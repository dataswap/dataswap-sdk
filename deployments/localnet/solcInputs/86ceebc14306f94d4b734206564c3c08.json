{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../extensions/IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"./IGovernorCompatibilityBravoUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Compatibility layer that implements GovernorBravo compatibility on top of {Governor}.\n *\n * This compatibility layer includes a voting system and requires a {IGovernorTimelock} compatible module to be added\n * through inheritance. It does not include token bindings, nor does it include any variable upgrade patterns.\n *\n * NOTE: When using this module, you may need to enable the Solidity optimizer to avoid hitting the contract size limit.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCompatibilityBravoUpgradeable is Initializable, IGovernorTimelockUpgradeable, IGovernorCompatibilityBravoUpgradeable, GovernorUpgradeable {\n    function __GovernorCompatibilityBravo_init() internal onlyInitializing {\n    }\n\n    function __GovernorCompatibilityBravo_init_unchained() internal onlyInitializing {\n    }\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalDetails {\n        address proposer;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        mapping(address => Receipt) receipts;\n        bytes32 descriptionHash;\n    }\n\n    mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=bravo\";\n    }\n\n    // ============================================== Proposal lifecycle ==============================================\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {\n        // Stores the proposal details (if not already present) and executes the propose logic from the core.\n        _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(signatures.length == calldatas.length, \"GovernorBravo: invalid signatures length\");\n        // Stores the full proposal and fallback to the public (possibly overridden) propose. The fallback is done\n        // after the full proposal is stored, so the store operation included in the fallback will be skipped. Here we\n        // call `propose` and not `super.propose` to make sure if a child contract override `propose`, whatever code\n        // is added there is also executed when calling this alternative interface.\n        _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n        return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-queue}.\n     */\n    function queue(uint256 proposalId) public virtual override {\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        ) = _getProposalParameters(proposalId);\n\n        queue(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-execute}.\n     */\n    function execute(uint256 proposalId) public payable virtual override {\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        ) = _getProposalParameters(proposalId);\n\n        execute(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Cancel a proposal with GovernorBravo logic.\n     */\n    function cancel(uint256 proposalId) public virtual override {\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        ) = _getProposalParameters(proposalId);\n\n        cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Cancel a proposal with GovernorBravo logic. At any moment a proposal can be cancelled, either by the\n     * proposer, or by third parties if the proposer's voting power has dropped below the proposal threshold.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        address proposer = _proposalDetails[proposalId].proposer;\n\n        require(\n            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),\n            \"GovernorBravo: proposer above threshold\"\n        );\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Encodes calldatas with optional function signature.\n     */\n    function _encodeCalldata(\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) private pure returns (bytes[] memory) {\n        bytes[] memory fullcalldatas = new bytes[](calldatas.length);\n        for (uint256 i = 0; i < fullcalldatas.length; ++i) {\n            fullcalldatas[i] = bytes(signatures[i]).length == 0\n                ? calldatas[i]\n                : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);\n        }\n\n        return fullcalldatas;\n    }\n\n    /**\n     * @dev Retrieve proposal parameters by id, with fully encoded calldatas.\n     */\n    function _getProposalParameters(\n        uint256 proposalId\n    )\n        private\n        view\n        returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return (\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev Store proposal metadata (if not already present) for later lookup.\n     */\n    function _storeProposal(\n        address proposer,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) private {\n        bytes32 descriptionHash = keccak256(bytes(description));\n        uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        if (details.descriptionHash == bytes32(0)) {\n            details.proposer = proposer;\n            details.targets = targets;\n            details.values = values;\n            details.signatures = signatures;\n            details.calldatas = calldatas;\n            details.descriptionHash = descriptionHash;\n        }\n    }\n\n    // ==================================================== Views =====================================================\n    /**\n     * @dev See {IGovernorCompatibilityBravo-proposals}.\n     */\n    function proposals(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        )\n    {\n        id = proposalId;\n        eta = proposalEta(proposalId);\n        startBlock = proposalSnapshot(proposalId);\n        endBlock = proposalDeadline(proposalId);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        proposer = details.proposer;\n        forVotes = details.forVotes;\n        againstVotes = details.againstVotes;\n        abstainVotes = details.abstainVotes;\n\n        ProposalState currentState = state(proposalId);\n        canceled = currentState == ProposalState.Canceled;\n        executed = currentState == ProposalState.Executed;\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getActions}.\n     */\n    function getActions(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        override\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return (details.targets, details.values, details.signatures, details.calldatas);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getReceipt}.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {\n        return _proposalDetails[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-quorumVotes}.\n     */\n    function quorumVotes() public view virtual override returns (uint256) {\n        return quorum(clock() - 1);\n    }\n\n    // ==================================================== Voting ====================================================\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalDetails[proposalId].receipts[account].hasVoted;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}. In this module, only forVotes count toward the quorum.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= details.forVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return details.forVotes > details.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows Governor Bravo.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        Receipt storage receipt = details.receipts[account];\n\n        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = SafeCastUpgradeable.toUint96(weight);\n\n        if (support == uint8(VoteType.Against)) {\n            details.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            details.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            details.abstainVotes += weight;\n        } else {\n            revert(\"GovernorCompatibilityBravo: invalid vote type\");\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/compatibility/IGovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface extension that adds missing functions to the {Governor} core to provide `GovernorBravo` compatibility.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorCompatibilityBravoUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorCompatibilityBravo_init() internal onlyInitializing {\n    }\n\n    function __IGovernorCompatibilityBravo_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Proposal structure from Compound Governor Bravo. Not actually used by the compatibility layer, as\n     * {{proposal}} returns a very different structure.\n     */\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        bool canceled;\n        bool executed;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev Receipt structure from Compound Governor Bravo\n     */\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface.\n     */\n    function quorumVotes() public view virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The official record of all proposals ever proposed\"_.\n     */\n    function proposals(\n        uint256\n    )\n        public\n        view\n        virtual\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Function used to propose a new proposal\"_.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Queues a proposal of state succeeded\"_.\n     */\n    function queue(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Executes a queued proposal if eta has passed\"_.\n     */\n    function execute(uint256 proposalId) public payable virtual;\n\n    /**\n     * @dev Cancels a proposal only if the sender is the proposer or the proposer delegates' voting power dropped below the proposal threshold.\n     */\n    function cancel(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets actions of a proposal\"_.\n     */\n    function getActions(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets the receipt for a voter on a given proposal\"_.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual returns (Receipt memory);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotesUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;\n\n    uint256 private _quorumNumerator; // DEPRECATED in favor of _quorumNumeratorHistory\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    CheckpointsUpgradeable.Trace224 private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        // If history is empty, fallback to old storage\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n        if (length == 0) {\n            return _quorumNumerator;\n        }\n\n        // Optimistic search, check the latest checkpoint\n        CheckpointsUpgradeable.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];\n        if (latest._key <= timepoint) {\n            return latest._value;\n        }\n\n        // Otherwise, do the binary search\n        return _quorumNumeratorHistory.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n\n        // Make sure we keep track of the original numerator in contracts upgraded from a version without checkpoints.\n        if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {\n            _quorumNumeratorHistory._checkpoints.push(\n                CheckpointsUpgradeable.Checkpoint224({_key: 0, _value: SafeCastUpgradeable.toUint224(oldQuorumNumerator)})\n            );\n        }\n\n        // Set new quorum for future proposals\n        _quorumNumeratorHistory.push(SafeCastUpgradeable.toUint32(clock()), SafeCastUpgradeable.toUint224(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n *\n * @custom:storage-size 51\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    IERC5805Upgradeable public token;\n\n    function __GovernorVotes_init(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        token = IERC5805Upgradeable(address(tokenAddress));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token.clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCastUpgradeable.toUint48(block.number);\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token.CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, timepoint);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal onlyInitializing {\n    }\n\n    function __IGovernorTimelock_init_unchained() internal onlyInitializing {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.1) (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/structs/DoubleEndedQueueUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");\n\n    // solhint-disable var-name-mixedcase\n    struct ProposalCore {\n        // --- start retyped from Timers.BlockNumber at offset 0x00 ---\n        uint64 voteStart;\n        address proposer;\n        bytes4 __gap_unused0;\n        // --- start retyped from Timers.BlockNumber at offset 0x20 ---\n        uint64 voteEnd;\n        bytes24 __gap_unused1;\n        // --- Remaining fields starting at offset 0x40 ---------------\n        bool executed;\n        bool canceled;\n    }\n    // solhint-enable var-name-mixedcase\n\n    string private _name;\n\n    /// @custom:oz-retyped-from mapping(uint256 => Governor.ProposalCore)\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueueUpgradeable.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this), \"Governor: must send to executor\");\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        bytes4 governorCancelId = this.cancel.selector ^ this.proposalProposer.selector;\n\n        bytes4 governorParamsId = this.castVoteWithReasonAndParams.selector ^\n            this.castVoteWithReasonAndParamsBySig.selector ^\n            this.getVotesWithParams.selector;\n\n        // The original interface id in v4.3.\n        bytes4 governor43Id = type(IGovernorUpgradeable).interfaceId ^\n            type(IERC6372Upgradeable).interfaceId ^\n            governorCancelId ^\n            governorParamsId;\n\n        // An updated interface id in v4.6, with params added.\n        bytes4 governor46Id = type(IGovernorUpgradeable).interfaceId ^ type(IERC6372Upgradeable).interfaceId ^ governorCancelId;\n\n        // For the updated interface id in v4.9, we use governorCancelId directly.\n\n        return\n            interfaceId == governor43Id ||\n            interfaceId == governor46Id ||\n            interfaceId == governorCancelId ||\n            interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Returns the account that created a given proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual override returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");\n\n        uint256 currentTimepoint = clock();\n        require(\n            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n        require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");\n\n        uint256 snapshot = currentTimepoint + votingDelay();\n        uint256 deadline = snapshot + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            proposer: proposer,\n            voteStart: SafeCastUpgradeable.toUint64(snapshot),\n            voteEnd: SafeCastUpgradeable.toUint64(deadline),\n            executed: false,\n            canceled: false,\n            __gap_unused0: 0,\n            __gap_unused1: 0\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n        require(\n            currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");\n        require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256 /* proposalId */,\n        address[] memory /* targets */,\n        uint256[] memory /* values */,\n        bytes[] memory /* calldatas */,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n\n        require(\n            currentState != ProposalState.Canceled &&\n                currentState != ProposalState.Expired &&\n                currentState != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart, params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        AddressUpgradeable.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        uint256 len = bytes(description).length;\n\n        // Length is too short to contain a valid proposer suffix\n        if (len < 52) {\n            return true;\n        }\n\n        // Extract what would be the `#proposer=0x` marker beginning the suffix\n        bytes12 marker;\n        assembly {\n            // - Start of the string contents in memory = description + 32\n            // - First character of the marker = len - 52\n            //   - Length of \"#proposer=0x0000000000000000000000000000000000000000\" = 52\n            // - We read the memory word starting at the first character of the marker:\n            //   - (description + 32) + (len - 52) = description + (len - 20)\n            // - Note: Solidity will ignore anything past the first 12 bytes\n            marker := mload(add(description, sub(len, 20)))\n        }\n\n        // If the marker is not found, there is no proposer suffix to check\n        if (marker != bytes12(\"#proposer=0x\")) {\n            return true;\n        }\n\n        // Parse the 40 characters following the marker as uint160\n        uint160 recovered = 0;\n        for (uint256 i = len - 40; i < len; ++i) {\n            (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);\n            // If any of the characters is not a hex digit, ignore the suffix entirely\n            if (!isHex) {\n                return true;\n            }\n            recovered = (recovered << 4) | value;\n        }\n\n        return recovered == uint160(proposer);\n    }\n\n    /**\n     * @dev Try to parse a character from a string as a hex value. Returns `(true, value)` if the char is in\n     * `[0-9a-fA-F]` and `(false, 0)` otherwise. Value is guaranteed to be in the range `0 <= value < 16`\n     */\n    function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {\n        uint8 c = uint8(char);\n        unchecked {\n            // Case 0-9\n            if (47 < c && c < 58) {\n                return (true, c - 48);\n            }\n            // Case A-F\n            else if (64 < c && c < 71) {\n                return (true, c - 55);\n            }\n            // Case a-f\n            else if (96 < c && c < 103) {\n                return (true, c - 87);\n            }\n            // Else: not a hex char\n            else {\n                return (false, 0);\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165Upgradeable.sol\";\nimport \"../interfaces/IERC6372Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable, IERC6372Upgradeable {\n    function __IGovernor_init() internal onlyInitializing {\n    }\n\n    function __IGovernor_init_unchained() internal onlyInitializing {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual override returns (uint48);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual returns (address);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotesUpgradeable.sol\";\nimport \"./IERC6372Upgradeable.sol\";\n\ninterface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372Upgradeable {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitUpgradeable.sol\";\nimport \"../../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable, IERC5805Upgradeable {\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCastUpgradeable.toUint48(block.number);\n    }\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"ERC20Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n        }\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_checkpoints[account], timepoint);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\n     * It is NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\n        //\n        // Initially we check if the block is recent to narrow the search range.\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\n        // the same.\n        uint256 length = ckpts.length;\n\n        uint256 low = 0;\n        uint256 high = length;\n\n        if (length > 5) {\n            uint256 mid = length - MathUpgradeable.sqrt(length);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        unchecked {\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\n        }\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n\n        unchecked {\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\n\n            oldWeight = oldCkpt.votes;\n            newWeight = op(oldWeight, delta);\n\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);\n            } else {\n                ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(clock()), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, ckpts.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "solidity-cborutils/contracts/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "src/v0.8/core/access/Roles.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\n\n/// @title Role Contract\n/// @notice This contract defines the role-based access control for various roles within the system.\ncontract Roles is\n    Initializable,\n    IRoles,\n    UUPSUpgradeable,\n    OwnableUpgradeable,\n    Ownable2StepUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize() public initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyOwner // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    ///@dev The new owner accepts the ownership transfer.\n    function acceptOwnership()\n        public\n        override(IRoles, Ownable2StepUpgradeable)\n    {\n        return super.acceptOwnership();\n    }\n\n    ///@dev check msg.sender is admin role.\n    function checkRole(bytes32 _role) public view {\n        return super._checkRole(_role);\n    }\n\n    ///@dev Returns the address of the current owner.\n    function owner()\n        public\n        view\n        override(IRoles, OwnableUpgradeable)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    ///@dev Returns the address of the pending owner.\n    function pendingOwner()\n        public\n        view\n        override(IRoles, Ownable2StepUpgradeable)\n        returns (address)\n    {\n        return super.pendingOwner();\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public override(IRoles, OwnableUpgradeable) {\n        super.renounceOwnership();\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(\n        address _newOwner\n    ) public override(IRoles, OwnableUpgradeable, Ownable2StepUpgradeable) {\n        super.transferOwnership(_newOwner);\n    }\n\n    /// @dev start the ownership transfer\n    function _transferOwnership(\n        address _newOwner\n    ) internal override(OwnableUpgradeable, Ownable2StepUpgradeable) {\n        super._transferOwnership(_newOwner);\n    }\n}\n"
    },
    "src/v0.8/core/carstore/abstract/CarstoreBase.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\n///shared\nimport {CarstoreModifiers} from \"../../../shared/modifiers/CarstoreModifiers.sol\";\n///library\nimport {CarLIB} from \"../library/CarLIB.sol\";\n///type\nimport {CarReplicaType} from \"../../../types/CarReplicaType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @title CarsStorageBase\n/// @notice This contract allows adding cars and managing their associated replicas.\n/// @dev This contract provides functionality for managing car data and associated replicas.\nabstract contract CarstoreBase is Initializable, ICarstore, CarstoreModifiers {\n    using CarLIB for CarReplicaType.Car;\n\n    uint64 public carsCount;\n    ///Car CID=> Car\n    mapping(bytes32 => CarReplicaType.Car) internal cars;\n    mapping(uint64 => bytes32) internal carsIndexes;\n\n    IRoles internal roles;\n    IFilplus public filplus;\n    IFilecoin public filecoin;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice carstoreBaseInitialize function to initialize the contract and grant the default admin role to the deployer.\n    function carstoreBaseInitialize(\n        address _roles,\n        address _filplus,\n        address _filecoin\n    ) public virtual onlyInitializing {\n        roles = IRoles(_roles);\n        filplus = IFilplus(_filplus);\n        filecoin = IFilecoin(_filecoin);\n    }\n\n    /// @notice Post an event for a car's replica based on the matching ID, triggering state transitions.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _event Event to be posted.\n    function _emitRepicaEvent(\n        uint64 _id,\n        uint64 _matchingId,\n        CarReplicaType.Event _event\n    )\n        internal\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n    {\n        CarReplicaType.Car storage car = _getCar(_id);\n        car._emitRepicaEvent(_matchingId, _event);\n    }\n\n    /// @notice Get the car ID associated with a car.\n    /// @param _id Car ID to check.\n    /// @return The car struct.\n    function _getCar(\n        uint64 _id\n    ) internal view returns (CarReplicaType.Car storage) {\n        bytes32 cid = carsIndexes[_id];\n        return cars[cid];\n    }\n\n    /// @notice Get a hash of a car based on car id.\n    /// @param _id The car's id to get hash.\n    /// @return  The hash of the car.\n    function _getHash(uint64 _id) internal view returns (bytes32) {\n        return carsIndexes[_id];\n    }\n\n    /// @notice Get car's id based on car's hash.\n    /// @param _hash The car's hash to get ID.\n    /// @return  The id of the car.\n    function _getId(bytes32 _hash) internal view returns (uint64) {\n        return cars[_hash].id;\n    }\n}\n"
    },
    "src/v0.8/core/carstore/Carstore.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n///shared\nimport {CarstoreEvents} from \"src/v0.8/shared/events/CarstoreEvents.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n///library\nimport {CarLIB} from \"src/v0.8/core/carstore/library/CarLIB.sol\";\n///abstract\nimport {CarstoreBase} from \"src/v0.8/core/carstore/abstract/CarstoreBase.sol\";\n///type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title CarsStorageBase\n/// @notice This contract allows adding cars and managing their associated replicas.\n/// @dev This contract provides functionality for managing car data and associated replicas.\ncontract Carstore is Initializable, UUPSUpgradeable, CarstoreBase {\n    using CarLIB for CarReplicaType.Car;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _roles,\n        address _filplus,\n        address _filecoin\n    ) public initializer {\n        CarstoreBase.carstoreBaseInitialize(_roles, _filplus, _filecoin);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Internal function to add a car based on its CID.\n    ///      tips: diffent dataset has the same car is dones't matter,maybe need limit replicas count for a car.\n    ///      filplus requires dataset replicas,but not limit for car replicas\n    /// @param _cid Car CID to be added.\n    /// @param _datasetId dataset index of approved dataset\n    /// @param _size size of car\n    /// @param _replicaCount count of car's replicas\n    function addCar(\n        bytes32 _cid,\n        uint64 _datasetId,\n        uint64 _size,\n        uint16 _replicaCount\n    )\n        public\n        onlyCarNotExist(this, _cid)\n        onlyNotZero(_datasetId)\n        onlyNotZero(_size)\n        returns (uint64)\n    {\n        carsCount++;\n        CarReplicaType.Car storage car = cars[_cid];\n        car._setDatasetId(_datasetId);\n        car._initRepicas(_replicaCount);\n        car.id = carsCount;\n        car.size = _size;\n        carsIndexes[carsCount] = _cid;\n        return car.id;\n    }\n\n    /// @notice Add multiple cars to the storage.\n    /// @dev This function allows the addition of multiple cars at once.\n    /// @param _cids Array of car CIDs to be added.\n    /// @param _datasetId dataset index of approved dataset\n    /// @param _sizes car size array\n    /// @param _replicaCount count of car's replicas\n    /// @return The ids of the cars and the size.\n    function addCars(\n        bytes32[] memory _cids,\n        uint64 _datasetId,\n        uint64[] memory _sizes,\n        uint16 _replicaCount\n    ) external onlyNotZero(_datasetId) returns (uint64[] memory, uint64) {\n        require(_cids.length == _sizes.length, \"Invalid params\");\n        uint64 totalSize;\n        uint64[] memory ids = new uint64[](_cids.length);\n        for (uint64 i; i < _cids.length; i++) {\n            ids[i] = addCar(_cids[i], _datasetId, _sizes[i], _replicaCount);\n            totalSize += _sizes[i];\n        }\n\n        emit CarstoreEvents.CarsAdded(_cids);\n        return (ids, totalSize);\n    }\n\n    /// @notice Regist a replica to a car.\n    /// @dev This function allows adding a replica to an existing car.\n    /// @param _id Car ID to which the replica will be added.\n    /// @param _matchingId Matching ID for the new replica.\n    /// @param _replicaIndex The index of the replica.\n    function registCarReplica(\n        uint64 _id,\n        uint64 _matchingId,\n        uint16 _replicaIndex\n    )\n        external\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaNotExist(this, _id, _matchingId)\n    {\n        CarReplicaType.Car storage car = _getCar(_id);\n        require(\n            _replicaIndex < car._getRepicasCount(),\n            \"Invalid replica index\"\n        );\n\n        car._registRepica(_matchingId, _replicaIndex);\n\n        emit CarstoreEvents.CarReplicaRegisted(_id, _matchingId, _replicaIndex);\n    }\n\n    /// @notice Report that matching's state for a replica.\n    /// @dev This function allows reporting that the matching for a replica is failed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _matchingState Matching's state of the replica, true for success ,false for failed.\n    function reportCarReplicaMatchingState(\n        uint64 _id,\n        uint64 _matchingId,\n        bool _matchingState\n    )\n        external\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n    {\n        if (_matchingState) {\n            _emitRepicaEvent(\n                _id,\n                _matchingId,\n                CarReplicaType.Event.MatchingCompleted\n            );\n            emit CarstoreEvents.CarReplicaMatchingState(\n                _id,\n                _matchingId,\n                \"success\"\n            );\n        } else {\n            _emitRepicaEvent(\n                _id,\n                _matchingId,\n                CarReplicaType.Event.MatchingFailed\n            );\n            emit CarstoreEvents.CarReplicaMatchingState(\n                _id,\n                _matchingId,\n                \"failed\"\n            );\n        }\n    }\n\n    function _checkCarReplicaDealState(\n        uint64 _id,\n        uint64 _claimId,\n        FilecoinType.DealState _dealState\n    ) internal {\n        if (\n            _dealState !=\n            filecoin.getReplicaDealState(getCarHash(_id), _claimId)\n        ) {\n            revert Errors.InvalidReplicaFilecoinDealState(_id, _claimId);\n        }\n    }\n\n    /// @notice Report that storage deal for a replica has expired.\n    /// @dev This function allows reporting that the storage deal for a replica has expired.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    function reportCarReplicaExpired(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    )\n        external\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n        onlyCarReplicaState(this, _id, _matchingId, CarReplicaType.State.Stored)\n    {\n        _checkCarReplicaDealState(\n            _id,\n            _claimId,\n            FilecoinType.DealState.Expired\n        );\n        _emitRepicaEvent(\n            _id,\n            _matchingId,\n            CarReplicaType.Event.StorageDealExpired\n        );\n        emit CarstoreEvents.CarReplicaExpired(_id, _matchingId);\n    }\n\n    /// @notice Report that storage of a replica has been slashed.\n    /// @dev This function allows reporting that the storage of a replica has been slashed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    function reportCarReplicaSlashed(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    )\n        external\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n        onlyCarReplicaState(this, _id, _matchingId, CarReplicaType.State.Stored)\n    {\n        _checkCarReplicaDealState(\n            _id,\n            _claimId,\n            FilecoinType.DealState.Slashed\n        );\n        _emitRepicaEvent(_id, _matchingId, CarReplicaType.Event.StorageSlashed);\n        emit CarstoreEvents.CarReplicaSlashed(_id, _matchingId);\n    }\n\n    /// @dev Modifier to ensure that a replica state before function do.\n    function _checkCarReplicaState(\n        uint64 _id,\n        uint64 _matchingId,\n        CarReplicaType.State _state\n    ) internal view {\n        if (_state != getCarReplicaState(_id, _matchingId)) {\n            revert Errors.InvalidReplicaState(_id, _matchingId);\n        }\n    }\n\n    /// @notice Set the Filecoin claim ID for a replica's storage.\n    /// @dev This function allows setting the Filecoin claim ID for a specific replica's storage.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _claimId New Filecoin claim ID to set for the replica's storage.\n    function setCarReplicaFilecoinClaimId(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    )\n        external\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyNotZero(_claimId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n        onlyUnsetCarReplicaFilecoinClaimId(this, _id, _matchingId)\n    {\n        _checkCarReplicaState(_id, _matchingId, CarReplicaType.State.Matched);\n        bytes32 _hash = _getHash(_id);\n        CarReplicaType.Car storage car = _getCar(_id);\n        car._setReplicaFilecoinClaimId(_hash, _matchingId, _claimId, filecoin);\n\n        emit CarstoreEvents.CarReplicaFilecoinClaimIdSet(\n            _id,\n            _matchingId,\n            _claimId\n        );\n    }\n\n    /// @notice Get the dataset ID associated with a car.\n    /// @param _id Car ID to check.\n    /// @return The car size of the car.\n    function getCarSize(\n        uint64 _id\n    ) public view onlyCarExist(this, _id) returns (uint64) {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car.size;\n    }\n\n    /// @notice Get the total size of cars based on an array of car IDs.\n    /// @param _ids An array of car IDs for which to calculate the size.\n    /// @return The total size of cars.\n    function getCarsSize(uint64[] memory _ids) public view returns (uint64) {\n        uint64 size = 0;\n        for (uint64 i = 0; i < _ids.length; i++) {\n            size += getCarSize(_ids[i]);\n        }\n        return size;\n    }\n\n    /// @notice Get the dataset ID associated with a car.\n    /// @param _id Car ID to check.\n    /// @return The dataset ID of the car.\n    function getCarDatasetId(uint64 _id) public view returns (uint64) {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._getDatasetId();\n    }\n\n    /// @notice Get the matching ids of a replica associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @return The matching ids of the car's replica.\n    function getCarMatchingIds(\n        uint64 _id\n    ) public view onlyCarExist(this, _id) returns (uint64[] memory) {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._getMatchingIds();\n    }\n\n    /// @notice Get the replica details associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The dataset ID, state, and Filecoin claim ID of the replica.\n    function getCarReplica(\n        uint64 _id,\n        uint64 _matchingId\n    )\n        public\n        view\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n        returns (CarReplicaType.State, uint64)\n    {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return (\n            car._getReplicaState(_matchingId),\n            car._getReplicaFilecoinClaimId(_matchingId)\n        );\n    }\n\n    /// @notice Get the count of replicas associated with a car.\n    /// @dev This function returns the number of replicas associated with a car.\n    /// @param _id Car ID for which to retrieve the replica count.\n    /// @return The count of replicas associated with the car.\n    function getCarReplicasCount(\n        uint64 _id\n    ) public view onlyCarExist(this, _id) returns (uint16) {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._getRepicasCount();\n    }\n\n    /// @notice Get the Filecoin claim ID associated with a specific replica of a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The Filecoin claim ID of the replica.\n    function getCarReplicaFilecoinClaimId(\n        uint64 _id,\n        uint64 _matchingId\n    )\n        public\n        view\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        onlyCarReplicaExist(this, _id, _matchingId)\n        returns (uint64)\n    {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._getReplicaFilecoinClaimId(_matchingId);\n    }\n\n    /// @notice Get the state of a replica associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The state of the replica.\n    function getCarReplicaState(\n        uint64 _id,\n        uint64 _matchingId\n    )\n        public\n        view\n        onlyCarExist(this, _id)\n        onlyNotZero(_matchingId)\n        returns (CarReplicaType.State)\n    {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._getReplicaState(_matchingId);\n    }\n\n    /// @notice Get the hash of car based on the car id.\n    /// @param _id Car ID which to get car hash.\n    /// @return The hash of the car.\n    function getCarHash(uint64 _id) public view returns (bytes32) {\n        return _getHash(_id);\n    }\n\n    /// @notice Get the hashs of cars based on an array of car IDs.\n    /// @param _ids An array of car IDs for which to get car hashs.\n    /// @return The hashs of cars.\n    function getCarsHashs(\n        uint64[] memory _ids\n    ) public view returns (bytes32[] memory) {\n        bytes32[] memory hashs = new bytes32[](_ids.length);\n        for (uint64 i = 0; i < _ids.length; i++) {\n            hashs[i] = _getHash(_ids[i]);\n        }\n        return hashs;\n    }\n\n    /// @notice Get the car's id based on the car's hash.\n    /// @param _hash The hash which to get car id.\n    /// @return The id of the car.\n    function getCarId(bytes32 _hash) public view returns (uint64) {\n        return _getId(_hash);\n    }\n\n    /// @notice Get the ids of cars based on an array of car hashs.\n    /// @param _hashs An array of car hashs for which to cat car hashs.\n    /// @return The ids of cars.\n    function getCarsIds(\n        bytes32[] memory _hashs\n    ) public view returns (uint64[] memory) {\n        uint64[] memory ids = new uint64[](_hashs.length);\n        for (uint64 i = 0; i < _hashs.length; i++) {\n            ids[i] = _getId(_hashs[i]);\n        }\n        return ids;\n    }\n\n    /// @notice Check if a car exists based on its Hash.\n    /// @dev This function returns whether a car exists or not.\n    /// @param _hash Car Hash to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCarHash(bytes32 _hash) public view returns (bool) {\n        CarReplicaType.Car storage car = cars[_hash];\n        return car.datasetId != 0;\n    }\n\n    /// @notice Check if a car exists based on its ID.\n    /// @dev This function returns whether a car exists or not.\n    /// @param _id Car ID to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCar(uint64 _id) public view returns (bool) {\n        require(_id != 0, \"Invalid car id\");\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car.id == _id;\n    }\n\n    /// @notice Check if a replica exists within a car based on its matching ID.\n    /// @dev This function returns whether a replica with the specified matching ID exists within a car or not.\n    /// @param _id Car ID to check.\n    /// @param _matchingId Matching ID of the replica to check.\n    /// @return True if the replica exists, false otherwise.\n    function hasCarReplica(\n        uint64 _id,\n        uint64 _matchingId\n    ) public view onlyCarExist(this, _id) returns (bool) {\n        CarReplicaType.Car storage car = _getCar(_id);\n        return car._hasReplica(_matchingId);\n    }\n\n    /// @notice Check if a car exists based on its Hashs.\n    /// @dev This function returns whether a car exists or not.\n    /// @param _hashs  Array of car Hashs to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCarsHashs(bytes32[] memory _hashs) public view returns (bool) {\n        for (uint64 i; i < _hashs.length; i++) {\n            if (!hasCarHash(_hashs[i])) return false;\n        }\n        return true;\n    }\n\n    /// @notice Check if multiple cars exist based on their IDs.\n    /// @dev This function returns whether all the specified cars exist or not.\n    /// @param _ids Array of car IDs to check.\n    /// @return True if all specified cars exist, false if any one does not exist.\n    function hasCars(uint64[] memory _ids) public view returns (bool) {\n        for (uint64 i; i < _ids.length; i++) {\n            if (!hasCar(_ids[i])) return false;\n        }\n        return true;\n    }\n}\n"
    },
    "src/v0.8/core/carstore/library/CarLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\nimport {CarReplicaLIB} from \"src/v0.8/core/carstore/library/CarReplicaLIB.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\n\n/// @title CarLIB\n/// @dev This library provides functions for managing the lifecycle and events of car and their replicas.\n/// @notice Library for managing the state, events, and operations related to car and their replicas.\nlibrary CarLIB {\n    using CarReplicaLIB for CarReplicaType.Replica;\n\n    /// @notice Add a new replica to a car.\n    /// @dev Requires a non-zero matching ID and that the replica does not already exist.\n    ///      This should be called by an external dataset contract after a dataset be approved.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID for the new replica.\n    /// @param _replicaIndex The index of the replica.\n    function _registRepica(\n        CarReplicaType.Car storage self,\n        uint64 _matchingId,\n        uint16 _replicaIndex\n    ) internal {\n        require(_matchingId != 0, \"Invalid matching id\");\n        require(!_hasReplica(self, _matchingId), \"Replica already exists\");\n\n        CarReplicaType.Replica storage replica = self.replicas[_replicaIndex];\n\n        if (replica.matchingId == 0) {\n            require(\n                replica.state == CarReplicaType.State.None,\n                \"Invalid car state\"\n            );\n        } else {\n            require(!replica._isStateValid(), \"Replica state not match\");\n        }\n\n        replica._init(_matchingId);\n        self.replicaIndex[_matchingId] = _replicaIndex;\n    }\n\n    /// @notice Initialize replica information for the car.\n    /// @param self The reference to the car storage.\n    /// @param _replicaCount The total number of storage replicas submitted by the client for the car.\n    function _initRepicas(\n        CarReplicaType.Car storage self,\n        uint16 _replicaCount\n    ) internal {\n        require(self.replicas.length == 0, \"Replica is not empty\");\n        for (uint16 index = 0; index < _replicaCount; index++) {\n            CarReplicaType.Replica memory newReplica;\n            self.replicas.push(newReplica);\n        }\n    }\n\n    /// @notice Post an event for a car's replica based on the matching ID, triggering state transitions.\n    /// @dev The state transition is based on the event and the current state of the replica.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID of the replica.\n    /// @param _event The event to post.\n    function _emitRepicaEvent(\n        CarReplicaType.Car storage self,\n        uint64 _matchingId,\n        CarReplicaType.Event _event\n    ) internal {\n        require(_hasReplica(self, _matchingId), \"Replica is not exists\");\n        uint16 index = self.replicaIndex[_matchingId];\n        CarReplicaType.Replica storage replica = self.replicas[index];\n\n        replica._emitEvent(_event);\n    }\n\n    /// @notice Set the dataset ID for a car\n    /// @dev Requires a non-zero matching ID and that the replica already exists.\n    ///      This should be called by an external matching contract after a successful matching process.\n    /// @param self The reference to the car storage.\n    /// @param _datasetId The new dataset ID for car to set.\n    function _setDatasetId(\n        CarReplicaType.Car storage self,\n        uint64 _datasetId\n    ) internal {\n        require(\n            _datasetId != 0 && _datasetId != self.datasetId,\n            \"Invalid dataset id\"\n        );\n        self.datasetId = _datasetId;\n    }\n\n    /// @notice Set the replica filecoin claim ID for a car's replica.\n    /// @dev Requires non-zero matching ID and Filecoin claim ID, and that the replica exists.\n    ///      This should be called by an external storage deal contract after a successful storage deal process.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID of the replica.\n    /// @param _claimId The new Filecoin claim ID to set.\n    function _setReplicaFilecoinClaimId(\n        CarReplicaType.Car storage self,\n        bytes32 _cid,\n        uint64 _matchingId,\n        uint64 _claimId,\n        IFilecoin _filecoin\n    ) internal {\n        require(_matchingId != 0, \"Invalid matching id\");\n        require(_claimId != 0, \"Invalid filecoin claim id\");\n        require(_hasReplica(self, _matchingId), \"Replica is not exists\");\n        uint16 index = self.replicaIndex[_matchingId];\n        CarReplicaType.Replica storage replica = self.replicas[index];\n\n        replica._setFilecoinClaimId(_claimId);\n\n        if (\n            FilecoinType.DealState.Stored ==\n            _filecoin.getReplicaDealState(_cid, _claimId)\n        ) {\n            _emitRepicaEvent(\n                self,\n                _matchingId,\n                CarReplicaType.Event.StorageCompleted\n            );\n        } else {\n            _emitRepicaEvent(\n                self,\n                _matchingId,\n                CarReplicaType.Event.StorageFailed\n            );\n        }\n    }\n\n    /// @notice Get the dataset ID associated with a car.\n    /// @dev Retrieves the dataset ID associated with the car.\n    /// @param self The reference to the car storage.\n    /// @return The dataset ID of the car.\n    function _getDatasetId(\n        CarReplicaType.Car storage self\n    ) internal view returns (uint64) {\n        return self.datasetId;\n    }\n\n    /// @notice Get the matching ids of a replica associated with a car.\n    /// @param self The reference to the car storage.\n    /// @return The matching ids of the car's replica.\n    function _getMatchingIds(\n        CarReplicaType.Car storage self\n    ) internal view returns (uint64[] memory) {\n        uint64[] memory matchings = new uint64[](self.replicas.length);\n        for (uint64 i = 0; i < self.replicas.length; i++) {\n            if (self.replicas[i]._isStateValid()) {\n                matchings[i] = self.replicas[i].matchingId;\n            }\n        }\n        return matchings;\n    }\n\n    /// @notice Get the count of replicas associated with a car.\n    /// @dev Retrieves the count of replicas associated with the car.\n    /// @param self The reference to the car storage.\n    /// @return The count of replicas.\n    function _getRepicasCount(\n        CarReplicaType.Car storage self\n    ) internal view returns (uint16) {\n        return uint16(self.replicas.length);\n    }\n\n    /// @notice Get the count of valid replicas associated with a car.\n    /// @dev Retrieves the count of replicas associated with the car.\n    /// @param self The reference to the car storage.\n    /// @return The count of replicas.\n    function _getValidRepicasCount(\n        CarReplicaType.Car storage self\n    ) internal view returns (uint16) {\n        uint16 count = 0;\n        for (uint16 i = 0; i < self.replicas.length; i++) {\n            if (\n                self.replicas[i].state == CarReplicaType.State.None ||\n                self.replicas[i].state == CarReplicaType.State.Matched ||\n                self.replicas[i].state == CarReplicaType.State.Stored\n            ) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /// @notice Get the Filecoin claim ID associated with a specific replica of a car.\n    /// @dev Retrieves the Filecoin claim ID associated with the given matching ID of a replica.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID of the replica.\n    /// @return The Filecoin claim ID of the replica.\n    function _getReplicaFilecoinClaimId(\n        CarReplicaType.Car storage self,\n        uint64 _matchingId\n    ) internal view returns (uint64) {\n        require(_matchingId != 0, \"Invalid matching id\");\n        require(_hasReplica(self, _matchingId), \"Replica is not exists\");\n        uint16 index = self.replicaIndex[_matchingId];\n        CarReplicaType.Replica storage replica = self.replicas[index];\n        require(replica._isMatchingValid(_matchingId), \"Invalid matching id\");\n\n        return replica.filecoinClaimId;\n    }\n\n    /// @notice Get the state of a replica associated with a car.\n    /// @dev Retrieves the state of a replica based on the provided matching ID.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID of the replica.\n    /// @return The state of the replica.\n    function _getReplicaState(\n        CarReplicaType.Car storage self,\n        uint64 _matchingId\n    ) internal view returns (CarReplicaType.State) {\n        require(_matchingId != 0, \"Invalid matching id\");\n        uint16 index = self.replicaIndex[_matchingId];\n        require(index < self.replicas.length, \"Index out of bounds\");\n        CarReplicaType.Replica storage replica = self.replicas[index];\n        require(replica._isMatchingValid(_matchingId), \"Invalid matching id\");\n        return replica.state;\n    }\n\n    /// @notice Check if a replica with a specific matching ID exists for a car.\n    /// @dev Checks whether a replica with the given matching ID exists for the car.\n    /// @param self The reference to the car storage.\n    /// @param _matchingId The matching ID to check.\n    /// @return exists Whether the replica exists or not.\n    function _hasReplica(\n        CarReplicaType.Car storage self,\n        uint64 _matchingId\n    ) internal view returns (bool) {\n        require(_matchingId != 0, \"Invalid matching id\");\n        uint16 index = self.replicaIndex[_matchingId];\n        if (self.replicas.length == 0 || index >= self.replicas.length) {\n            return false;\n        }\n\n        CarReplicaType.Replica storage replica = self.replicas[index];\n        if (!replica._isMatchingValid(_matchingId)) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "src/v0.8/core/carstore/library/CarReplicaLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\n\n/// @title CarReplicaLIB\n/// @dev This library provides functions to manage the state and events of car replicas.\n/// @notice Library for managing the lifecycle and events of car replicas.\nlibrary CarReplicaLIB {\n    /// @notice Set the Filecoin claim ID for a car replica.\n    /// @dev Requires a non-zero new Filecoin claim ID and that it's different from the existing one.\n    ///      This should be called by an external storage deal contract after a successful storage deal process.\n    /// @param self The reference to the replica storage.\n    /// @param _claimId The new Filecoin claim ID to set.\n    function _setFilecoinClaimId(\n        CarReplicaType.Replica storage self,\n        uint64 _claimId\n    ) internal {\n        require(\n            _claimId != 0 && self.filecoinClaimId != _claimId,\n            \"Invalid params\"\n        );\n        self.filecoinClaimId = _claimId;\n    }\n\n    /// @notice Emit an event for a car replica, triggering state transitions.\n    /// @dev The state transition is based on the event and current state.\n    ///      Invalid transitions do not change the state.\n    /// @param self The reference to the replica storage.\n    /// @param _event The event to post.\n    function _emitEvent(\n        CarReplicaType.Replica storage self,\n        CarReplicaType.Event _event\n    ) internal {\n        CarReplicaType.State currentState = self.state;\n        CarReplicaType.State newState;\n\n        // Apply the state transition based on the event\n        if (_event == CarReplicaType.Event.MatchingFailed) {\n            if (currentState == CarReplicaType.State.None) {\n                newState = CarReplicaType.State.StorageFailed;\n            }\n        } else if (_event == CarReplicaType.Event.MatchingCompleted) {\n            if (currentState == CarReplicaType.State.None) {\n                newState = CarReplicaType.State.Matched;\n            }\n        } else if (_event == CarReplicaType.Event.StorageCompleted) {\n            if (currentState == CarReplicaType.State.Matched) {\n                newState = CarReplicaType.State.Stored;\n            }\n        } else if (_event == CarReplicaType.Event.StorageFailed) {\n            if (currentState == CarReplicaType.State.Matched) {\n                newState = CarReplicaType.State.StorageFailed;\n            }\n        } else if (_event == CarReplicaType.Event.StorageDealExpired) {\n            if (currentState == CarReplicaType.State.Stored) {\n                newState = CarReplicaType.State.Expired;\n            }\n        } else if (_event == CarReplicaType.Event.StorageSlashed) {\n            if (currentState == CarReplicaType.State.Stored) {\n                newState = CarReplicaType.State.Slashed;\n            }\n        }\n\n        /// @notice Update the state if newState is not Approved (i.e., a valid transition)\n        /// @dev The state variable self.state will be updated with the new state if newState is not Approved.\n        if (newState != CarReplicaType.State.None) {\n            self.state = newState;\n        }\n    }\n\n    /// @notice Check if a replica with a specific index valid or not.\n    /// @param self The reference to the replica storage.\n    /// @param _matchingId The matching ID of the replica.\n    function _init(\n        CarReplicaType.Replica storage self,\n        uint64 _matchingId\n    ) internal {\n        self.matchingId = _matchingId;\n        self.state = CarReplicaType.State.None;\n        self.filecoinClaimId = 0;\n    }\n\n    /// @notice Check if a replica with a specific index valid or not.\n    /// @param self The reference to the replica storage.\n    /// @param _matchingId The matching ID of the replica.\n    function _isMatchingValid(\n        CarReplicaType.Replica storage self,\n        uint64 _matchingId\n    ) internal view returns (bool) {\n        if (self.matchingId != _matchingId) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Check if a replica with a specific index valid or not.\n    /// @param self The reference to the replica storage.\n    function _isStateValid(\n        CarReplicaType.Replica storage self\n    ) internal view returns (bool) {\n        if (uint64(self.state) > uint64(CarReplicaType.State.Stored)) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "src/v0.8/core/filecoin/Filecoin.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {MarketAPI} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/MarketAPI.sol\";\nimport {VerifRegAPI} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/VerifRegAPI.sol\";\nimport {FilAddresses} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol\";\nimport {BigInts} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/BigInts.sol\";\nimport {MarketTypes} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\";\nimport {VerifRegTypes} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/VerifRegTypes.sol\";\nimport {CommonTypes} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\";\n///interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\n///type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\n\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Filecoin\ncontract Filecoin is Initializable, UUPSUpgradeable, IFilecoin, RolesModifiers {\n    FilecoinType.Network public network;\n    IRoles private roles;\n    address private datacapAddress;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        FilecoinType.Network _network,\n        address _roles\n    ) public initializer {\n        network = _network;\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice The function to init the dependencies of a filecoin.\n    function initDependencies(\n        address _datacap\n    ) external onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        datacapAddress = _datacap;\n    }\n\n    /// @notice The function to allocate the datacap of a storage deal.\n    function allocateDatacap(\n        uint64 client,\n        uint256 _size\n    ) external onlyAddress(datacapAddress) {\n        VerifRegTypes.AddVerifiedClientParams memory params = VerifRegTypes\n            .AddVerifiedClientParams(\n                FilAddresses.fromActorID(client),\n                BigInts.fromUint256(_size)\n            );\n        VerifRegAPI.addVerifiedClient(params);\n    }\n\n    /// @notice Internal function to get the state of a Filecoin storage deal for a replica.\n    /// @dev TODO:check _claimId belongs to the _cid, now filecoin-solidity is not support\n    ///           https://github.com/dataswap/core/issues/41\n    function getReplicaDealState(\n        bytes32 /*_cid*/,\n        uint64 _claimId\n    ) external returns (FilecoinType.DealState) {\n        //get expired info\n        MarketTypes.GetDealTermReturn memory dealTerm = MarketAPI.getDealTerm(\n            _claimId\n        );\n        if (\n            CommonTypes.ChainEpoch.unwrap(dealTerm.end) < int256(block.number)\n        ) {\n            return FilecoinType.DealState.Expired;\n        }\n\n        //get slashed info\n        // solhint-disable-next-line\n        MarketTypes.GetDealActivationReturn memory DealActivation = MarketAPI\n            .getDealActivation(_claimId);\n        if (\n            CommonTypes.ChainEpoch.unwrap(DealActivation.terminated) <\n            int256(block.number)\n        ) {\n            return FilecoinType.DealState.Slashed;\n        }\n\n        return FilecoinType.DealState.Stored;\n    }\n\n    /// @dev do nothing,just for mock\n    // solhint-disable-next-line\n    function setMockDealState(FilecoinType.DealState _state) external {}\n\n    /// @notice Internal function to get the claim of a Filecoin storage for a replica.\n    function getReplicaClaimData(\n        uint64 _provider,\n        uint64 _claimId\n    ) external returns (bytes memory) {\n        CommonTypes.FilActorId[] memory actorIds = new CommonTypes.FilActorId[](\n            1\n        );\n\n        actorIds[0] = CommonTypes.FilActorId.wrap(_claimId);\n\n        VerifRegTypes.GetClaimsParams memory params = VerifRegTypes\n            .GetClaimsParams(CommonTypes.FilActorId.wrap(_provider), actorIds);\n\n        VerifRegTypes.GetClaimsReturn memory claims = VerifRegAPI.getClaims(\n            params\n        );\n\n        require(claims.claims.length > 0, \"length mast greater than 0\");\n\n        return claims.claims[0].data;\n    }\n\n    /// @dev mock the filecoin claim data\n    // solhint-disable-next-line\n    function setMockClaimData(uint64 claimId, bytes memory _data) external {}\n}\n"
    },
    "src/v0.8/core/filplus/Filplus.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n///interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\n///shared\nimport {FilplusEvents} from \"src/v0.8/shared/events/FilplusEvents.sol\";\nimport \"src/v0.8/shared/utils/array/ArrayLIB.sol\";\n///type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Filplus\ncontract Filplus is Initializable, UUPSUpgradeable, IFilplus, RolesModifiers {\n    using ArrayUint16LIB for uint16[];\n    using ArrayUint32LIB for uint32[];\n    IRoles private roles;\n    // solhint-disable-next-line\n    address public GOVERNANCE_ADDRESS; //The address of the governance contract.\n\n    ///@notice dataset region rules\n    uint16 public datasetRuleMinRegionsPerDataset; // Minimum required number of regions (e.g., 3).\n\n    uint16 public datasetRuleDefaultMaxReplicasPerCountry; // Default maximum replicas allowed per country.\n\n    mapping(uint16 => uint16) private datasetRuleMaxReplicasInCountries; // Maximum replicas allowed per country.\n\n    uint16 public datasetRuleMaxReplicasPerCity; // Maximum replicas allowed per city (e.g., 1).\n\n    uint8 public datasetRuleMaxProportionOfMappingFilesToDataset; //Maximum proportion of dataset mapping files,measured in ten-thousandths.(e.g.,40)\n\n    ///@notice dataset sp rules\n    uint16 public datasetRuleMinSPsPerDataset; // Minimum required number of storage providers (e.g., 5).\n\n    uint16 public datasetRuleMaxReplicasPerSP; // Maximum replicas allowed per storage provider (e.g., 1).\n\n    uint16 public datasetRuleMinTotalReplicasPerDataset; // Minimum required total replicas (e.g., 5).\n\n    uint16 public datasetRuleMaxTotalReplicasPerDataset; // Maximum allowed total replicas (e.g., 10).\n\n    ///@notice datacap rules\n    uint64 public datacapRulesMaxAllocatedSizePerTime; // Maximum allocate datacap size per time.\n\n    uint8 public datacapRulesMaxRemainingPercentageForNext; // Minimum completion percentage for the next allocation.\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    // solhint-disable-next-line\n    function initialize(\n        address payable _governanceAddress,\n        address _roles\n    ) public initializer {\n        roles = IRoles(_roles);\n        GOVERNANCE_ADDRESS = _governanceAddress;\n\n        //defalut dataset region rules\n        datasetRuleMinRegionsPerDataset = 3;\n        datasetRuleDefaultMaxReplicasPerCountry = 1;\n        datasetRuleMaxReplicasPerCity = 1;\n        datasetRuleMaxProportionOfMappingFilesToDataset = 40; // 40/10000\n\n        //defalut dataset sp rules\n        datasetRuleMinSPsPerDataset = 5;\n        datasetRuleMaxReplicasPerSP = 1;\n        datasetRuleMinTotalReplicasPerDataset = 5;\n        datasetRuleMaxTotalReplicasPerDataset = 10;\n\n        //defalut datacap rules\n        datacapRulesMaxAllocatedSizePerTime = 50 * 1024 * 1024 * 1024 * 1024; //50TB\n        datacapRulesMaxRemainingPercentageForNext = 20; //20%\n\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    // Public getter function to access datasetRuleMaxReplicasInCountries\n    function getDatasetRuleMaxReplicasInCountry(\n        uint16 _countryCode\n    ) public view returns (uint16) {\n        if (datasetRuleMaxReplicasInCountries[_countryCode] == 0) {\n            return datasetRuleDefaultMaxReplicasPerCountry;\n        } else {\n            return datasetRuleMaxReplicasInCountries[_countryCode];\n        }\n    }\n\n    function setDatasetRuleMinRegionsPerDataset(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMinRegionsPerDataset = _newValue;\n        emit FilplusEvents.SetDatasetRuleMinRegionsPerDataset(_newValue);\n    }\n\n    function setDatasetRuleDefaultMaxReplicasPerCountry(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleDefaultMaxReplicasPerCountry = _newValue;\n        emit FilplusEvents.SetDatasetRuleDefaultMaxReplicasPerCountry(\n            _newValue\n        );\n    }\n\n    function setDatasetRuleMaxReplicasInCountry(\n        uint16 _countryCode,\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) onlyNotZero(_newValue) {\n        datasetRuleMaxReplicasInCountries[_countryCode] = _newValue;\n        emit FilplusEvents.SetDatasetRuleMaxReplicasInCountry(\n            _countryCode,\n            _newValue\n        );\n    }\n\n    function setDatasetRuleMaxReplicasPerCity(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMaxReplicasPerCity = _newValue;\n        emit FilplusEvents.SetDatasetRuleMaxReplicasPerCity(_newValue);\n    }\n\n    /// @notice set maximum proportion of dataset mapping files\n    function setDatasetRuleMaxProportionOfMappingFilesToDataset(\n        uint8 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMaxProportionOfMappingFilesToDataset = _newValue;\n        emit FilplusEvents.SetDatasetRuleMaxProportionOfMappingFilesToDataset(\n            _newValue\n        );\n    }\n\n    function setDatasetRuleMinSPsPerDataset(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMinSPsPerDataset = _newValue;\n        emit FilplusEvents.SetDatasetRuleMinSPsPerDataset(_newValue);\n    }\n\n    function setDatasetRuleMaxReplicasPerSP(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMaxReplicasPerSP = _newValue;\n        emit FilplusEvents.SetDatasetRuleMaxReplicasPerSP(_newValue);\n    }\n\n    function setDatasetRuleMinTotalReplicasPerDataset(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMinTotalReplicasPerDataset = _newValue;\n        emit FilplusEvents.SetDatasetRuleMinTotalReplicasPerDataset(_newValue);\n    }\n\n    function setDatasetRuleMaxTotalReplicasPerDataset(\n        uint16 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datasetRuleMaxTotalReplicasPerDataset = _newValue;\n        emit FilplusEvents.SetDatasetRuleMaxTotalReplicasPerDataset(_newValue);\n    }\n\n    function setDatacapRulesMaxAllocatedSizePerTime(\n        uint64 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datacapRulesMaxAllocatedSizePerTime = _newValue;\n        emit FilplusEvents.SetDatacapRulesMaxAllocatedSizePerTime(_newValue);\n    }\n\n    function setDatacapRulesMaxRemainingPercentageForNext(\n        uint8 _newValue\n    ) external onlyAddress(GOVERNANCE_ADDRESS) {\n        datacapRulesMaxRemainingPercentageForNext = _newValue;\n        emit FilplusEvents.SetDatacapRulesMaxRemainingPercentageForNext(\n            _newValue\n        );\n    }\n\n    /// @notice Check if the storage regions complies with filplus rules.\n    function isCompliantRuleMinRegionsPerDataset(\n        uint16[] memory _regions\n    ) internal view returns (bool) {\n        uint256 count = _regions.countUniqueElements();\n        if (count < datasetRuleMinRegionsPerDataset) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Check if the distribution of storage replica countries complies with filplus rules.\n    function isCompliantRuleMaxReplicasPerCountry(\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) internal view returns (bool) {\n        (uint256 uniqueCountryCount, uint16[] memory uniqueCountrys) = _countrys\n            .uniqueElements();\n\n        for (uint256 i = 0; i < uniqueCountryCount; i++) {\n            uint256 _value = _countrys.countOccurrences(uniqueCountrys[i]);\n            if (_value > 1) {\n                for (uint32 j = 0; j < _countrys.length; j++) {\n                    if (uniqueCountrys[i] == _countrys[j]) {\n                        require(_citys[j].length > 0, \"City is required\");\n                    }\n                }\n            }\n            if (\n                _value > getDatasetRuleMaxReplicasInCountry(uniqueCountrys[i])\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Check if the distribution of storage replica cities complies with filplus rules\n    function isCompliantRuleMaxReplicasPerCity(\n        uint32[][] memory _citys\n    ) internal view returns (bool) {\n        uint256 cityCount = 0;\n        for (uint256 i = 0; i < _citys.length; i++) {\n            require(!_citys[i].hasDuplicates(), \"Invalid duplicate city\");\n            cityCount += _citys[i].length;\n        }\n        uint32[] memory totalCitys = new uint32[](cityCount);\n        uint256 cnt = 0;\n\n        for (uint256 i = 0; i < _citys.length; i++) {\n            for (uint256 j = 0; j < _citys[i].length; j++) {\n                totalCitys[cnt] = _citys[i][j];\n                cnt++;\n            }\n        }\n\n        (uint256 count, uint32[] memory uniqueCitys) = totalCitys\n            .uniqueElements();\n\n        for (uint256 i = 0; i < count; i++) {\n            uint256 _value = totalCitys.countOccurrences(uniqueCitys[i]);\n            if (_value > datasetRuleMaxReplicasPerCity) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Check if the storage geolocation complies with filplus rules.\n    function isCompliantRuleGeolocation(\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) external view returns (bool) {\n        if (!isCompliantRuleMinRegionsPerDataset(_regions)) {\n            return false;\n        }\n\n        if (!isCompliantRuleMaxReplicasPerCountry(_countrys, _citys)) {\n            return false;\n        }\n\n        if (!isCompliantRuleMaxReplicasPerCity(_citys)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Check if the mappingFiles percentage in the dataset complies with filplus rules.\n    function isCompliantRuleMaxProportionOfMappingFilesToDataset(\n        uint64 _mappingFilesSize,\n        uint64 _sourceSize\n    ) external view returns (bool) {\n        uint64 proportion = (_mappingFilesSize * 10000) / _sourceSize;\n        if (proportion > datasetRuleMaxProportionOfMappingFilesToDataset) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Check if the total number of storage replicas complies with filplus rules.\n    function isCompliantRuleTotalReplicasPerDataset(\n        address[][] memory _dataPreparers,\n        address[][] memory _storageProviders,\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) external view returns (bool) {\n        if (\n            _regions.length != _dataPreparers.length ||\n            _regions.length != _storageProviders.length ||\n            _regions.length != _countrys.length ||\n            _regions.length != _citys.length\n        ) {\n            return false;\n        }\n\n        if (\n            _regions.length > datasetRuleMaxTotalReplicasPerDataset ||\n            _regions.length < datasetRuleMinTotalReplicasPerDataset ||\n            _regions.length < datasetRuleMinSPsPerDataset\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Check if the storage provider for each dataset complies with filplus rules `datasetRuleMinSPsPerDataset`.\n    function isCompliantRuleMinSPsPerDataset(\n        uint16 _requirementValue,\n        uint16 _totalExists,\n        uint16 _uniqueExists\n    ) external view returns (bool) {\n        if (_uniqueExists >= datasetRuleMinSPsPerDataset) {\n            return true;\n        }\n\n        if (\n            _uniqueExists >= _requirementValue ||\n            _totalExists >= _requirementValue\n        ) {\n            return false;\n        }\n\n        if (\n            (_requirementValue - _totalExists + _uniqueExists) >=\n            datasetRuleMinSPsPerDataset\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Check if the storage provider for each dataset complies with filplus rules `datasetRuleMaxReplicasPerSP`.\n    function isCompliantRuleMaxReplicasPerSP(\n        uint16 _value\n    ) external view returns (bool) {\n        if (_value > datasetRuleMaxReplicasPerSP) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "src/v0.8/core/finance/Escrow.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {SendAPI} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/SendAPI.sol\";\nimport {FilAddresses} from \"src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol\";\n\n// upgrade\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n// type\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\n\n// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IEscrow} from \"src/v0.8/interfaces/core/IEscrow.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\n\n// shared\nimport {EscrowEvents} from \"src/v0.8/shared/events/EscrowEvents.sol\";\nimport {EscrowLIB} from \"src/v0.8/core/finance/library/EscrowLIB.sol\";\n\n/// @title Escrow\n/// @dev Base escrow contract, holds funds designated for a payee until they withdraw them.\ncontract Escrow is Initializable, UUPSUpgradeable, RolesModifiers, IEscrow {\n    using EscrowLIB for EscrowType.Escrow;\n\n    mapping(EscrowType.Type => mapping(address => mapping(uint256 => EscrowType.Escrow)))\n        private escrowAccount; // mapping(type, mapping(payee, mapping(id, Escrow)))\n\n    IRoles private roles;\n    IDatasets private datasets;\n    IDatasetsProof private datasetsProof;\n    IDatasetsRequirement private datasetsRequirement;\n    uint256 public constant PER_DAY_BLOCKNUMBER = 2880;\n    address payable public constant BURN_ADDRESS =\n        payable(0xff00000000000000000000000000000000000063); // Filecoin burn address\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice Initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(address _roles) public initializer {\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Set dependencies function to initialize the depend contract.\n    /// @dev After the contract is deployed, this function needs to be called manually!\n    function setDependencies(\n        address _datasets,\n        address _datasetsProof,\n        address _datasetsRequirement\n    ) public onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        datasets = IDatasets(_datasets);\n        datasetsProof = IDatasetsProof(_datasetsProof);\n        datasetsRequirement = IDatasetsRequirement(_datasetsRequirement);\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by default admin role\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Records the sent amount as credit for future withdrawals.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {Collateral} event upon successful credit recording.\n    function collateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        uint256 _amount\n    ) public payable {\n        uint256 total = msg.value;\n        escrowAccount[_type][_owner][_id].deposit(total);\n        escrowAccount[_type][_owner][_id].collateral(_amount);\n\n        emit EscrowEvents.Collateral(_type, _owner, _id, _amount);\n    }\n\n    /// @notice Withdraw funds authorized for an address.\n    /// @dev This function allows the owner to initiate a withdrawal of authorized funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @notice Emits a {Withdrawn} event upon successful withdrawal.\n    function withdraw(\n        EscrowType.Type _type,\n        address payable _owner,\n        uint64 _id\n    ) public {\n        uint256 amount = escrowAccount[_type][_owner][_id].withdraw();\n        SendAPI.send(FilAddresses.fromEthAddress(_owner), amount);\n\n        emit EscrowEvents.Withdrawn(_type, _owner, _id, amount);\n    }\n\n    /// @dev Records the sent amount as credit for future payment withdraw.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {PaymentCollateral} event upon successful credit recording.\n    function paymentCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        uint256 _amount\n    ) public payable {\n        uint256 total = msg.value;\n        escrowAccount[_type][_owner][_id].deposit(total);\n        escrowAccount[_type][_owner][_id].paymentCollateral(_amount);\n\n        emit EscrowEvents.PaymentCollateral(_type, _owner, _id, _amount);\n    }\n\n    /// @dev Records the sent amount as credit for future payment withdraw.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {PaymentSingleBeneficiaryCollateral} event upon successful credit recording.\n    function paymentSingleBeneficiaryCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _amount\n    ) public payable {\n        uint256 total = msg.value;\n        require(total >= _amount, \"Exceeds the amount of payment\");\n        escrowAccount[_type][_owner][_id].deposit(total);\n        escrowAccount[_type][_owner][_id].paymentCollateral(_amount);\n        escrowAccount[_type][_owner][_id].paymentAddbeneficiary(\n            _beneficiary,\n            _amount\n        );\n\n        emit EscrowEvents.PaymentSingleBeneficiaryCollateral(\n            _type,\n            _owner,\n            _id,\n            _beneficiary,\n            _amount\n        );\n    }\n\n    /// @notice Payment withdraw funds authorized for an address.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @notice Emits a {PaymentWithdrawn} event upon successful credit recording.\n    function paymentWithdraw(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary\n    ) public {\n        uint256 amount = escrowAccount[_type][_owner][_id].paymentWithdraw(\n            _beneficiary\n        );\n        SendAPI.send(FilAddresses.fromEthAddress(_beneficiary), amount);\n\n        emit EscrowEvents.PaymentWithdrawn(\n            _type,\n            _owner,\n            _id,\n            _beneficiary,\n            amount\n        );\n    }\n\n    /// @notice Post an event for collateral type.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function emitCollateralEvent(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        EscrowType.CollateralEvent _event\n    ) external {\n        if (_event == EscrowType.CollateralEvent.SyncBurn) {\n            uint256 amount = _syncBurn(_type, _owner, _id);\n            _updateBurn(_type, payable(_owner), _id, amount);\n        } else if (_event == EscrowType.CollateralEvent.SyncCollateral) {\n            uint256 amount = _syncCollateral(_type, _owner, _id);\n            _updateCollateral(_type, _owner, _id, amount);\n        }\n    }\n\n    /// @notice Post an event for payment type.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    function emitPaymentEvent(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        EscrowType.PaymentEvent _event\n    ) external {\n        if (_event == EscrowType.PaymentEvent.SyncPaymentRefund) {\n            uint256 amount = _syncPaymentRefund(\n                _type,\n                _owner,\n                _id,\n                _beneficiary\n            );\n            _updatePaymentRefund(_type, _owner, _id, _beneficiary, amount);\n        } else if (_event == EscrowType.PaymentEvent.SyncPaymentCollateral) {\n            uint256 amount = _syncPaymentCollateral(\n                _type,\n                _owner,\n                _id,\n                _beneficiary\n            );\n            _updatePaymentCollateral(_type, _owner, _id, _beneficiary, amount);\n        } else if (_event == EscrowType.PaymentEvent.SyncPaymentBeneficiaries) {\n            uint256 amount = _syncPaymentBeneficiary(\n                _type,\n                _owner,\n                _id,\n                _beneficiary\n            );\n            _updatePaymentBeneficiary(_type, _owner, _id, _beneficiary, amount);\n        }\n    }\n\n    /// @notice Update collateral funds authorized for an address.\n    /// @dev This function allows update collateral funds authorized for an address.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {UpdateCollateral} event upon successful withdrawal.\n    function _updateCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        uint256 _amount\n    ) internal {\n        escrowAccount[_type][_owner][_id].updateCollateral(_amount);\n\n        emit EscrowEvents.UpdateCollateral(_type, _owner, _id, _amount);\n    }\n\n    /// @notice Burn funds authorized for an address.\n    /// @dev This function allows burn funds.Triggered by business conditions\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The burn funds.\n    /// @notice Emits a {Burn} event upon successful withdrawal.\n    function _updateBurn(\n        EscrowType.Type _type,\n        address payable _owner,\n        uint64 _id,\n        uint256 _amount\n    ) internal {\n        escrowAccount[_type][_owner][_id].burn(_amount);\n        SendAPI.send(FilAddresses.fromEthAddress(BURN_ADDRESS), _amount);\n\n        emit EscrowEvents.Burn(_type, _owner, _id, _amount);\n    }\n\n    /// @notice Burn funds authorized for an address.\n    /// @dev This function allows burn funds.Triggered by business conditions\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The burn funds.\n    /// @notice Emits a {Burn} event upon successful withdrawal.\n    function _updatePaymentCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        escrowAccount[_type][_owner][_id].updatePaymentCollateral(\n            _beneficiary,\n            _amount\n        );\n\n        emit EscrowEvents.UpdatePaymentCollateral(\n            _type,\n            _owner,\n            _id,\n            _beneficiary,\n            _amount\n        );\n    }\n\n    /// @notice Refund funds authorized for an address.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The refund funds.\n    /// @notice Emits a {PaymentRefund} event upon successful credit recording.\n    function _updatePaymentRefund(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        escrowAccount[_type][_owner][_id].paymentRefund(_beneficiary, _amount);\n\n        emit EscrowEvents.PaymentRefund(\n            _type,\n            _owner,\n            _id,\n            _beneficiary,\n            _amount\n        );\n    }\n\n    /// @notice Update payment beneficiaries authorized for an address.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The payment amount of beneficiaries.\n    /// @notice Emits a {UpdatePaymentBeneficiaries} event upon successful credit recording.\n    function _updatePaymentBeneficiary(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        escrowAccount[_type][_owner][_id].paymentAddbeneficiary(\n            _beneficiary,\n            _amount\n        );\n\n        emit EscrowEvents.UpdatePaymentBeneficiary(\n            _type,\n            _owner,\n            _id,\n            _beneficiary,\n            _amount\n        );\n    }\n\n    /// @dev Determines the amount available for collateral based on escrow type, owner, and ID.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function _syncCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) internal view returns (uint256) {\n        if (_type == EscrowType.Type.DatacapCollateral) {\n            return _datacapCollateral(_owner, _id);\n        } else if (_type == EscrowType.Type.DatacapChunkCollateral) {\n            // TODO: Implement logic to retrieve allowed withdrawal funds from the datacap contract.\n            return 0;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev Handles the logic for burning funds based on escrow type, owner, and ID.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function _syncBurn(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) internal view returns (uint256) {\n        // TODO:\n        return getOwnerCollateral(_type, _owner, _id); // Burn all collateral\n    }\n\n    /// @dev Handles the logic for collateral payments based on escrow type, owner, ID, and beneficiary.\n    function _syncPaymentCollateral(\n        EscrowType.Type /*_type*/,\n        address /*_owner*/,\n        uint64 /*_id*/,\n        address /*_beneficiary*/\n    ) internal pure returns (uint256) {\n        // TODO:\n        return 0; // Release all collateral\n    }\n\n    /// @dev Handles the logic for refunding payments based on escrow type, owner, ID, and beneficiary.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function _syncPaymentRefund(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address /*_beneficiary*/\n    ) internal view returns (uint256) {\n        // TODO:\n        return getOwnerCollateral(_type, _owner, _id); // Refund all payment for test\n    }\n\n    /// @dev Handles the logic for synchronize payment beneficiary based on escrow type, owner, ID.\n    function _syncPaymentBeneficiary(\n        EscrowType.Type /*_type*/,\n        address /*_owner*/,\n        uint64 /*_id*/,\n        address /*_beneficiary*/\n    ) internal pure returns (uint256) {\n        // TODO:\n        return 0;\n    }\n\n    /// @dev Determines the amount available for collateral from a DatacapCollateral\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function _datacapCollateral(\n        address _owner,\n        uint64 _id\n    ) internal view returns (uint256) {\n        uint256 collateralFunds = 0;\n\n        // Check the dataset's status:\n        // - If it's in the 'MetadataRejected' status,\n        // - or if it's not in the 'MetadataApproved' status and has been staked for over 180 days,\n        // - or if it has been mortgaged for over 365 days, the funds are eligible for withdrawal.\n        DatasetType.State datasetState = datasets.getDatasetState(_id);\n        uint64 createBlockNumber = getOwnerCreatedBlockNumber(\n            EscrowType.Type.DatacapCollateral,\n            _owner,\n            _id\n        );\n\n        if (\n            (datasetState == DatasetType.State.MetadataRejected) ||\n            (datasetState != DatasetType.State.DatasetApproved &&\n                block.number >\n                (createBlockNumber + PER_DAY_BLOCKNUMBER * 180)) ||\n            block.number > (createBlockNumber + PER_DAY_BLOCKNUMBER * 365)\n        ) {\n            return collateralFunds; // Release all collateral funds\n        }\n\n        // Check the datasetProof's status:\n        // - If it's in the 'allCompleted' status,\n        // - it's all proof completed collateral funds\n        if (\n            datasetsProof.isDatasetProofallCompleted(\n                _id,\n                DatasetType.DataType.Source\n            )\n        ) {\n            collateralFunds = datasetsProof.getDatasetCollateralRequirement(\n                _id\n            );\n        } else {\n            // Others are pre collateral funds\n            collateralFunds = datasetsRequirement\n                .getDatasetPreCollateralRequirements(_id);\n        }\n\n        uint256 total = getOwnerTotal(\n            EscrowType.Type.DatacapCollateral,\n            _owner,\n            _id\n        );\n        require(total >= collateralFunds, \"Insufficient collateral funds\");\n        return collateralFunds;\n    }\n\n    /// @notice Get owner created block number.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerCreatedBlockNumber(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (uint64) {\n        return escrowAccount[_type][_owner][_id].owner.createdBlockNumber;\n    }\n\n    /// @notice Get owner collateral funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (uint256) {\n        return escrowAccount[_type][_owner][_id].owner.collateral;\n    }\n\n    /// @notice Get owner total funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerTotal(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (uint256) {\n        return escrowAccount[_type][_owner][_id].owner.total;\n    }\n\n    /// @notice Get owner lock funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerLock(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (uint256) {\n        return escrowAccount[_type][_owner][_id].owner.lock;\n    }\n\n    /// @notice Get owner burned funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerBurned(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (uint256) {\n        return escrowAccount[_type][_owner][_id].owner.burned;\n    }\n\n    /// @notice Get beneficiariesList.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getBeneficiariesList(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) public view returns (address[] memory) {\n        return escrowAccount[_type][_owner][_id].beneficiariesList;\n    }\n\n    /// @notice Get beneficiary fund.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    function getBeneficiaryFund(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary\n    ) public view returns (uint256, uint256, uint256, uint256, uint64) {\n        return (\n            escrowAccount[_type][_owner][_id].beneficiaries[_beneficiary].total,\n            escrowAccount[_type][_owner][_id].beneficiaries[_beneficiary].lock,\n            escrowAccount[_type][_owner][_id]\n                .beneficiaries[_beneficiary]\n                .collateral,\n            escrowAccount[_type][_owner][_id]\n                .beneficiaries[_beneficiary]\n                .burned,\n            escrowAccount[_type][_owner][_id]\n                .beneficiaries[_beneficiary]\n                .createdBlockNumber\n        );\n    }\n}\n"
    },
    "src/v0.8/core/finance/library/EscrowLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\n\n/// @title EscrowLIB\n/// @dev This library provides functions for managing the escrow.\n/// @notice Library for managing operations related to escrow.\nlibrary EscrowLIB {\n    function deposit(EscrowType.Escrow storage self, uint256 _total) internal {\n        self.owner.total += _total;\n    }\n\n    /// @dev Increases the total and collateral balances for the escrow owner and updates the creation block number.\n    /// @param self The Escrow object.\n    /// @param _amount The collateral funds.\n    function collateral(\n        EscrowType.Escrow storage self,\n        uint256 _amount\n    ) internal {\n        require(\n            self.owner.total >=\n                _amount + self.owner.collateral + self.owner.lock,\n            \"collateral > total\"\n        );\n        self.owner.collateral += _amount;\n        self.owner.createdBlockNumber = uint64(block.number);\n    }\n\n    /// @dev Calculates and returns the amount available for withdrawal and reduces the total balance accordingly.\n    /// @param self The Escrow object.\n    function withdraw(\n        EscrowType.Escrow storage self\n    ) internal returns (uint256) {\n        uint256 amount = self.owner.total -\n            self.owner.collateral -\n            self.owner.lock;\n\n        self.owner.total -= amount;\n        return amount;\n    }\n\n    /// @dev Updates the collateral balance for the escrow owner.\n    /// @param self The Escrow object.\n    /// @param _amount The collateral funds.\n    function updateCollateral(\n        EscrowType.Escrow storage self,\n        uint256 _amount\n    ) internal {\n        self.owner.collateral = _amount;\n    }\n\n    /// @dev Decreases the total and collateral balances for the escrow owner and increases the burned balance.\n    /// @param self The Escrow object.\n    /// @param _amount The collateral funds.\n    function burn(EscrowType.Escrow storage self, uint256 _amount) internal {\n        self.owner.total -= _amount;\n        self.owner.collateral -= _amount;\n        self.owner.burned += _amount;\n    }\n\n    /// @dev Deposits funds into the escrow, locking them for a payment, and updates creation information.\n    /// @param self The Escrow object.\n    /// @param _amount The collateral funds.\n    function paymentCollateral(\n        EscrowType.Escrow storage self,\n        uint256 _amount\n    ) internal {\n        require(\n            self.owner.total >=\n                _amount + self.owner.lock + self.owner.collateral,\n            \"payment > total\"\n        );\n        self.owner.lock += _amount;\n        self.owner.createdBlockNumber = uint64(block.number);\n    }\n\n    /// @dev Add beneficiary to payment escrow, and updates creation information.\n    /// @param self The Escrow object.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The payment funds.\n    function paymentAddbeneficiary(\n        EscrowType.Escrow storage self,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        if (self.beneficiaries[_beneficiary].createdBlockNumber == 0) {\n            self.beneficiariesList.push(_beneficiary);\n        }\n        require(self.owner.lock >= _amount, \"Exceeds the amount of payment\");\n\n        self.beneficiaries[_beneficiary].total += _amount;\n        self.beneficiaries[_beneficiary].collateral += _amount;\n        self.beneficiaries[_beneficiary].createdBlockNumber = uint64(\n            block.number\n        );\n    }\n\n    /// @dev Calculates the amount available for withdrawal by a beneficiary and adjusts balances accordingly.\n    /// @param self The Escrow object.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @return The amount available for withdrawal by the beneficiary.\n    function paymentWithdraw(\n        EscrowType.Escrow storage self,\n        address _beneficiary\n    ) internal returns (uint256) {\n        uint256 amount = self.beneficiaries[_beneficiary].total -\n            self.beneficiaries[_beneficiary].collateral -\n            self.beneficiaries[_beneficiary].lock;\n\n        self.beneficiaries[_beneficiary].total -= amount;\n        self.owner.total -= amount;\n        self.owner.lock -= amount;\n\n        return amount;\n    }\n\n    /// @dev Updates the collateral balance for a specific beneficiary in the escrow.\n    /// @param self The Escrow object.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The collateral funds.\n    function updatePaymentCollateral(\n        EscrowType.Escrow storage self,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        self.beneficiaries[_beneficiary].collateral = _amount;\n    }\n\n    /// @dev Refunds funds to a beneficiary, reducing their total and collateral balances and unlocking the owner's funds.\n    /// @param self The Escrow object.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The collateral funds.\n    function paymentRefund(\n        EscrowType.Escrow storage self,\n        address _beneficiary,\n        uint256 _amount\n    ) internal {\n        self.beneficiaries[_beneficiary].total -= _amount;\n        self.beneficiaries[_beneficiary].collateral -= _amount;\n\n        self.owner.lock -= _amount;\n    }\n}\n"
    },
    "src/v0.8/core/governance/abstract/DataswapDAOBase.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GovernorUpgradeable, IGovernorUpgradeable, IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport {GovernorCompatibilityBravoUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";\nimport {GovernorVotesUpgradeable, IVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport {GovernorVotesQuorumFractionUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\n\n// import \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControl.sol\";\n\n/// @title DataswapDAOBase Contract\n/// @notice This contract serves as the base for the DataSwap DAO governance mechanism.\n/// @dev This contract inherits from various GovernorUpgradeable-related contracts and Ownable2Step.\nabstract contract DataswapDAOBase is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorCompatibilityBravoUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable\n    // GovernorTimelockControl\n{\n    /// @notice initialize function to initialize the DataswapDAOBase contract.\n    /// @param _token The token used for voting.\n    //  @param _timelock The timelock contract.\n    // solhint-disable-next-line\n    function initialize(\n        IVotesUpgradeable _token\n    ) public virtual onlyInitializing {\n        // TimelockController _timelock\n        GovernorUpgradeable.__Governor_init(\"DataswapDAO\");\n        GovernorVotesUpgradeable.__GovernorVotes_init(_token);\n        GovernorVotesQuorumFractionUpgradeable\n            .__GovernorVotesQuorumFraction_init(4);\n        // GovernorTimelockControl(_timelock)\n    }\n\n    /// @notice Returns the delay between the proposal's creation and the ability to vote on it.\n    /// @dev This function is an override required by the IGovernorUpgradeable interface.\n    /// @return The delay in seconds.\n    function votingDelay()\n        public\n        pure\n        virtual\n        override(IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return 2880; // 1 day\n    }\n\n    /// @notice Returns the duration of voting on a proposal.\n    /// @dev This function is an override required by the IGovernorUpgradeable interface.\n    /// @return The voting period in seconds.\n    function votingPeriod()\n        public\n        pure\n        virtual\n        override(IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return 2880 * 7; // 1 week\n    }\n\n    /// @notice Returns the minimum amount of votes required for a proposal to succeed.\n    /// @dev This function is an override required by the IGovernorUpgradeable interface.\n    /// @return The proposal threshold.\n    function proposalThreshold()\n        public\n        pure\n        virtual\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    // The functions below are overrides required by Solidity.\n    function state(\n        uint256 proposalId\n    )\n        public\n        view\n        override(GovernorUpgradeable, IGovernorUpgradeable)\n        returns (\n            // override(GovernorUpgradeable, IGovernorUpgradeable, GovernorTimelockControl)\n            ProposalState\n        )\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    )\n        public\n        override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        public\n        override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)\n        returns (uint256)\n    {\n        return super.cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(\n            // ) internal override(GovernorUpgradeable, GovernorTimelockControl) {\n            GovernorUpgradeable\n        )\n    {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(\n            // ) internal override(GovernorUpgradeable, GovernorTimelockControl) returns (uint256) {\n            GovernorUpgradeable\n        )\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(\n            // override(GovernorUpgradeable, GovernorTimelockControl)\n            GovernorUpgradeable\n        )\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(GovernorUpgradeable, IERC165Upgradeable)\n        returns (\n            //override(GovernorUpgradeable, IERC165Upgradeable, GovernorTimelockControl)\n            bool\n        )\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/v0.8/core/governance/abstract/DataswapDAOPerPersonVoting.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n// import {Governor, IGovernor, IERC165} from \"@openzeppelin/contracts-upgradeable/governance/Governor.sol\";\n// import {GovernorCompatibilityBravo} from \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravo.sol\";\nimport {IVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\n// import {GovernorVotesQuorumFraction} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFraction.sol\";\n// import {GovernorTimelockControl} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControl.sol\";\nimport {DataswapDAOBase} from \"src/v0.8/core/governance/abstract/DataswapDAOBase.sol\";\n\n/// @title DataswapDAOPerPersonVoting Contract\n/// @notice This contract serves as the base for the DataSwap DAO governance mechanism with per-person voting.\n/// @dev This contract inherits from DataswapDAOBase and provides the foundation for individual voting.\nabstract contract DataswapDAOPerPersonVoting is Initializable, DataswapDAOBase {\n\n    /// @notice initialize function to initialize the DataswapDAOPerPersonVoting contract.\n    /// @param _token The token used for voting.\n    // solhint-disable-next-line\n    function initialize(\n        IVotesUpgradeable _token\n    ) public virtual override onlyInitializing {\n        DataswapDAOBase.initialize(_token);\n    }\n}\n"
    },
    "src/v0.8/core/governance/dataset/DatasetDAO.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n// import {DataswapDAOPerPersonVoting} from \"../abstract/DataswapDAOPerPersonVoting.sol\";\n// import {IDatasetDAO} from \"../interface/IDatasetDAO.sol\";\n\n/// @title DataswapDAOPerPersonVoting Contract\n/// @notice This contract serves as the base for the DataSwap DAO governance mechanism with per-person voting.\n/// @dev This contract inherits from DataswapDAOBase and provides the foundation for individual voting.\n// abstract contract DatasetDAO is DataswapDAOPerPersonVoting, IDatasetDAO {\n//     /// @notice Constructor function to initialize the DataswapDAOPerPersonVoting contract.\n//     /// @param _token The token used for voting.\n//     constructor(IVotes _token) DataswapDAOPerPersonVoting(_token) {}\n// }\n"
    },
    "src/v0.8/core/governance/interface/IDatasetDAO.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @title IDatasetDAO\n// solhint-disable-next-line\ninterface IDatasetDAO {\n\n}\n"
    },
    "src/v0.8/core/token/Dswap.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\n\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {ERC20VotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/// @title DataswapBase Contract\n/// @notice This contract serves as the base for the DataSwap token (DSWAP).\n/// @dev This contract inherits from ERC20Upgradeable, ERC20PermitUpgradeable, ERC20VotesUpgradeable, and Ownable2StepUpgradeable contracts.\ncontract Dswap is\n    Initializable,\n    UUPSUpgradeable,\n    ERC20Upgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable,\n    Ownable2StepUpgradeable,\n    RolesModifiers\n{\n    IRoles private roles;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(address _roles) public virtual onlyInitializing {\n        ERC20Upgradeable.__ERC20_init(\"DataSwap\", \"DSWAP\");\n        ERC20PermitUpgradeable.__ERC20Permit_init(\"DSWAP\");\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Overrides the _afterTokenTransfer function from ERC20VotesUpgradeable and ERC20Upgradeable.\n    /// @param _from The address transferring tokens.\n    /// @param _to The address receiving tokens.\n    /// @param _amount The amount of tokens being transferred.\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @dev Overrides the _mint function from ERC20VotesUpgradeable and ERC20Upgradeable.\n    /// @param _to The address receiving the minted tokens.\n    /// @param _amount The amount of tokens being minted.\n    function _mint(\n        address _to,\n        uint256 _amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._mint(_to, _amount);\n    }\n\n    /// @dev Overrides the _burn function from ERC20VotesUpgradeable and ERC20Upgradeable.\n    /// @param _account The address from which tokens are burned.\n    /// @param _amount The amount of tokens being burned.\n    function _burn(\n        address _account,\n        uint256 _amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._burn(_account, _amount);\n    }\n}\n"
    },
    "src/v0.8/interfaces/core/ICarstore.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\n\n/// @title ICarstoreReadOnly\n/// @notice This interface defines the functions for get car status.\ninterface ICarstoreReadOnly {\n    /// @notice Get the dataset ID associated with a car.\n    /// @param _id Car ID to check.\n    /// @return The car size of the car.\n    function getCarSize(uint64 _id) external view returns (uint64);\n\n    /// @notice Get the total size of cars based on an array of car IDs.\n    /// @param _ids An array of car IDs for which to calculate the size.\n    /// @return The total size of cars.\n    function getCarsSize(uint64[] memory _ids) external view returns (uint64);\n\n    /// @notice Get the dataset ID associated with a car.\n    /// @param _id Car ID to check.\n    /// @return The dataset ID of the car.\n    /// NOTE: a car only belongs a datasets\n    function getCarDatasetId(uint64 _id) external view returns (uint64);\n\n    /// @notice Get the matching ids of a replica associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @return The matching ids of the car's replica.\n    function getCarMatchingIds(\n        uint64 _id\n    ) external view returns (uint64[] memory);\n\n    /// @notice Get the replica details associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The dataset ID, state, and Filecoin claim ID of the replica.\n    function getCarReplica(\n        uint64 _id,\n        uint64 _matchingId\n    ) external view returns (CarReplicaType.State, uint64);\n\n    /// @notice Get the count of replicas associated with a car.\n    /// @param _id Car ID for which to retrieve the replica count.\n    /// @return The count of replicas associated with the car.\n    function getCarReplicasCount(uint64 _id) external view returns (uint16);\n\n    /// @notice Get the Filecoin claim ID associated with a specific replica of a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The Filecoin claim ID of the replica.\n    function getCarReplicaFilecoinClaimId(\n        uint64 _id,\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice Get the state of a replica associated with a car.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @return The state of the replica.\n    function getCarReplicaState(\n        uint64 _id,\n        uint64 _matchingId\n    ) external view returns (CarReplicaType.State);\n\n    /// @notice Get the hash of car based on the car id.\n    /// @param _id Car ID which to get car hash.\n    /// @return The hash of the car.\n    function getCarHash(uint64 _id) external view returns (bytes32);\n\n    /// @notice Get the hashs of cars based on an array of car IDs.\n    /// @param _ids An array of car IDs for which to get car hashs.\n    /// @return The hashs of cars.\n    function getCarsHashs(\n        uint64[] memory _ids\n    ) external view returns (bytes32[] memory);\n\n    /// @notice Get the car's id based on the car's hash.\n    /// @param _hash The hash which to get car id.\n    /// @return The id of the car.\n    function getCarId(bytes32 _hash) external view returns (uint64);\n\n    /// @notice Get the ids of cars based on an array of car hashs.\n    /// @param _hashs An array of car hashs for which to cat car hashs.\n    /// @return The ids of cars.\n    function getCarsIds(\n        bytes32[] memory _hashs\n    ) external view returns (uint64[] memory);\n\n    /// @notice Check if a car exists based on its Hash.\n    /// @param _hash Car Hash to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCarHash(bytes32 _hash) external view returns (bool);\n\n    /// @notice Check if a car exists based on its ID.\n    /// @param _id Car ID to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCar(uint64 _id) external view returns (bool);\n\n    /// @notice Check if a replica exists within a car based on its matching ID.\n    /// @param _id Car ID to check.\n    /// @param _matchingId Matching ID of the replica to check.\n    /// @return True if the replica exists, false otherwise.\n    function hasCarReplica(\n        uint64 _id,\n        uint64 _matchingId\n    ) external view returns (bool);\n\n    /// @notice Check if a car exists based on its Hashs.\n    /// @dev This function returns whether a car exists or not.\n    /// @param _hashs  Array of car Hashs to check.\n    /// @return True if the car exists, false otherwise.\n    function hasCarsHashs(bytes32[] memory _hashs) external view returns (bool);\n\n    /// @notice Check if multiple cars exist based on their IDs.\n    /// @param _ids Array of car IDs to check.\n    /// @return True if all specified cars exist, false if any one does not exist.\n    function hasCars(uint64[] memory _ids) external view returns (bool);\n\n    // Default getter functions for public variables\n    function carsCount() external view returns (uint64);\n\n    /// @notice get filecoin object\n    function filecoin() external view returns (IFilecoin);\n\n    /// @notice get filplus object\n    function filplus() external view returns (IFilplus);\n}\n\n/// @title ICarStore\n/// @notice This interface defines the functions for managing car data and associated replicas.\ninterface ICarstore is ICarstoreReadOnly {\n    /// @dev Internal function to add a car based on its CID.\n    ///      tips: diffent dataset has the same car is dones't matter,maybe need limit replicas count for a car.\n    ///      filplus requires dataset replicas,but not limit for car replicas\n    /// @param _cid Car CID to be added.\n    /// @param _datasetId dataset index of approved dataset.\n    /// @param _size car size.\n    /// @param _replicaCount count of car's replicas.\n    /// @return The id of the car.\n    function addCar(\n        bytes32 _cid,\n        uint64 _datasetId,\n        uint64 _size,\n        uint16 _replicaCount\n    ) external returns (uint64);\n\n    /// @notice Add multiple cars to the storage.\n    /// @dev This function allows the addition of multiple cars at once.\n    /// @param _cids Array of car CIDs to be added.\n    /// @param _datasetId dataset index of approved dataset.\n    /// @param _sizes car size array.\n    /// @param _replicaCount count of car's replicas.\n    /// @return The ids of the cars and the size.\n    function addCars(\n        bytes32[] memory _cids,\n        uint64 _datasetId,\n        uint64[] memory _sizes,\n        uint16 _replicaCount\n    ) external returns (uint64[] memory, uint64);\n\n    /// @notice Regist a replica to a car.\n    /// @dev This function allows adding a replica to an existing car.\n    /// @param _id Car ID to which the replica will be added.\n    /// @param _matchingId Matching ID for the new replica.\n    /// @param _replicaIndex The index of the replica.\n    function registCarReplica(\n        uint64 _id,\n        uint64 _matchingId,\n        uint16 _replicaIndex\n    ) external;\n\n    /// @notice Report that matching's state for a replica.\n    /// @dev This function allows reporting that the matching for a replica is failed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _matchingState Matching's state of the replica, true for success ,false for failed.\n    function reportCarReplicaMatchingState(\n        uint64 _id,\n        uint64 _matchingId,\n        bool _matchingState\n    ) external;\n\n    /// @notice Report that storage deal for a replica has expired.\n    /// @dev This function allows reporting that the storage deal for a replica has expired.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    function reportCarReplicaExpired(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    ) external;\n\n    /// @notice Report that storage of a replica has been slashed.\n    /// @dev This function allows reporting that the storage of a replica has been slashed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    function reportCarReplicaSlashed(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    ) external;\n\n    /// @notice Set the Filecoin claim ID for a replica's storage.\n    /// @dev This function allows setting the Filecoin claim ID for a specific replica's storage.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _claimId New Filecoin claim ID to set for the replica's storage.\n    function setCarReplicaFilecoinClaimId(\n        uint64 _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    ) external;\n}\n"
    },
    "src/v0.8/interfaces/core/IEscrow.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\n\n/// @title IEscrow Interface\n/// @notice This interface defines the escrow-related functions within the system.\ninterface IEscrow {\n    /// @dev Records the sent amount as credit for future withdrawals.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {Collateral} event upon successful credit recording.\n    function collateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        uint256 _amount\n    ) external payable;\n\n    /// @notice Withdraw funds authorized for an address.\n    /// @dev This function allows the owner to initiate a withdrawal of authorized funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @notice Emits a {Withdrawn} event upon successful withdrawal.\n    function withdraw(\n        EscrowType.Type _type,\n        address payable _owner,\n        uint64 _id\n    ) external;\n\n    /// @dev Records the sent amount as credit for future payment withdraw.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {PaymentCollateral} event upon successful credit recording.\n    function paymentCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        uint256 _amount\n    ) external payable;\n\n    /// @dev Records the sent amount as credit for future payment withdraw.\n    /// Note Called by the payer to store the sent amount as credit to be pulled.\n    /// Funds sent in this way are stored in an intermediate {Escrow} contract, so\n    /// there is no danger of them being spent before withdrawal.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _amount The collateral funds.\n    /// @notice Emits a {PaymentSingleBeneficiaryCollateral} event upon successful credit recording.\n    function paymentSingleBeneficiaryCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _amount\n    ) external payable;\n\n    /// @notice Payment withdraw funds authorized for an address.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @notice Emits a {PaymentWithdrawn} event upon successful credit recording.\n    function paymentWithdraw(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary\n    ) external;\n\n    /// @notice Post an event for collateral type.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function emitCollateralEvent(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        EscrowType.CollateralEvent _event\n    ) external;\n\n    /// @notice Post an event for payment type.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    function emitPaymentEvent(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary,\n        EscrowType.PaymentEvent _event\n    ) external;\n\n    /// @notice Get owner created block number.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerCreatedBlockNumber(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (uint64);\n\n    /// @notice Get owner collateral funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerCollateral(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (uint256);\n\n    /// @notice Get owner total funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerTotal(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (uint256);\n\n    /// @notice Get owner lock funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerLock(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (uint256);\n\n    /// @notice Get owner burned funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getOwnerBurned(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (uint256);\n\n    /// @notice Get beneficiariesList.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    function getBeneficiariesList(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id\n    ) external view returns (address[] memory);\n\n    /// @notice Get beneficiary fund.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    function getBeneficiaryFund(\n        EscrowType.Type _type,\n        address _owner,\n        uint64 _id,\n        address _beneficiary\n    )\n        external\n        view\n        returns (\n            uint256 total, // Total amount in fund account\n            uint256 lock, // Lock amount in fund account for payment beneficiaries\n            uint256 collateral, // Collateral amount in fund account for withdraw and punishment\n            uint256 burned, // burned amount in fund account\n            uint64 createdBlockNumber // Fund account created block number\n        );\n}\n"
    },
    "src/v0.8/interfaces/core/IFilecoin.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\n\n/// @title IFilplus\ninterface IFilecoin {\n    /// @notice The function to init the dependencies of a filecoin.\n    function initDependencies(address _datacap) external;\n\n    /// @notice The function to allocate the datacap of a storage deal.\n    function allocateDatacap(uint64 client, uint256 _size) external;\n\n    /// @notice The function to get the state of a Filecoin storage deal for a replica.\n    function getReplicaDealState(\n        bytes32 _cid,\n        uint64 _claimId\n    ) external returns (FilecoinType.DealState);\n\n    /// @dev do nothing,just for mock\n    function setMockDealState(FilecoinType.DealState _state) external;\n\n    /// @notice The function to get the data of a claim for a replica.\n    function getReplicaClaimData(\n        uint64 _provider,\n        uint64 _claimId\n    ) external returns (bytes memory);\n\n    /// @dev mock the filecoin claim data\n    function setMockClaimData(uint64 claimId, bytes memory _data) external;\n}\n"
    },
    "src/v0.8/interfaces/core/IFilplus.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title IFilplus\ninterface IFilplus {\n    // Public getter function to access datasetRuleMaxReplicasInCountries\n    function getDatasetRuleMaxReplicasInCountry(\n        uint16 _countryCode\n    ) external view returns (uint16);\n\n    // Set functions for public variables\n    function setDatasetRuleMinRegionsPerDataset(uint16 _newValue) external;\n\n    function setDatasetRuleDefaultMaxReplicasPerCountry(\n        uint16 _newValue\n    ) external;\n\n    function setDatasetRuleMaxReplicasInCountry(\n        uint16 _countryCode,\n        uint16 _newValue\n    ) external;\n\n    function setDatasetRuleMaxReplicasPerCity(uint16 _newValue) external;\n\n    // set maximum proportion of dataset mapping files\n    function setDatasetRuleMaxProportionOfMappingFilesToDataset(\n        uint8 _newValue\n    ) external;\n\n    function setDatasetRuleMinSPsPerDataset(uint16 _newValue) external;\n\n    function setDatasetRuleMaxReplicasPerSP(uint16 _newValue) external;\n\n    function setDatasetRuleMinTotalReplicasPerDataset(\n        uint16 _newValue\n    ) external;\n\n    function setDatasetRuleMaxTotalReplicasPerDataset(\n        uint16 _newValue\n    ) external;\n\n    function setDatacapRulesMaxAllocatedSizePerTime(uint64 _newValue) external;\n\n    function setDatacapRulesMaxRemainingPercentageForNext(\n        uint8 _newValue\n    ) external;\n\n    // Default getter functions for public variables\n    function datasetRuleMinRegionsPerDataset() external view returns (uint16);\n\n    function datasetRuleDefaultMaxReplicasPerCountry()\n        external\n        view\n        returns (uint16);\n\n    function datasetRuleMaxReplicasPerCity() external view returns (uint16);\n\n    function datasetRuleMaxProportionOfMappingFilesToDataset()\n        external\n        view\n        returns (uint8);\n\n    function datasetRuleMinSPsPerDataset() external view returns (uint16);\n\n    function datasetRuleMaxReplicasPerSP() external view returns (uint16);\n\n    function datasetRuleMinTotalReplicasPerDataset()\n        external\n        view\n        returns (uint16);\n\n    function datasetRuleMaxTotalReplicasPerDataset()\n        external\n        view\n        returns (uint16);\n\n    function datacapRulesMaxAllocatedSizePerTime()\n        external\n        view\n        returns (uint64);\n\n    function datacapRulesMaxRemainingPercentageForNext()\n        external\n        view\n        returns (uint8);\n\n    /// @notice Check if the storage area complies with filplus rules.\n    function isCompliantRuleGeolocation(\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) external view returns (bool);\n\n    /// @notice Check if the mappingFiles percentage in the dataset complies with filplus rules.\n    function isCompliantRuleMaxProportionOfMappingFilesToDataset(\n        uint64 _mappingFilesSize,\n        uint64 _sourceSize\n    ) external view returns (bool);\n\n    /// @notice Check if the total number of storage replicas complies with filplus rules.\n    function isCompliantRuleTotalReplicasPerDataset(\n        address[][] memory _dataPreparers,\n        address[][] memory _storageProviders,\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) external view returns (bool);\n\n    /// @notice Check if the storage provider for each dataset complies with filplus rules `datasetRuleMinSPsPerDataset`.\n    function isCompliantRuleMinSPsPerDataset(\n        uint16 _requirementValue,\n        uint16 _totalExists,\n        uint16 _uniqueExists\n    ) external view returns (bool);\n\n    /// @notice Check if the storage provider for each dataset complies with filplus rules `datasetRuleMaxReplicasPerSP`.\n    function isCompliantRuleMaxReplicasPerSP(\n        uint16 _value\n    ) external view returns (bool);\n}\n"
    },
    "src/v0.8/interfaces/core/IRoles.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\n\n/// @title IRoles Interface\n/// @notice This interface defines the role-based access control for various roles within the system.\ninterface IRoles is IAccessControlEnumerableUpgradeable {\n    ///@dev The new owner accepts the ownership transfer.\n    function acceptOwnership() external;\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 _role) external view;\n\n    ///@dev Returns the address of the current owner.\n    function owner() external view returns (address);\n\n    ///@dev Returns the address of the pending owner.\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external;\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/v0.8/interfaces/module/IDatacaps.sol": {
      "content": "/// SPDX-License-Identifier: GPL-3.0-or-later\n/// (c) 2023 Dataswap\n///\n/// Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     https://www.gnu.org/licenses/gpl-3.0.en.html\n///\n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n\npragma solidity ^0.8.21;\nimport {IStorages} from \"src/v0.8/interfaces/module/IStorages.sol\";\n\n/// @title IDatacap\n/// @dev Interface for managing the allocation of datacap for matched data storage.\ninterface IDatacaps {\n    /// @dev Requests the allocation of matched datacap for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    function requestAllocateDatacap(\n        uint64 _matchingId\n    ) external returns (uint64);\n\n    /// @dev Gets the allocated matched datacap for a storage.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The allocated datacap size.\n    function getAvailableDatacap(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @dev Gets the allocated matched datacap for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The allocated datacap size.\n    function getAllocatedDatacap(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @dev Gets the total datacap size needed to be allocated for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The total datacap size needed.\n    function getTotalDatacapAllocationRequirement(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @dev Gets the remaining datacap size needed to be allocated for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The remaining datacap size needed.\n    function getRemainingUnallocatedDatacap(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @dev Checks if the next datacap allocation is allowed for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return True if next allocation is allowed, otherwise false.\n    function isNextDatacapAllocationValid(\n        uint64 _matchingId\n    ) external view returns (bool);\n\n    function storages() external view returns (IStorages);\n}\n"
    },
    "src/v0.8/interfaces/module/IDatasets.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\n\n/// @title IDatasets\ninterface IDatasets {\n    ///@notice Approve a dataset.\n    ///@dev This function changes the state of the dataset to DatasetApproved and emits the DatasetApproved event.\n    function approveDataset(uint64 _datasetId) external;\n\n    ///@notice Approve the metadata of a dataset.\n    ///@dev This function changes the state of the dataset to MetadataApproved and emits the MetadataApproved event.\n    function approveDatasetMetadata(uint64 _datasetId) external;\n\n    ///@notice Reject a dataset.\n    ///@dev This function changes the state of the dataset to DatasetRejected and emits the DatasetRejected event.\n    function rejectDataset(uint64 _datasetId) external;\n\n    ///@notice Reject the metadata of a dataset.\n    ///@dev This function changes the state of the dataset to MetadataRejected and emits the MetadataRejected event.\n    function rejectDatasetMetadata(uint64 _datasetId) external;\n\n    ///@notice Submit metadata for a dataset\n    ///        Note:anyone can submit dataset metadata\n    function submitDatasetMetadata(\n        uint64 _client,\n        string memory _title,\n        string memory _industry,\n        string memory _name,\n        string memory _description,\n        string memory _source,\n        string memory _accessMethod,\n        uint64 _sizeInBytes,\n        bool _isPublic,\n        uint64 _version\n    ) external returns (uint64);\n\n    ///@notice Get dataset metadata\n    function getDatasetMetadata(\n        uint64 _datasetId\n    )\n        external\n        view\n        returns (\n            string memory title,\n            string memory industry,\n            string memory name,\n            string memory description,\n            string memory source,\n            string memory accessMethod,\n            address submitter,\n            uint64 createdBlockNumber,\n            uint64 sizeInBytes,\n            bool isPublic,\n            uint64 version\n        );\n\n    /// @notice Get submitter of dataset's metadata\n    function getDatasetMetadataSubmitter(\n        uint64 _datasetId\n    ) external view returns (address);\n\n    /// @notice Get client of dataset's metadata\n    function getDatasetMetadataClient(\n        uint64 _datasetId\n    ) external view returns (uint64);\n\n    ///@notice Get dataset state\n    function getDatasetState(\n        uint64 _datasetId\n    ) external view returns (DatasetType.State);\n\n    ///@notice Check if a dataset has metadata\n    function hasDatasetMetadata(\n        string memory _accessMethod\n    ) external view returns (bool);\n\n    /// @notice Checks if metadata fields are valid.\n    function requireValidDatasetMetadata(\n        uint64 _datasetId\n    ) external view returns (bool);\n\n    /// @notice Report the dataset has not enough collateral.\n    function reportCollateralNotEnough(uint64 _datasetId) external;\n\n    /// @notice Report the dataset has enough collateral.\n    function reportCollateralEnough(uint64 _datasetId) external;\n\n    /// @notice Report the dataset replica has already been submitted.\n    function reportDatasetReplicaRequirementSubmitted(\n        uint64 _datasetId\n    ) external;\n\n    /// @notice Report the dataset proof has already been submitted.\n    function reportDatasetProofSubmitted(uint64 _datasetId) external;\n\n    /// @notice Default getter functions for public variables\n    function datasetsCount() external view returns (uint64);\n\n    /// @notice get  roles instance\n    function roles() external view returns (IRoles);\n\n    /// @notice get  governance address\n    function governanceAddress() external view returns (address);\n}\n"
    },
    "src/v0.8/interfaces/module/IDatasetsChallenge.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\n\n/// @title IDatasetsChallenge\ninterface IDatasetsChallenge {\n    ///@notice Submit challenge proof for a dataset\n    /// Based on merkle proof challenge.\n    /// random challenge method is used to reduce the amount of data and calculation while ensuring algorithm security.\n    function submitDatasetChallengeProofs(\n        uint64 _datasetId,\n        uint64 _randomSeed,\n        bytes32[] memory _leaves,\n        bytes32[][] memory _siblings,\n        uint32[] memory _paths\n    ) external;\n\n    ///@notice Get dataset challenge proofs\n    function getDatasetChallengeProofs(\n        uint64 _datasetId,\n        address _auditor\n    )\n        external\n        view\n        returns (\n            bytes32[] memory,\n            bytes32[][] memory _siblings,\n            uint32[] memory _paths\n        );\n\n    ///@notice Get count of dataset challenge proofs\n    function getDatasetChallengeProofsCount(\n        uint64 _datasetId\n    ) external view returns (uint16);\n\n    ///@notice Checking if duplicate verifications of the Dataset\n    function isDatasetChallengeProofDuplicate(\n        uint64 _datasetId,\n        address _auditor,\n        uint64 _randomSeed\n    ) external view returns (bool);\n\n    /// @notice Get a dataset challenge count\n    function getChallengeCount(\n        uint64 _datasetId\n    ) external view returns (uint64);\n\n    /// @notice get  merkle utils\n    function merkleUtils() external view returns (IMerkleUtils);\n}\n"
    },
    "src/v0.8/interfaces/module/IDatasetsProof.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\n\n/// @title IDatasetsProof\ninterface IDatasetsProof {\n    ///@notice Submit proof root for a dataset\n    function submitDatasetProofRoot(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        string calldata _mappingFilesAccessMethod,\n        bytes32 _rootHash\n    ) external;\n\n    ///@notice Submit proof for a dataset\n    function submitDatasetProof(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        bytes32[] memory _leafHashes,\n        uint64 _leafIndex,\n        uint64[] memory _leafSizes,\n        bool _completed\n    ) external;\n\n    ///@notice Submit proof completed for a dataset\n    function submitDatasetProofCompleted(uint64 _datasetId) external;\n\n    /// @notice Append dataset collateral funds\n    function appendDatasetCollateral(uint64 _datasetId) external payable;\n\n    /// @notice Get dataset need append collateral funds\n    function getDatasetAppendCollateral(\n        uint64 _datasetId\n    ) external view returns (uint256);\n\n    ///@notice Get dataset source CIDs\n    function getDatasetProof(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) external view returns (bytes32[] memory);\n\n    ///@notice Get dataset source CIDs\n    function getDatasetCars(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) external view returns (bytes32[] memory);\n\n    function getDatasetProofCount(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) external view returns (uint64);\n\n    ///@notice Get dataset proof's submitter\n    function getDatasetProofSubmitter(\n        uint64 _datasetId\n    ) external view returns (address);\n\n    ///@notice Get dataset source CIDs\n    function getDatasetCarsCount(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) external view returns (uint64);\n\n    ///@notice Get dataset size\n    function getDatasetSize(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) external view returns (uint64);\n\n    ///@notice Get dataset minimum conditional\n    function getDatasetCollateralRequirement(\n        uint64 _datasetId\n    ) external view returns (uint256);\n\n    ///@notice Check if a dataset has a car id\n    function isDatasetContainsCar(\n        uint64 _datasetId,\n        uint64 _id\n    ) external returns (bool);\n\n    ///@notice Check if a dataset has car ids\n    function isDatasetContainsCars(\n        uint64 _datasetId,\n        uint64[] memory _ids\n    ) external view returns (bool);\n\n    ///@notice Check if a dataset has submitter\n    function isDatasetProofSubmitter(\n        uint64 _datasetId,\n        address _submitter\n    ) external view returns (bool);\n\n    ///@notice Check if a dataset proof all completed\n    function isDatasetProofallCompleted(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) external view returns (bool);\n}\n"
    },
    "src/v0.8/interfaces/module/IDatasetsRequirement.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\n\n/// @title IDatasetsRequirement\ninterface IDatasetsRequirement {\n    ///@notice Submit storage requirement for a dataset\n    ///        Note: submmiter of dataset can submit dataset storage requirement\n    function submitDatasetReplicaRequirements(\n        uint64 _datasetId,\n        address[][] memory _dataPreparers,\n        address[][] memory _storageProviders,\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) external payable;\n\n    ///@notice Get dataset replicas count\n    function getDatasetReplicasCount(\n        uint64 _datasetId\n    ) external view returns (uint16);\n\n    ///@notice Get dataset replica requirement\n    function getDatasetReplicaRequirement(\n        uint64 _datasetId,\n        uint64 _index\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            address[] memory,\n            uint16,\n            uint16,\n            uint32[] memory\n        );\n\n    ///@notice Get dataset pre conditional\n    function getDatasetPreCollateralRequirements(\n        uint64 _datasetId\n    ) external view returns (uint256);\n}\n"
    },
    "src/v0.8/interfaces/module/IMatchings.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title IMatchings\ninterface IMatchings {\n    /// @notice The function to init the dependencies of a matchings.\n    function initDependencies(\n        address _matchingsTarget,\n        address _matchingsBids\n    ) external;\n\n    /// @notice Function for create a new matching.\n    /// @param _datasetId The dataset id to create matching.\n    /// @param _bidSelectionRule The rules for determining the winning bid.\n    /// @param _biddingDelayBlockCount The number of blocks to delay bidding.\n    /// @param _biddingPeriodBlockCount The number of blocks for bidding period.\n    /// @param _storageCompletionPeriodBlocks The number of blocks for storage period.\n    /// @param _biddingThreshold The threshold for bidding.\n    /// @param _replicaIndex The index of the replica in dataset.\n    /// @param _additionalInfo The additional information about the matching.\n    /// @return The matchingId.\n    function createMatching(\n        uint64 _datasetId,\n        MatchingType.BidSelectionRule _bidSelectionRule,\n        uint64 _biddingDelayBlockCount,\n        uint64 _biddingPeriodBlockCount,\n        uint64 _storageCompletionPeriodBlocks,\n        uint256 _biddingThreshold,\n        uint16 _replicaIndex,\n        string memory _additionalInfo\n    ) external returns (uint64);\n\n    /// @notice Function for pausing a matching\n    /// @param _matchingId The matching id.\n    function pauseMatching(uint64 _matchingId) external;\n\n    /// @notice Function for resuming a paused matching\n    /// @param _matchingId The matching id.\n    function resumeMatching(uint64 _matchingId) external;\n\n    /// @notice Function for report publishing a matching\n    /// @param _matchingId The matching id to publish cars.\n    function reportPublishMatching(uint64 _matchingId) external;\n\n    /// @notice Function for report canceling a matching\n    /// @param _matchingId The matching id.\n    function reportCancelMatching(uint64 _matchingId) external;\n\n    /// @notice Function for report closing a matching\n    /// @param _matchingId The matching id.\n    function reportCloseMatching(uint64 _matchingId) external;\n\n    /// @notice Function for report complete with a winner\n    /// @param _matchingId The matching id.\n    /// @param _winner The winner of bids of matching.\n    function reportMatchingHasWinner(\n        uint64 _matchingId,\n        address _winner\n    ) external;\n\n    /// @notice Function for report complete a matching without winner\n    /// @param _matchingId The matching id.\n    function reportMatchingNoWinner(uint64 _matchingId) external;\n\n    /// @notice Function for getting matchings initiator\n    function getMatchingInitiator(\n        uint64 _matchingId\n    ) external view returns (address);\n\n    /// @notice  Function for getting the state of a matching\n    function getMatchingState(\n        uint64 _matchingId\n    ) external view returns (MatchingType.State);\n\n    /// @notice  Function for getting the bid selection rule of a matching\n    function getBidSelectionRule(\n        uint64 _matchingId\n    ) external view returns (MatchingType.BidSelectionRule);\n\n    /// @notice  Function for getting the bid threshold of a matching\n    function getBiddingThreshold(\n        uint64 _matchingId\n    ) external view returns (uint256);\n\n    /// @notice  Function for getting the start height of a matching\n    function getBiddingStartHeight(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice  Function for getting the after pause height of a matching\n    function getBiddingAfterPauseHeight(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice  Function for getting the end height of a matching\n    function getBiddingEndHeight(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    // Default getter functions for public variables\n    function matchingsCount() external view returns (uint64);\n}\n"
    },
    "src/v0.8/interfaces/module/IMatchingsBids.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title IMatchingsBid\ninterface IMatchingsBids {\n    /// @notice The function to init the dependencies of a matchingsBids.\n    function initDependencies(\n        address _matchings,\n        address _matchingsTarget\n    ) external;\n\n    /// @notice  Function for bidding on a matching\n    function bidding(uint64 _matchingId, uint256 _amount) external;\n\n    /// @notice  Function for canceling a matching\n    function cancelMatching(uint64 _matchingId) external;\n\n    /// @notice  Function for closing a matching and choosing a winner\n    function closeMatching(uint64 _matchingId) external;\n\n    /// @notice  Function for getting bids in a matching\n    function getMatchingBids(\n        uint64 _matchingId\n    ) external view returns (address[] memory, uint256[] memory);\n\n    /// @notice  Function for getting bid amount of a bidder in a matching\n    function getMatchingBidAmount(\n        uint64 _matchingId,\n        address _bidder\n    ) external view returns (uint256);\n\n    /// @notice  Function for getting the count of bids in a matching\n    function getMatchingBidsCount(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice  Function for getting winner of a matching\n    function getMatchingWinner(\n        uint64 _matchingId\n    ) external view returns (address);\n\n    /// @notice  Function for getting winners of a matchings\n    function getMatchingWinners(\n        uint64[] memory _matchingIds\n    ) external view returns (address[] memory);\n\n    /// @notice  Function for checking if a bidder has a bid in a matching\n    function hasMatchingBid(\n        uint64 _matchingId,\n        address _bidder\n    ) external view returns (bool);\n}\n"
    },
    "src/v0.8/interfaces/module/IMatchingsTarget.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title IMatchingsTarget\ninterface IMatchingsTarget {\n    /// @notice The function to init the dependencies of a matchingsTarget.\n    function initDependencies(\n        address _matchings,\n        address _matchingsBids\n    ) external;\n\n    /// @notice Function for create a new matching target.\n    /// @param _matchingId The matching id to publish cars.\n    /// @param _datasetId The dataset id to create matching.\n    /// @param _dataType Identify the data type of \"cars\", which can be either \"Source\" or \"MappingFiles\".\n    /// @param _associatedMappingFilesMatchingID The matching ID that associated with mapping files of dataset of _datasetId\n    /// @param _replicaIndex The index of the replica in dataset.\n    function createTarget(\n        uint64 _matchingId,\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _associatedMappingFilesMatchingID,\n        uint16 _replicaIndex\n    ) external;\n\n    /// @notice  Function for parse cars from indexes.\n    /// @param _starts The starts of cars to publish.\n    /// @param _ends The ends of cars to publish.\n    /// @return The cars of the indexes.\n    function parseCars(\n        uint64[] memory _starts,\n        uint64[] memory _ends\n    ) external pure returns (uint64[] memory);\n\n    /// @notice  Function for publishing a matching\n    /// @param _matchingId The matching id to publish cars.\n    /// @param _datasetId The dataset id of matching.\n    /// @param _carsStarts The cars to publish.\n    /// @param _carsEnds The cars to publish.\n    /// @param complete If the publish is complete.\n    function publishMatching(\n        uint64 _matchingId,\n        uint64 _datasetId,\n        uint64[] memory _carsStarts,\n        uint64[] memory _carsEnds,\n        bool complete\n    ) external;\n\n    /// @notice  Function for getting the count of bids in a matching\n    function getMatchingCars(\n        uint64 _matchingId\n    ) external view returns (uint64[] memory);\n\n    /// @notice  Function for getting the dataset id in a matching\n    function getMatchingDatasetId(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice Get the index of matching's replica.\n    function getMatchingReplicaIndex(\n        uint64 _matchingId\n    ) external view returns (uint16);\n\n    /// @notice get matchings size\n    function getMatchingSize(uint64 _matchingId) external view returns (uint64);\n\n    /// @notice Get the target information of a matching.\n    /// @param _matchingId The ID of the matching.\n    /// @return datasetID The ID of the associated dataset.\n    /// @return cars An array of CIDs representing the cars in the matching.\n    /// @return size The size of the matching.\n    /// @return dataType The data type of the matching.\n    /// @return associatedMappingFilesMatchingID The ID of the associated mapping files matching.\n    function getMatchingTarget(\n        uint64 _matchingId\n    )\n        external\n        view\n        returns (\n            uint64 datasetID,\n            uint64[] memory cars,\n            uint64 size,\n            DatasetType.DataType dataType,\n            uint64 associatedMappingFilesMatchingID\n        );\n\n    /// @notice Check if a matching with the given matching ID contains a specific CID.\n    /// @param _matchingId The ID of the matching to check.\n    /// @param _cid The CID (Content Identifier) to check for.\n    /// @return True if the matching contains the specified CID, otherwise false.\n    function isMatchingContainsCar(\n        uint64 _matchingId,\n        uint64 _cid\n    ) external view returns (bool);\n\n    /// @notice Check if a matching with the given matching ID contains multiple CIDs.\n    /// @param _matchingId The ID of the matching to check.\n    /// @param _cids An array of CIDs (Content Identifiers) to check for.\n    /// @return True if the matching contains all the specified CIDs, otherwise false.\n    function isMatchingContainsCars(\n        uint64 _matchingId,\n        uint64[] memory _cids\n    ) external view returns (bool);\n\n    /// @notice check is matching targe valid\n    function isMatchingTargetValid(\n        uint64 _datasetId,\n        uint64[] memory _cars,\n        uint64 _size,\n        DatasetType.DataType _dataType,\n        uint64 _associatedMappingFilesMatchingID\n    ) external view returns (bool);\n\n    /// @notice Check if a matching meets the requirements of Fil+.\n    function isMatchingTargetMeetsFilPlusRequirements(\n        uint64 _matchingId,\n        address candidate\n    ) external view returns (bool);\n}\n"
    },
    "src/v0.8/interfaces/module/IStorages.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\n\n/// @title Interface for Matchedstores contract\ninterface IStorages {\n    /// @dev Submits a Filecoin claim Id for a matchedstore after successful matching.\n    /// @param _matchingId The ID of the matching.\n    /// @param _provider A provider of storage provider of matching.\n    /// @param _id The content identifier of the matched data.\n    /// @param _claimId The ID of the successful Filecoin storage deal.\n    function submitStorageClaimId(\n        uint64 _matchingId,\n        uint64 _provider,\n        uint64 _id,\n        uint64 _claimId\n    ) external;\n\n    /// @dev Submits multiple Filecoin claim Ids for a matchedstore after successful matching.\n    /// @param _matchingId The ID of the matching.\n    /// @param _provider A provider of storage provider of matching.\n    /// @param _ids An array of content identifiers of the matched data.\n    /// @param _claimIds An array of IDs of successful Filecoin storage deals.\n    function submitStorageClaimIds(\n        uint64 _matchingId,\n        uint64 _provider,\n        uint64[] memory _ids,\n        uint64[] memory _claimIds\n    ) external;\n\n    /// @dev Gets the list of done cars in the matchedstore.\n    /// @param _matchingId The ID of the matching.\n    /// @return An array of content identifiers of the done cars.\n    function getStoredCars(\n        uint64 _matchingId\n    ) external view returns (uint64[] memory);\n\n    /// @dev Gets the count of done cars in the matchedstore.\n    /// @param _matchingId The ID of the matching.\n    /// @return The count of done cars in the matchedstore.\n    function getStoredCarCount(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    /// @notice get total stored size\n    /// @param _matchingId The ID of the matching.\n    /// @return The total size of the matching's stored cars.\n    function getTotalStoredSize(\n        uint64 _matchingId\n    ) external view returns (uint64);\n\n    ///@notice get car size\n    /// @param _matchingId The ID of the matching.\n    /// @param _id The content identifier of the matched data.\n    /// @return The size of the matching's stored cars.\n    function getStoredCarSize(\n        uint64 _matchingId,\n        uint64 _id\n    ) external view returns (uint64);\n\n    /// @dev Checks if all cars are done in the matchedstore.\n    /// @param _matchingId The ID of the matching.\n    /// @return True if all cars are done in the matchedstore, otherwise false.\n    function isAllStoredDone(uint64 _matchingId) external view returns (bool);\n\n    ///@notice get matchings instance\n    function matchings() external view returns (IMatchings);\n\n    ///@notice get matchingsTarget instance\n    function matchingsTarget() external view returns (IMatchingsTarget);\n\n    ///@notice get matchingsBids instance\n    function matchingsBids() external view returns (IMatchingsBids);\n}\n"
    },
    "src/v0.8/interfaces/utils/IMerkleUtils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title IMerkleUtils\ninterface IMerkleUtils {\n    /// @notice Validate a Merkle proof.\n    /// @dev This function checks if a given Merkle proof is valid.\n    function isValidMerkleProof(\n        bytes32 _root,\n        bytes32 _leaf,\n        bytes32[] memory _siblings,\n        uint32 _path\n    ) external view returns (bool);\n\n    /// @notice Set mock valid state\n    function setMockValidState(bool _state) external;\n}\n"
    },
    "src/v0.8/mocks/core/filecoin/MockFilecoin.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract MockFilecoin is\n    Initializable,\n    UUPSUpgradeable,\n    IFilecoin,\n    RolesModifiers\n{\n    IRoles private roles;\n    FilecoinType.DealState private mockDealState;\n    address datacapAddress;\n    //bytes private mockClaimData;\n    mapping(uint64 => bytes) private mockClaimData; //matchingId=>Matchedstore\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(address _roles) public initializer {\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice The function to init the dependencies of a filecoin.\n    function initDependencies(\n        address _datacap\n    ) external onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        datacapAddress = _datacap;\n    }\n\n    /// @notice The function to allocate the datacap of a storage deal.\n    function allocateDatacap(uint64 client, uint256 _size) external {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev mock the filecoin storage state\n    function setMockDealState(FilecoinType.DealState _state) external {\n        mockDealState = _state;\n    }\n\n    /// @dev get replica filecoin storage state\n    function getReplicaDealState(\n        bytes32,\n        uint64\n    ) external view override returns (FilecoinType.DealState) {\n        return mockDealState;\n    }\n\n    /// @dev mock the filecoin claim data\n    function setMockClaimData(uint64 claimId, bytes memory _data) external {\n        mockClaimData[claimId] = _data;\n    }\n\n    /// @notice The function to get the data of a claim for a replica.\n    function getReplicaClaimData(\n        uint64,\n        uint64 claimId\n    ) external view override returns (bytes memory) {\n        return mockClaimData[claimId];\n    }\n}\n"
    },
    "src/v0.8/mocks/utils/merkle/MockMerkleUtils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title MockMerkleUtils\ncontract MockMerkleUtils is\n    Initializable,\n    UUPSUpgradeable,\n    IMerkleUtils,\n    RolesModifiers\n{\n    IRoles private roles;\n    bool private mockValidState;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(address _roles) public initializer {\n        mockValidState = true;\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Validate a Merkle proof.\n    /// @dev This function checks if a given Merkle proof is valid.\n    function isValidMerkleProof(\n        bytes32,\n        bytes32,\n        bytes32[] memory,\n        uint32\n    ) external view returns (bool) {\n        require(mockValidState == true, \"mockValidState must is true\");\n        return mockValidState;\n    }\n\n    /// @notice Set mock valid state\n    function setMockValidState(bool _state) external {\n        mockValidState = _state;\n    }\n}\n"
    },
    "src/v0.8/module/datacap/Datacaps.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\nimport {IStorages} from \"src/v0.8/interfaces/module/IStorages.sol\";\nimport {IDatacaps} from \"src/v0.8/interfaces/module/IDatacaps.sol\";\n\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\n\n/// shared\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\nimport {DatacapsModifiers} from \"src/v0.8/shared/modifiers/DatacapsModifiers.sol\";\nimport {DatacapsEvents} from \"src/v0.8/shared/events/DatacapsEvents.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n// TODO:version issue\n// import {DataCapAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/DataCapAPI.sol\";\n// import {DataCapTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/DataCapTypes.sol\";\n// import {FilAddresses} from \"@zondax/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol\";\n// import {BigInts} from \"@zondax/filecoin-solidity/contracts/v0.8/utils/BigInts.sol\";\n\n/// @title Datacap\n/// @dev Manages the allocation of datacap for matched data storage after successful matching with Filecoin storage deals.\n/// Note:The removal of datacap is not necessary.\n///     This design allocates datacap step by step according to chunks,\n///     rather than allocating all at once.\ncontract Datacaps is\n    Initializable,\n    UUPSUpgradeable,\n    IDatacaps,\n    DatacapsModifiers\n{\n    //(matchingID => allocated datacap size)\n    mapping(uint64 => uint64) private allocatedDatacaps;\n    address private governanceAddress;\n    IRoles private roles;\n    IFilplus private filplus;\n    IFilecoin private filecoin;\n    ICarstore private carstore;\n    IDatasets private datasets;\n    IMatchings private matchings;\n    IMatchingsTarget private matchingsTarget;\n    IMatchingsBids private matchingsBids;\n    IStorages public storages;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    // solhint-disable-next-line\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _filecoin,\n        address _carstore,\n        address _datasets,\n        address _matchings,\n        address _matchingsTarget,\n        address _matchingsBids,\n        address _storages\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        filplus = IFilplus(_filplus);\n        filecoin = IFilecoin(_filecoin);\n        carstore = ICarstore(_carstore);\n        datasets = IDatasets(_datasets);\n        matchings = IMatchings(_matchings);\n        matchingsTarget = IMatchingsTarget(_matchingsTarget);\n        matchingsBids = IMatchingsBids(_matchingsBids);\n        storages = IStorages(_storages);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Internal function to allocate matched datacap.\n    // solhint-disable-next-line\n    function _allocateDatacap(\n        uint64 _matchingId,\n        uint64 _size // solhint-disable-next-line\n    ) internal {\n        uint64 datasetId = matchingsTarget.getMatchingDatasetId(_matchingId);\n        uint64 client = datasets.getDatasetMetadataClient(datasetId);\n        filecoin.allocateDatacap(client, uint256(_size));\n    }\n\n    /// @dev Requests the allocation of matched datacap for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    function requestAllocateDatacap(\n        uint64 _matchingId\n    )\n        external\n        onlyAddress(matchings.getMatchingInitiator(_matchingId))\n        onlyNotZeroAddress(matchings.getMatchingInitiator(_matchingId))\n        validNextDatacapAllocation(this, _matchingId)\n        returns (uint64)\n    {\n        uint64 remainingUnallocatedDatacap = getRemainingUnallocatedDatacap(\n            _matchingId\n        );\n        uint64 maxAllocateCapacityPreTime = filplus\n            .datacapRulesMaxAllocatedSizePerTime();\n        if (remainingUnallocatedDatacap <= maxAllocateCapacityPreTime) {\n            allocatedDatacaps[_matchingId] =\n                allocatedDatacaps[_matchingId] +\n                remainingUnallocatedDatacap;\n            _allocateDatacap(_matchingId, remainingUnallocatedDatacap);\n\n            emit DatacapsEvents.DatacapAllocated(\n                _matchingId,\n                remainingUnallocatedDatacap\n            );\n            return remainingUnallocatedDatacap;\n        } else {\n            allocatedDatacaps[_matchingId] =\n                allocatedDatacaps[_matchingId] +\n                maxAllocateCapacityPreTime;\n            _allocateDatacap(_matchingId, maxAllocateCapacityPreTime);\n\n            emit DatacapsEvents.DatacapAllocated(\n                _matchingId,\n                maxAllocateCapacityPreTime\n            );\n            return maxAllocateCapacityPreTime;\n        }\n    }\n\n    /// @dev Gets the allocated matched datacap for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The allocated datacap size.\n    function getAllocatedDatacap(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        return allocatedDatacaps[_matchingId];\n    }\n\n    /// @notice Gets the available datacap that can still be allocated for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The available datacap size.\n    function getAvailableDatacap(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        uint64 allocatedDatacap = getAllocatedDatacap(_matchingId);\n        uint64 reallyStored = storages.getTotalStoredSize(_matchingId);\n        return allocatedDatacap - reallyStored;\n    }\n\n    /// @dev Gets the total datacap size needed to be allocated for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The total datacap size needed.\n    function getTotalDatacapAllocationRequirement(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        return matchingsTarget.getMatchingSize(_matchingId);\n    }\n\n    /// @dev Gets the remaining datacap size needed to be allocated for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return The remaining datacap size needed.\n    function getRemainingUnallocatedDatacap(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        uint64 allocatedDatacap = getAllocatedDatacap(_matchingId);\n        uint64 totalDatacapAllocationRequirement = getTotalDatacapAllocationRequirement(\n                _matchingId\n            );\n        return totalDatacapAllocationRequirement - allocatedDatacap;\n    }\n\n    /// @dev Checks if the next datacap allocation is allowed for a matching process.\n    /// @param _matchingId The ID of the matching process.\n    /// @return True if next allocation is allowed, otherwise false.\n    function isNextDatacapAllocationValid(\n        uint64 _matchingId\n    ) public view returns (bool) {\n        uint64 totalDatacapAllocationRequirement = getTotalDatacapAllocationRequirement(\n                _matchingId\n            );\n        uint64 allocatedDatacap = getAllocatedDatacap(_matchingId);\n        uint64 reallyStored = storages.getTotalStoredSize(_matchingId);\n        uint64 availableDatacap = getAvailableDatacap(_matchingId);\n        uint64 allocationThreshold = (filplus\n            .datacapRulesMaxRemainingPercentageForNext() / 100) *\n            filplus.datacapRulesMaxAllocatedSizePerTime();\n\n        if (allocatedDatacap > totalDatacapAllocationRequirement) {\n            revert Errors.AllocatedDatacapExceedsTotalRequirement(\n                allocatedDatacap,\n                totalDatacapAllocationRequirement\n            );\n        }\n\n        if (reallyStored > allocatedDatacap) {\n            revert Errors.StoredExceedsAllocatedDatacap(\n                reallyStored,\n                allocatedDatacap\n            );\n        }\n\n        if (availableDatacap > allocationThreshold) {\n            revert Errors.AvailableDatacapExceedAllocationThreshold(\n                availableDatacap,\n                allocationThreshold\n            );\n        }\n\n        return true;\n    }\n}\n"
    },
    "src/v0.8/module/dataset/Datasets.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IEscrow} from \"src/v0.8/interfaces/core/IEscrow.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\n///shared\nimport {DatasetsEvents} from \"src/v0.8/shared/events/DatasetsEvents.sol\";\nimport {DatasetsModifiers} from \"src/v0.8/shared/modifiers/DatasetsModifiers.sol\";\n/// library\nimport {DatasetMetadataLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetMetadataLIB.sol\";\nimport {DatasetStateMachineLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetStateMachineLIB.sol\";\nimport {DatasetAuditLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetAuditLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Datasets Base Contract\n/// @notice This contract serves as the base for managing Dataset, metadata, state.\n/// @dev This contract is intended to be inherited by specific dataset-related contracts.\ncontract Datasets is\n    Initializable,\n    UUPSUpgradeable,\n    IDatasets,\n    DatasetsModifiers\n{\n    using DatasetMetadataLIB for DatasetType.Dataset;\n    using DatasetAuditLIB for DatasetType.Dataset;\n    using DatasetStateMachineLIB for DatasetType.Dataset;\n\n    uint64 public datasetsCount; // Total count of datasets\n    mapping(uint64 => DatasetType.Dataset) private datasets; // Mapping of dataset ID to dataset details\n\n    address public governanceAddress;\n    IRoles public roles;\n    IEscrow public escrow;\n    IDatasetsProof private datasetsProof;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _escrow\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        escrow = IEscrow(_escrow);\n\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice setDatasetsProofAddress function to initialize the datasetsProof contract.\n    /// @dev After the contract is deployed, this function needs to be called manually!\n    function setDatasetsProofAddress(\n        address _datasetsProof\n    ) public onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        datasetsProof = IDatasetsProof(_datasetsProof);\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    ///@notice Approve a dataset.\n    ///@dev This function changes the state of the dataset to DatasetApproved and emits the DatasetApproved event.\n    function approveDataset(\n        uint64 _datasetId\n    )\n        external\n        onlyNotZero(_datasetId)\n        onlyDatasetState(\n            this,\n            _datasetId,\n            DatasetType.State.DatasetProofSubmitted\n        )\n        onlyAddress(governanceAddress)\n    {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        uint256 funds = escrow.getOwnerTotal(\n            EscrowType.Type.DatacapCollateral,\n            dataset.metadata.submitter,\n            _datasetId\n        );\n        if (\n            funds >= datasetsProof.getDatasetCollateralRequirement(_datasetId)\n        ) {\n            // Update collateral funds to collateral requirement\n            escrow.emitCollateralEvent(\n                EscrowType.Type.DatacapCollateral,\n                dataset.metadata.submitter,\n                _datasetId,\n                EscrowType.CollateralEvent.SyncCollateral\n            );\n\n            dataset.approveDataset();\n            emit DatasetsEvents.DatasetApproved(_datasetId);\n        } else {\n            dataset.rejectDataset();\n            emit DatasetsEvents.DatasetRejected(_datasetId);\n        }\n    }\n\n    ///@notice Approve the metadata of a dataset.\n    ///@dev This function changes the state of the dataset to MetadataApproved and emits the MetadataApproved event.\n    function approveDatasetMetadata(\n        uint64 _datasetId\n    )\n        external\n        onlyNotZero(_datasetId)\n        onlyDatasetState(this, _datasetId, DatasetType.State.MetadataSubmitted)\n        onlyAddress(governanceAddress)\n    {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n\n        dataset.approveDatasetMetadata();\n        emit DatasetsEvents.DatasetMetadataApproved(_datasetId);\n    }\n\n    ///@notice Reject the metadata of a dataset.\n    ///@dev This function changes the state of the dataset to MetadataRejected and emits the MetadataRejected event.\n    function rejectDatasetMetadata(\n        uint64 _datasetId\n    )\n        external\n        onlyNotZero(_datasetId)\n        onlyDatasetState(this, _datasetId, DatasetType.State.MetadataSubmitted)\n        onlyAddress(governanceAddress)\n    {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset.rejectDatasetMetadata();\n\n        emit DatasetsEvents.DatasetMetadataRejected(_datasetId);\n    }\n\n    ///@notice Reject a dataset.\n    ///@dev This function changes the state of the dataset to DatasetRejected and emits the DatasetRejected event.\n    function rejectDataset(\n        uint64 _datasetId\n    )\n        external\n        onlyNotZero(_datasetId)\n        onlyDatasetState(\n            this,\n            _datasetId,\n            DatasetType.State.DatasetProofSubmitted\n        )\n        onlyAddress(governanceAddress)\n    {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset.rejectDataset();\n\n        emit DatasetsEvents.DatasetRejected(_datasetId);\n    }\n\n    ///@notice Submit metadata for a dataset\n    ///        Note:anyone can submit dataset metadata\n    function submitDatasetMetadata(\n        uint64 _client,\n        string memory _title,\n        string memory _industry,\n        string memory _name,\n        string memory _description,\n        string memory _source,\n        string memory _accessMethod,\n        uint64 _sizeInBytes,\n        bool _isPublic,\n        uint64 _version\n    )\n        external\n        onlyDatasetMetadataNotExsits(this, _accessMethod)\n        returns (uint64)\n    {\n        //Note: params check in lib\n        datasetsCount++;\n\n        DatasetType.Dataset storage dataset = datasets[datasetsCount];\n        dataset.submitDatasetMetadata(\n            _client,\n            _title,\n            _industry,\n            _name,\n            _description,\n            _source,\n            _accessMethod,\n            _sizeInBytes,\n            _isPublic,\n            _version\n        );\n\n        emit DatasetsEvents.DatasetMetadataSubmitted(datasetsCount, msg.sender);\n        return datasetsCount;\n    }\n\n    ///@notice Get dataset metadata\n    function getDatasetMetadata(\n        uint64 _datasetId\n    )\n        public\n        view\n        onlyNotZero(_datasetId)\n        returns (\n            string memory title,\n            string memory industry,\n            string memory name,\n            string memory description,\n            string memory source,\n            string memory accessMethod,\n            address submitter,\n            uint64 createdBlockNumber,\n            uint64 sizeInBytes,\n            bool isPublic,\n            uint64 version\n        )\n    {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        require(\n            bytes(dataset.metadata.title).length > 0,\n            \"Metadata does not exist\"\n        );\n        return (\n            dataset.metadata.title,\n            dataset.metadata.industry,\n            dataset.metadata.name,\n            dataset.metadata.description,\n            dataset.metadata.source,\n            dataset.metadata.accessMethod,\n            dataset.metadata.submitter,\n            dataset.metadata.createdBlockNumber,\n            dataset.metadata.sizeInBytes,\n            dataset.metadata.isPublic,\n            dataset.metadata.version\n        );\n    }\n\n    /// @notice Get submitter of dataset's metadata\n    function getDatasetMetadataSubmitter(\n        uint64 _datasetId\n    ) public view returns (address) {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        return dataset.getDatasetMetadataSubmitter();\n    }\n\n    /// @notice Get client of dataset's metadata\n    function getDatasetMetadataClient(\n        uint64 _datasetId\n    ) public view returns (uint64) {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        return dataset.getDatasetMetadataClient();\n    }\n\n    ///@notice Get dataset state\n    function getDatasetState(\n        uint64 _datasetId\n    ) public view onlyNotZero(_datasetId) returns (DatasetType.State) {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        return dataset.getDatasetState();\n    }\n\n    ///@notice Check if a dataset has metadata\n    function hasDatasetMetadata(\n        string memory _accessMethod\n    ) public view returns (bool) {\n        for (uint64 i = 1; i <= datasetsCount; i++) {\n            DatasetType.Dataset storage dataset = datasets[i];\n            if (dataset.hasDatasetMetadata(_accessMethod)) return true;\n        }\n        return false;\n    }\n\n    /// @notice Checks if metadata fields are valid.\n    function requireValidDatasetMetadata(\n        uint64 _datasetId\n    ) external view returns (bool) {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset.requireValidDatasetMetadata();\n        return true;\n    }\n\n    /// @notice Report the dataset replica has already been submitted.\n    function reportDatasetReplicaRequirementSubmitted(\n        uint64 _datasetId\n    ) external {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset._emitDatasetEvent(DatasetType.Event.SubmitMetadata);\n    }\n\n    /// @notice Report the dataset has not enough collateral.\n    function reportCollateralNotEnough(uint64 _datasetId) external {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset._emitDatasetEvent(DatasetType.Event.NotEnoughCollateral);\n    }\n\n    /// @notice Report the dataset has enough collateral.\n    function reportCollateralEnough(uint64 _datasetId) external {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset._emitDatasetEvent(DatasetType.Event.EnoughCollateral);\n    }\n\n    /// @notice Report the dataset proof has already been submitted.\n    function reportDatasetProofSubmitted(uint64 _datasetId) external {\n        DatasetType.Dataset storage dataset = datasets[_datasetId];\n        dataset._emitDatasetEvent(DatasetType.Event.SubmitDatasetProof);\n    }\n}\n"
    },
    "src/v0.8/module/dataset/DatasetsChallenge.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IDatasetsChallenge} from \"src/v0.8/interfaces/module/IDatasetsChallenge.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\n///shared\nimport {DatasetsEvents} from \"src/v0.8/shared/events/DatasetsEvents.sol\";\nimport {CarstoreModifiers} from \"src/v0.8/shared/modifiers/CarstoreModifiers.sol\";\n/// library\nimport {DatasetChallengeProofLIB} from \"src/v0.8/module/dataset/library/challenge/DatasetChallengeProofLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title DatasetsChallenge Contract\n/// @notice This contract serves as the base for managing DatasetChallengeProof.\n/// @dev This contract is intended to be inherited by specific dataset-related contracts.\ncontract DatasetsChallenge is\n    Initializable,\n    UUPSUpgradeable,\n    IDatasetsChallenge,\n    CarstoreModifiers\n{\n    using DatasetChallengeProofLIB for DatasetType.DatasetChallengeProof;\n    mapping(uint64 => DatasetType.DatasetChallengeProof)\n        private datasetChallengeProofs; // Mapping of dataset ID to dataset details\n\n    address public governanceAddress;\n    IRoles public roles;\n    IMerkleUtils public merkleUtils;\n    IDatasetsProof public datasetProof;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _datasetProof,\n        address _merkleUtils\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        datasetProof = IDatasetsProof(_datasetProof);\n        merkleUtils = IMerkleUtils(_merkleUtils);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    ///@notice Submit challenge proof for a dataset\n    /// Based on merkle proof challenge.\n    /// random challenge method is used to reduce the amount of data and calculation while ensuring algorithm security.\n    function submitDatasetChallengeProofs(\n        uint64 _datasetId,\n        uint64 _randomSeed,\n        bytes32[] memory _leaves,\n        bytes32[][] memory _siblings,\n        uint32[] memory _paths\n    ) external onlyRole(roles, RolesType.DATASET_AUDITOR) {\n        DatasetType.DatasetChallengeProof\n            storage datasetChallengeProof = datasetChallengeProofs[_datasetId];\n        bytes32[] memory roots = _getChallengeRoots(\n            _datasetId,\n            _randomSeed,\n            getChallengeCount(_datasetId)\n        );\n        datasetChallengeProof._submitDatasetChallengeProofs(\n            _randomSeed,\n            _leaves,\n            _siblings,\n            _paths,\n            roots,\n            merkleUtils\n        );\n        emit DatasetsEvents.DatasetChallengeProofsSubmitted(\n            _datasetId,\n            msg.sender\n        );\n    }\n\n    ///@notice Get dataset challenge proofs\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    /// @param _auditor The auditor of the dataset for which challenge proof is submitted.\n    function getDatasetChallengeProofs(\n        uint64 _datasetId,\n        address _auditor\n    )\n        public\n        view\n        onlyNotZero(_datasetId)\n        returns (\n            bytes32[] memory,\n            bytes32[][] memory _siblings,\n            uint32[] memory _paths\n        )\n    {\n        DatasetType.DatasetChallengeProof\n            storage datasetChallengeProof = datasetChallengeProofs[_datasetId];\n        return datasetChallengeProof.getDatasetChallengeProofs(_auditor);\n    }\n\n    ///@notice Get count of dataset chellange proofs.\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    function getDatasetChallengeProofsCount(\n        uint64 _datasetId\n    ) public view onlyNotZero(_datasetId) returns (uint16) {\n        DatasetType.DatasetChallengeProof\n            storage datasetChallengeProof = datasetChallengeProofs[_datasetId];\n        return datasetChallengeProof.getDatasetChallengeProofsCount();\n    }\n\n    ///@notice Check if the challenge proof is a duplicate.\n    function isDatasetChallengeProofDuplicate(\n        uint64 _datasetId,\n        address _auditor,\n        uint64 _randomSeed\n    ) public view returns (bool) {\n        DatasetType.DatasetChallengeProof\n            storage datasetChallengeProof = datasetChallengeProofs[_datasetId];\n        return\n            datasetChallengeProof.isDatasetChallengeProofDuplicate(\n                _auditor,\n                _randomSeed\n            );\n    }\n\n    ///@notice Get a dataset challenge count\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    function getChallengeCount(uint64 _datasetId) public view returns (uint64) {\n        uint32 smallDataSet = 1000;\n        uint64 carCount = datasetProof.getDatasetProofCount(\n            _datasetId,\n            DatasetType.DataType.Source\n        );\n        if (carCount < smallDataSet) {\n            return 1;\n        } else {\n            return carCount / smallDataSet + 1;\n        }\n    }\n\n    /// @notice generate cars challenge.\n    /// @dev This function returns the cars Challenge information for a specific dataset.\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    /// @param _randomSeed The cars challenge random seed.\n    /// @param _carChallengesCount the cars Challenge count for specific dataset.\n    function _getChallengeRoots(\n        uint64 _datasetId,\n        uint64 _randomSeed,\n        uint64 _carChallengesCount\n    ) internal view returns (bytes32[] memory) {\n        bytes32[] memory carChallenges = new bytes32[](_carChallengesCount);\n        for (uint64 i = 0; i < _carChallengesCount; i++) {\n            carChallenges[i] = _getChallengeRoot(\n                _datasetId,\n                _randomSeed,\n                i,\n                _carChallengesCount\n            );\n        }\n        return carChallenges;\n    }\n\n    /// @notice generate a car challenge.\n    /// @dev This function returns a car Challenge information for a specific dataset.\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    /// @param _randomSeed The cars challenge random seed.\n    /// @param _index The car index of challenge.\n    /// @param _carChallengesCount the cars Challenge count for specific dataset.\n    function _getChallengeRoot(\n        uint64 _datasetId,\n        uint64 _randomSeed,\n        uint64 _index,\n        uint64 _carChallengesCount\n    ) internal view returns (bytes32) {\n        uint64 index = DatasetChallengeProofLIB.generateChallengeIndex(\n            _randomSeed,\n            _index,\n            _carChallengesCount\n        );\n\n        return\n            datasetProof.getDatasetProof(\n                _datasetId,\n                DatasetType.DataType.Source,\n                index,\n                1\n            )[0];\n    }\n}\n"
    },
    "src/v0.8/module/dataset/DatasetsProof.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IEscrow} from \"src/v0.8/interfaces/core/IEscrow.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\n\n///shared\nimport {DatasetsEvents} from \"src/v0.8/shared/events/DatasetsEvents.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\nimport {DatasetsModifiers} from \"src/v0.8/shared/modifiers/DatasetsModifiers.sol\";\n/// library\nimport {DatasetProofLIB} from \"src/v0.8/module/dataset/library/proof/DatasetProofLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title DatasetsProof Contract\n/// @notice This contract serves as the base for managing datasetProof.\n/// @dev This contract is intended to be inherited by specific dataset-related contracts.\ncontract DatasetsProof is\n    Initializable,\n    UUPSUpgradeable,\n    IDatasetsProof,\n    DatasetsModifiers\n{\n    using DatasetProofLIB for DatasetType.DatasetProof;\n\n    mapping(uint64 => DatasetType.DatasetProof) private datasetProofs; // Mapping of dataset ID to dataset details\n\n    address public governanceAddress;\n    IRoles public roles;\n    IEscrow public escrow;\n    IFilplus private filplus;\n    ICarstore private carstore;\n    IDatasets private datasets;\n    IDatasetsRequirement private datasetsRequirement;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _carstore,\n        address _datasets,\n        address _datasetsRequirement,\n        address _escrow\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        escrow = IEscrow(_escrow);\n        filplus = IFilplus(_filplus);\n        carstore = ICarstore(_carstore);\n        datasets = IDatasets(_datasets);\n        datasetsRequirement = IDatasetsRequirement(_datasetsRequirement);\n\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    ///@notice Submit proof root for a dataset\n    ///@dev Submit the rootHash of the dataset, the mappingFilesAccessMethod,\n    /// and confirm that the sender is the submitter of the dataset.\n    function submitDatasetProofRoot(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        string calldata _mappingFilesAccessMethod,\n        bytes32 _rootHash\n    )\n        external\n        onlyDatasetProofSubmitterOrSubmitterNotExsits(\n            this,\n            _datasetId,\n            msg.sender\n        )\n        onlyDatasetState(\n            datasets,\n            _datasetId,\n            DatasetType.State.MetadataApproved\n        )\n    {\n        //Note: params check in lib\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        if (_dataType == DatasetType.DataType.MappingFiles) {\n            if (bytes(datasetProof.mappingFilesAccessMethod).length == 0) {\n                datasetProof\n                    .mappingFilesAccessMethod = _mappingFilesAccessMethod;\n            }\n        }\n        // If the Dataset proof has not been submitted before,\n        // then set the current sender as the submitter.\n        if (\n            datasetProof.getDatasetCount(DatasetType.DataType.Source) == 0 &&\n            datasetProof.getDatasetCount(DatasetType.DataType.MappingFiles) == 0\n        ) {\n            datasetProof.proofSubmitter = msg.sender;\n        }\n        require(\n            datasetProof.isDatasetSubmitter(msg.sender),\n            \"Invalid Dataset submitter\"\n        );\n        datasetProof.addDatasetProofRoot(_dataType, _rootHash);\n    }\n\n    ///@notice Internal submit proof for a dataset\n    ///@dev Submit the proof of the dataset in batches,\n    /// specifically by submitting the _leafHashes in the order of _leafIndexes.\n    function _submitDatasetProof(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        bytes32[] memory _leafHashes,\n        uint64 _leafIndex,\n        uint64[] memory _leafSizes,\n        bool _completed\n    )\n        internal\n        onlyDatasetState(\n            datasets,\n            _datasetId,\n            DatasetType.State.MetadataApproved\n        )\n    {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n\n        // Checking if the current sender is the submitter.\n        require(\n            datasetProof.isDatasetSubmitter(msg.sender),\n            \"Invalid Dataset submitter\"\n        );\n\n        uint16 replicaCount = datasetsRequirement.getDatasetReplicasCount(\n            _datasetId\n        );\n\n        (uint64[] memory leafIds, uint64 size) = carstore.addCars(\n            _leafHashes,\n            _datasetId,\n            _leafSizes,\n            replicaCount\n        );\n\n        datasetProof.addDatasetProofBatch(\n            _dataType,\n            leafIds,\n            _leafIndex,\n            size,\n            _completed\n        );\n    }\n\n    ///@notice Submit proof completed for a dataset\n    function submitDatasetProofCompleted(uint64 _datasetId) public {\n        //Note: params check in lib\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        if (\n            datasetProof.sourceProof.allCompleted &&\n            datasetProof.mappingFilesProof.allCompleted\n        ) {\n            require(\n                filplus.isCompliantRuleMaxProportionOfMappingFilesToDataset(\n                    datasetProof.getDatasetSize(\n                        DatasetType.DataType.MappingFiles\n                    ),\n                    datasetProof.getDatasetSize(DatasetType.DataType.Source)\n                ),\n                \"Invalid mappingFiles percentage\"\n            );\n\n            uint256 collateralRequirement = getDatasetCollateralRequirement(\n                _datasetId\n            );\n            if (\n                escrow.getOwnerTotal(\n                    EscrowType.Type.DatacapCollateral,\n                    datasets.getDatasetMetadataSubmitter(_datasetId),\n                    _datasetId\n                ) < collateralRequirement\n            ) {\n                datasets.reportCollateralNotEnough(_datasetId);\n                emit DatasetsEvents.CollateralNotEnough(_datasetId, msg.sender);\n            } else {\n                // Update collateral funds to collateral requirement\n                escrow.emitCollateralEvent(\n                    EscrowType.Type.DatacapCollateral,\n                    datasets.getDatasetMetadataSubmitter(_datasetId),\n                    _datasetId,\n                    EscrowType.CollateralEvent.SyncCollateral\n                );\n\n                datasets.reportDatasetProofSubmitted(_datasetId);\n                emit DatasetsEvents.DatasetProofSubmitted(\n                    _datasetId,\n                    msg.sender\n                );\n            }\n        }\n    }\n\n    ///@notice Submit proof for a dataset\n    ///@dev Submit the proof of the dataset in batches,\n    /// specifically by submitting the _leafHashes in the order of _leafIndexes.\n    function submitDatasetProof(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        bytes32[] memory _leafHashes,\n        uint64 _leafIndex,\n        uint64[] memory _leafSizes,\n        bool _completed\n    ) external {\n        _submitDatasetProof(\n            _datasetId,\n            _dataType,\n            _leafHashes,\n            _leafIndex,\n            _leafSizes,\n            _completed\n        );\n\n        if (_completed) {\n            submitDatasetProofCompleted(_datasetId);\n        }\n    }\n\n    /// @notice Append dataset collateral funds\n    function appendDatasetCollateral(uint64 _datasetId) public payable {\n        uint256 amount = msg.value;\n        uint256 appendCollateral = getDatasetAppendCollateral(_datasetId);\n        emit DatasetsEvents.LogMessage(\n            msg.sender,\n            \"Insufficient funds\",\n            amount,\n            appendCollateral\n        );\n\n        if (amount < appendCollateral) {\n            revert Errors.NotEnough(amount, appendCollateral);\n        }\n\n        require(amount >= appendCollateral, \"Insufficient collateral funds\");\n\n        escrow.collateral{value: amount}(\n            EscrowType.Type.DatacapCollateral,\n            datasets.getDatasetMetadataSubmitter(_datasetId),\n            _datasetId,\n            appendCollateral\n        );\n\n        datasets.reportCollateralEnough(_datasetId);\n        emit DatasetsEvents.CollateralEnough(_datasetId, msg.sender);\n    }\n\n    /// @notice Get dataset need append collateral funds\n    function getDatasetAppendCollateral(\n        uint64 _datasetId\n    ) public view returns (uint256) {\n        uint256 collateralRequirement = getDatasetCollateralRequirement(\n            _datasetId\n        );\n        uint256 total = escrow.getOwnerTotal(\n            EscrowType.Type.DatacapCollateral,\n            datasets.getDatasetMetadataSubmitter(_datasetId),\n            _datasetId\n        );\n\n        uint256 appendCollateral = 0;\n        if (collateralRequirement > total) {\n            appendCollateral = collateralRequirement - total;\n        }\n\n        return appendCollateral;\n    }\n\n    ///@notice Get dataset source CIDs\n    function getDatasetProof(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) public view onlyNotZero(_datasetId) returns (bytes32[] memory) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return\n            carstore.getCarsHashs(\n                datasetProof.getDatasetProof(_dataType, _index, _len)\n            );\n    }\n\n    ///@notice Get dataset source CIDs\n    function getDatasetCars(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) public view onlyNotZero(_datasetId) returns (bytes32[] memory) {\n        return getDatasetProof(_datasetId, _dataType, _index, _len);\n    }\n\n    /// @notice Get the number of leaf nodes (cars) in the dataset proofs.\n    function getDatasetProofCount(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) public view onlyNotZero(_datasetId) returns (uint64) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return datasetProof.getDatasetCount(_dataType);\n    }\n\n    /// @notice Get submitter of dataset's proofs\n    function getDatasetProofSubmitter(\n        uint64 _datasetId\n    ) public view returns (address) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return datasetProof.getDatasetSubmitter();\n    }\n\n    ///@notice Get dataset source CIDs\n    function getDatasetCarsCount(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) public view onlyNotZero(_datasetId) returns (uint64) {\n        return getDatasetProofCount(_datasetId, _dataType);\n    }\n\n    ///@notice Get dataset size\n    function getDatasetSize(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) public view onlyNotZero(_datasetId) returns (uint64) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return datasetProof.getDatasetSize(_dataType);\n    }\n\n    ///@notice Get dataset minimum conditional\n    function getDatasetCollateralRequirement(\n        uint64 _datasetId\n    ) public view onlyNotZero(_datasetId) returns (uint256) {\n        // TODO: PRICE_PER_BYTE import from governance\n        uint64 PER_TIB_BYTE = (1024 * 1024 * 1024 * 1024);\n        uint256 PRICE_PER_BYTE = (1000000000000000000 / PER_TIB_BYTE);\n        return\n            getDatasetSize(_datasetId, DatasetType.DataType.Source) *\n            datasetsRequirement.getDatasetReplicasCount(_datasetId) *\n            PRICE_PER_BYTE;\n    }\n\n    ///@notice Check if a dataset proof all completed\n    function isDatasetProofallCompleted(\n        uint64 _datasetId,\n        DatasetType.DataType _dataType\n    ) public view onlyNotZero(_datasetId) returns (bool) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return datasetProof.isDatasetProofallCompleted(_dataType);\n    }\n\n    ///@notice Check if a dataset has a cid\n    function isDatasetContainsCar(\n        uint64 _datasetId,\n        uint64 _id\n    ) public view onlyNotZero(_datasetId) returns (bool) {\n        return _datasetId == carstore.getCarDatasetId(_id);\n    }\n\n    ///@notice Check if a dataset has cids\n    function isDatasetContainsCars(\n        uint64 _datasetId,\n        uint64[] memory _ids\n    ) external view onlyNotZero(_datasetId) returns (bool) {\n        for (uint64 i = 0; i < _ids.length; i++) {\n            if (!isDatasetContainsCar(_datasetId, _ids[i])) return false;\n        }\n        return true;\n    }\n\n    ///@notice Check if a dataset has submitter\n    function isDatasetProofSubmitter(\n        uint64 _datasetId,\n        address _submitter\n    ) public view returns (bool) {\n        DatasetType.DatasetProof storage datasetProof = datasetProofs[\n            _datasetId\n        ];\n        return datasetProof.isDatasetSubmitter(_submitter);\n    }\n}\n"
    },
    "src/v0.8/module/dataset/DatasetsRequirement.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IEscrow} from \"src/v0.8/interfaces/core/IEscrow.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\n///shared\nimport {DatasetsEvents} from \"src/v0.8/shared/events/DatasetsEvents.sol\";\nimport {DatasetsModifiers} from \"src/v0.8/shared/modifiers/DatasetsModifiers.sol\";\n/// library\nimport {DatasetReplicaRequirementLIB} from \"src/v0.8/module/dataset/library/requirement/DatasetReplicaRequirementLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title DatasetsRequirement Contract\n/// @notice This contract serves as the base for managing datasetsReplicasRequirmentd.\n/// @dev This contract is intended to be inherited by specific dataset-related contracts.\ncontract DatasetsRequirement is\n    Initializable,\n    UUPSUpgradeable,\n    IDatasetsRequirement,\n    DatasetsModifiers\n{\n    using DatasetReplicaRequirementLIB for DatasetType.DatasetReplicasRequirement;\n\n    mapping(uint64 => DatasetType.DatasetReplicasRequirement)\n        private datasetReplicasRequirements; // Mapping of dataset ID to dataset details\n\n    address public governanceAddress;\n    IRoles public roles;\n    IFilplus private filplus;\n    IDatasets private datasets;\n\n    IEscrow public escrow;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _datasets,\n        address _escrow\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        escrow = IEscrow(_escrow);\n        filplus = IFilplus(_filplus);\n        datasets = IDatasets(_datasets);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    ///@notice Submit replica requirement for a dataset\n    ///        Note: submmiter of dataset can submit dataset replica requirement\n    /// @param _datasetId The ID of the dataset for which proof is submitted.\n    /// @param _dataPreparers The client specified data preparer, which the client can either specify or not, but the parameter cannot be empty.\n    /// @param _storageProviders The client specified storage provider, which the client can either specify or not, but the parameter cannot be empty.\n    /// @param _regions The region specified by the client, and the client must specify a region for the replicas.\n    /// @param _countrys The country specified by the client, and the client must specify a country for the replicas.\n    /// @param _citys The citys specified by the client, when the country of a replica is duplicated, citys must be specified and cannot be empty.\n    function submitDatasetReplicaRequirements(\n        uint64 _datasetId,\n        address[][] memory _dataPreparers,\n        address[][] memory _storageProviders,\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    )\n        external\n        payable\n        onlyDatasetState(datasets, _datasetId, DatasetType.State.None)\n        onlyAddress(datasets.getDatasetMetadataSubmitter(_datasetId))\n    {\n        uint256 preCollateral = getDatasetPreCollateralRequirements(_datasetId);\n        require(msg.value >= preCollateral, \"Insufficient collateral funds\");\n\n        escrow.collateral{value: msg.value}(\n            EscrowType.Type.DatacapCollateral,\n            msg.sender,\n            _datasetId,\n            preCollateral\n        );\n\n        require(\n            filplus.isCompliantRuleTotalReplicasPerDataset(\n                _dataPreparers,\n                _storageProviders,\n                _regions,\n                _countrys,\n                _citys\n            ),\n            \"Invalid replicas count\"\n        );\n\n        require(\n            filplus.isCompliantRuleGeolocation(_regions, _countrys, _citys),\n            \"Invalid region distribution\"\n        );\n\n        DatasetType.DatasetReplicasRequirement\n            storage datasetReplicasRequirement = datasetReplicasRequirements[\n                _datasetId\n            ];\n\n        require(\n            datasets.requireValidDatasetMetadata(_datasetId),\n            \"Invalid Metadata\"\n        );\n\n        datasetReplicasRequirement.submitDatasetRequirements(\n            _dataPreparers,\n            _storageProviders,\n            _regions,\n            _countrys,\n            _citys\n        );\n\n        datasets.reportDatasetReplicaRequirementSubmitted(_datasetId);\n        emit DatasetsEvents.DatasetReplicaRequirementSubmitted(\n            _datasetId,\n            msg.sender\n        );\n    }\n\n    ///@notice Get dataset replicas count\n    function getDatasetReplicasCount(\n        uint64 _datasetId\n    ) public view onlyNotZero(_datasetId) returns (uint16) {\n        DatasetType.DatasetReplicasRequirement\n            storage datasetReplicasRequirement = datasetReplicasRequirements[\n                _datasetId\n            ];\n        return datasetReplicasRequirement.getDatasetReplicasCount();\n    }\n\n    ///@notice Get dataset replica requirement\n    function getDatasetReplicaRequirement(\n        uint64 _datasetId,\n        uint64 _index\n    )\n        public\n        view\n        onlyNotZero(_datasetId)\n        returns (\n            address[] memory,\n            address[] memory,\n            uint16,\n            uint16,\n            uint32[] memory\n        )\n    {\n        DatasetType.DatasetReplicasRequirement\n            storage datasetReplicasRequirement = datasetReplicasRequirements[\n                _datasetId\n            ];\n        return datasetReplicasRequirement.getDatasetReplicaRequirement(_index);\n    }\n\n    ///@notice Get dataset pre conditional\n    function getDatasetPreCollateralRequirements(\n        uint64 _datasetId\n    ) public view onlyNotZero(_datasetId) returns (uint256) {\n        (, , , , , , , , uint64 size, , ) = datasets.getDatasetMetadata(\n            _datasetId\n        );\n        // TODO: PRICE_PER_BYTE import from governance\n        uint64 PER_TIB_BYTE = (1024 * 1024 * 1024 * 1024);\n        uint256 PRICE_PER_BYTE = (1000000000000000000 / PER_TIB_BYTE);\n        return size * getDatasetReplicasCount(_datasetId) * PRICE_PER_BYTE;\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/challenge/DatasetChallengeLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\n\nlibrary DatasetChallengeLIB {\n    function setChallengeProof(\n        DatasetType.Challenge memory self,\n        bytes32 _leaf,\n        bytes32[] memory _siblings,\n        uint32 _path\n    ) internal pure {\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            self.siblings[i] = _siblings[i];\n        }\n        self.leaf = _leaf;\n        self.path = _path;\n    }\n\n    function getChallengeProof(\n        DatasetType.Challenge storage self\n    )\n        internal\n        view\n        returns (bytes32 _leaf, bytes32[] memory _siblings, uint32 _path)\n    {\n        bytes32[] memory result = new bytes32[](self.siblings.length);\n        bytes32 leaf;\n        uint32 path;\n        for (uint256 i = 0; i < self.siblings.length; i++) {\n            result[i] = self.siblings[i];\n        }\n        leaf = self.leaf;\n        path = self.path;\n        return (leaf, result, path);\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/challenge/DatasetChallengeProofLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\nimport {DatasetProofLIB} from \"src/v0.8/module/dataset/library/proof/DatasetProofLIB.sol\";\nimport {DatasetChallengeLIB} from \"src/v0.8/module/dataset/library/challenge/DatasetChallengeLIB.sol\";\n\n/// @title DatasetVerificationLIB Library,include add,get,verify.\n/// @notice This library provides functions for managing verification associated with datasets.\n/// @dev Note:Need to check carefully,Need rewrite verification logic.\nlibrary DatasetChallengeProofLIB {\n    using DatasetProofLIB for DatasetType.DatasetProof;\n    using DatasetChallengeLIB for DatasetType.Challenge;\n\n    /// @notice Submit a challenge proofs for a dataset.\n    /// @dev This function allows submitting a challenge proofs for a dataset and triggers appropriate actions based on challenge results.\n    /// @param self The dataset to which the challenge proofs will be submitted.\n    function _submitDatasetChallengeProofs(\n        DatasetType.DatasetChallengeProof storage self,\n        uint64 _randomSeed,\n        bytes32[] memory _leaves,\n        bytes32[][] memory _siblings,\n        uint32[] memory _paths,\n        bytes32[] memory _roots,\n        IMerkleUtils _merkle\n    ) internal returns (bool) {\n        //For each challenge proofs submitted by an auditor, the random seed must be different.\n        require(\n            !isDatasetChallengeProofDuplicate(self, msg.sender, _randomSeed),\n            \"Verification is duplicate\"\n        );\n        require(_randomSeed > 0, \"Invalid random seed\");\n\n        if (\n            !_requireValidChallengeProofs(\n                _leaves,\n                _siblings,\n                _paths,\n                _roots,\n                _merkle\n            )\n        ) {\n            return false;\n        }\n\n        // Update the dataset state here\n        self.challengesCount++;\n        DatasetType.ChallengeProof storage challengeProof = self\n            .challengeProofs[msg.sender];\n        for (uint32 i = 0; i < _paths.length; i++) {\n            DatasetType.Challenge memory challenge;\n            challenge.siblings = new bytes32[](_siblings[i].length);\n            challenge.setChallengeProof(_leaves[i], _siblings[i], _paths[i]);\n            challengeProof.challenges.push(challenge);\n        }\n        // Recording the auditor\n        self.auditors.push(msg.sender);\n\n        return true;\n    }\n\n    /// @notice Validates the submitted challenge proofs.\n    /// @dev This function checks the validity of the submitted Merkle proofs for both the source dataset and mapping files.\n    // solhint-disable-next-line\n    function _requireValidChallengeProofs(\n        bytes32[] memory _leaves,\n        bytes32[][] memory _siblings,\n        uint32[] memory _paths,\n        bytes32[] memory roots,\n        IMerkleUtils _merkle\n    ) private view returns (bool) {\n        require(\n            roots.length == _leaves.length,\n            \"roots.length != _leaves.length\"\n        );\n        require(\n            roots.length == _siblings.length,\n            \"roots.length != _siblings.length\"\n        );\n        require(roots.length == _paths.length, \"roots.length != _paths.length\");\n\n        for (uint32 i = 0; i < roots.length; i++) {\n            if (\n                !_merkle.isValidMerkleProof(\n                    roots[i],\n                    _leaves[i],\n                    _siblings[i],\n                    _paths[i]\n                )\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Get the challenge proofs details for a specific index of a dataset.\n    /// @dev This function returns the challenge proofs details for a specific challenge proofs conducted on the dataset.\n    /// @param self The dataset for which to retrieve challenge proofs details.\n    /// @param _auditor address of the auditor.\n    function getDatasetChallengeProofs(\n        DatasetType.DatasetChallengeProof storage self,\n        address _auditor\n    )\n        internal\n        view\n        returns (bytes32[] memory, bytes32[][] memory, uint32[] memory)\n    {\n        DatasetType.ChallengeProof storage challengeProof = self\n            .challengeProofs[_auditor];\n        bytes32[][] memory siblingss = new bytes32[][](\n            challengeProof.challenges.length\n        );\n        uint32[] memory paths = new uint32[](challengeProof.challenges.length);\n        bytes32[] memory leaves = new bytes32[](\n            challengeProof.challenges.length\n        );\n\n        for (uint256 i = 0; i < challengeProof.challenges.length; i++) {\n            DatasetType.Challenge storage challenge = challengeProof.challenges[\n                i\n            ];\n            (bytes32 leaf, bytes32[] memory siblings, uint32 path) = challenge\n                .getChallengeProof();\n            leaves[i] = leaf;\n            siblingss[i] = siblings;\n            paths[i] = path;\n        }\n        return (leaves, siblingss, paths);\n    }\n\n    /// @notice Get the count of challenge proofs for a dataset.\n    /// @dev This function returns the count of challenge proofs conducted on the dataset.\n    /// @param self The dataset for which to retrieve the challenge proofs count.\n    function getDatasetChallengeProofsCount(\n        DatasetType.DatasetChallengeProof storage self\n    ) internal view returns (uint16) {\n        return self.challengesCount;\n    }\n\n    /// @notice Check if the challange proof is a duplicate.\n    /// @param self The dataset for which to retrieve challenge proof details.\n    /// @param _auditor The address of the auditor submitting the challenge proof.\n    /// @param _randomSeed The random value used for selecting the challenge point.\n    function isDatasetChallengeProofDuplicate(\n        DatasetType.DatasetChallengeProof storage self,\n        address _auditor,\n        uint64 _randomSeed\n    ) internal view returns (bool) {\n        for (uint32 i = 0; i < self.auditors.length; i++) {\n            if (self.auditors[i] == _auditor) return true;\n            DatasetType.ChallengeProof storage verification = self\n                .challengeProofs[_auditor];\n            if (verification.randomSeed == _randomSeed) return true;\n        }\n        return false;\n    }\n\n    /// @notice generate a car challenge index.\n    /// @dev This function returns a car Challenge information for a specific dataset.\n    /// @param _randomSeed The cars challenge random seed.\n    /// @param _index The car index of challenge.\n    /// @param _carChallengesCount the cars Challenge count for specific dataset.\n    function generateChallengeIndex(\n        uint64 _randomSeed,\n        uint64 _index,\n        uint64 _carChallengesCount\n    ) internal pure returns (uint64) {\n        // Convert randomness and index to bytes\n        bytes memory input = new bytes(16);\n\n        bytes8 randomSeedBytes = bytes8(_randomSeed);\n        bytes8 indexBytes = bytes8(_index);\n\n        // LittleEndian encode\n        for (uint256 i = 0; i < 8; i++) {\n            input[i] = randomSeedBytes[7 - i];\n            input[i + 8] = indexBytes[7 - i];\n        }\n        // Calculate SHA-256 hash\n        bytes32 hash = sha256(input);\n\n        uint64 carChallenge;\n        // from golang binary.LittleEndian.Uint64\n        for (uint256 i = 0; i < 8; i++) {\n            carChallenge |= uint64(uint8(hash[i])) << uint64(i * 8);\n        }\n\n        return carChallenge % _carChallengesCount;\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/metadata/DatasetAuditLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {DatasetStateMachineLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetStateMachineLIB.sol\";\n\n/// @title Dataset Library\n/// @notice This library provides functions to manage datasets and their metadata, proofs, and verifications.\n/// @dev This library is intended to be used in conjunction with the Dataset contract.\n///       Note: only called by governance contract\nlibrary DatasetAuditLIB {\n    using DatasetStateMachineLIB for DatasetType.Dataset;\n\n    /// @notice Approve the metadata of a dataset.\n    /// @dev This function changes the state of the dataset to MetadataApproved and emits the MetadataApproved event.\n    /// @param self The dataset for which metadata is being approved.\n    function approveDatasetMetadata(DatasetType.Dataset storage self) internal {\n        require(\n            self.state == DatasetType.State.MetadataSubmitted,\n            \"Invalid state\"\n        );\n        self._emitDatasetEvent(DatasetType.Event.MetadataApproved);\n    }\n\n    /// @notice Reject the metadata of a dataset.\n    /// @dev This function changes the state of the dataset to MetadataRejected and emits the MetadataRejected event.\n    /// @param self The dataset for which metadata is being rejected.\n    function rejectDatasetMetadata(DatasetType.Dataset storage self) internal {\n        require(\n            self.state == DatasetType.State.MetadataSubmitted,\n            \"Invalid state\"\n        );\n        self._emitDatasetEvent(DatasetType.Event.MetadataRejected);\n    }\n\n    /// @notice Approve a dataset.\n    /// @dev This function changes the state of the dataset to DatasetApproved and emits the DatasetApproved event.\n    /// @param self The dataset to be approved.\n    function approveDataset(DatasetType.Dataset storage self) internal {\n        require(\n            self.state == DatasetType.State.DatasetProofSubmitted,\n            \"Invalid state\"\n        );\n        self._emitDatasetEvent(DatasetType.Event.DatasetApproved);\n    }\n\n    /// @notice Reject a dataset.\n    /// @dev This function changes the state of the dataset to MetadataApproved and emits the DatasetRejected event.\n    /// @param self The dataset to be rejected.\n    function rejectDataset(DatasetType.Dataset storage self) internal {\n        require(\n            self.state == DatasetType.State.DatasetProofSubmitted,\n            \"Invalid state\"\n        );\n        self._emitDatasetEvent(DatasetType.Event.DatasetRejected);\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/metadata/DatasetMetadataLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {DatasetStateMachineLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetStateMachineLIB.sol\";\n\n/// @title DatasetMetadataLIB Library,,include add,get,verify.\n/// @notice This library provides functions for managing metadata of datasets.\nlibrary DatasetMetadataLIB {\n    using DatasetStateMachineLIB for DatasetType.Dataset;\n\n    /// @notice Checks if metadata fields are valid.\n    /// @param _title Title of the dataset.\n    /// @param _industry Industry category of the dataset.\n    /// @param _name Name of the dataset.\n    /// @param _description Description of the dataset.\n    /// @param _source Source of the dataset.\n    /// @param _accessMethod Method of accessing the dataset (e.g., URL, API).\n    /// @param _sizeInBytes Size of the dataset in bytes.\n    function _requireValidDatasetMetadata(\n        string memory _title,\n        string memory _industry,\n        string memory _name,\n        string memory _description,\n        string memory _source,\n        string memory _accessMethod,\n        uint256 _sizeInBytes\n    ) private pure {\n        require(\n            bytes(_title).length > 0 &&\n                bytes(_industry).length > 0 &&\n                bytes(_name).length > 0 &&\n                bytes(_description).length > 0 &&\n                bytes(_source).length > 0 &&\n                bytes(_accessMethod).length > 0 &&\n                _sizeInBytes > 0,\n            \"all params must be non-empty\"\n        );\n    }\n\n    /// @notice Checks if metadata fields are valid.\n    /// @param self The metadata object to store the metadata details.\n    function requireValidDatasetMetadata(\n        DatasetType.Dataset storage self\n    ) internal view {\n        _requireValidDatasetMetadata(\n            self.metadata.title,\n            self.metadata.industry,\n            self.metadata.name,\n            self.metadata.description,\n            self.metadata.source,\n            self.metadata.accessMethod,\n            self.metadata.sizeInBytes\n        );\n    }\n\n    /// @notice Submits metadata for a dataset.\n    /// @dev This function allows submitting metadata for a dataset if it hasn't been submitted before.\n    /// @param self The metadata object to store the metadata details.\n    /// @param _title Title of the dataset.\n    /// @param _industry Industry category of the dataset.\n    /// @param _name Name of the dataset.\n    /// @param _description Description of the dataset.\n    /// @param _source Source of the dataset.\n    /// @param _accessMethod Method of accessing the dataset (e.g., URL, API).\n    /// @param _sizeInBytes Size of the dataset in bytes.\n    /// @param _isPublic Boolean indicating if the dataset is public.\n    /// @param _version Version number of the dataset.\n    function submitDatasetMetadata(\n        DatasetType.Dataset storage self,\n        uint64 _client,\n        string memory _title,\n        string memory _industry,\n        string memory _name,\n        string memory _description,\n        string memory _source,\n        string memory _accessMethod,\n        uint64 _sizeInBytes,\n        bool _isPublic,\n        uint64 _version\n    ) internal {\n        _requireValidDatasetMetadata(\n            _title,\n            _industry,\n            _name,\n            _description,\n            _source,\n            _accessMethod,\n            _sizeInBytes\n        );\n\n        self.metadata.title = _title;\n        self.metadata.industry = _industry;\n        self.metadata.name = _name;\n        self.metadata.description = _description;\n        self.metadata.source = _source;\n        self.metadata.accessMethod = _accessMethod;\n        self.metadata.submitter = msg.sender;\n        self.metadata.client = _client;\n        self.metadata.createdBlockNumber = uint64(block.number);\n        self.metadata.sizeInBytes = _sizeInBytes;\n        self.metadata.isPublic = _isPublic;\n        self.metadata.version = _version;\n    }\n\n    /// @notice Gets the submitter  for a dataset.\n    /// @dev This function requires that metadata has been submitted before.\n    /// @param self The metadata object to retrieve the metadata details from.\n    function getDatasetMetadataSubmitter(\n        DatasetType.Dataset storage self\n    ) internal view returns (address submitter) {\n        require(\n            bytes(self.metadata.title).length > 0,\n            \"Metadata does not exist\"\n        );\n\n        return (self.metadata.submitter);\n    }\n\n    /// @notice Gets the client  for a dataset.\n    /// @dev This function requires that metadata has been submitted before.\n    /// @param self The metadata object to retrieve the metadata details from.\n    function getDatasetMetadataClient(\n        DatasetType.Dataset storage self\n    ) internal view returns (uint64 client) {\n        require(\n            bytes(self.metadata.title).length > 0,\n            \"Metadata does not exist\"\n        );\n\n        return (self.metadata.client);\n    }\n\n    /// @notice Checks if an access method for a dataset has been submitted.\n    /// @param self The metadata object to check.\n    /// @param _accessMethod The access method to check.\n    /// @return True if the access method exists, false otherwise.\n    function hasDatasetMetadata(\n        DatasetType.Dataset storage self,\n        string memory _accessMethod\n    ) internal view returns (bool) {\n        return\n            keccak256(bytes(self.metadata.accessMethod)) ==\n            keccak256(bytes(_accessMethod));\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/metadata/DatasetStateMachineLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\n\n/// @title DatasetStateMachineLIB Library,include add,get,verify.\n/// @notice This library defines the state machine for managing the states of datasets.\nlibrary DatasetStateMachineLIB {\n    /// @notice Post an event for a dataset.\n    /// @dev This function updates the dataset's state based on the event and emits the corresponding event.\n    /// @param self The dataset for which the event will be posted.\n    /// @param _event The event to be posted.\n    function _emitDatasetEvent(\n        DatasetType.Dataset storage self,\n        DatasetType.Event _event\n    ) internal {\n        DatasetType.State currentState = self.state;\n        DatasetType.State newState;\n        // Apply the state transition based on the event\n        if (_event == DatasetType.Event.SubmitMetadata) {\n            if (currentState == DatasetType.State.None) {\n                newState = DatasetType.State.MetadataSubmitted;\n            }\n        } else if (_event == DatasetType.Event.MetadataApproved) {\n            if (currentState == DatasetType.State.MetadataSubmitted) {\n                newState = DatasetType.State.MetadataApproved;\n            }\n        } else if (_event == DatasetType.Event.MetadataRejected) {\n            if (currentState == DatasetType.State.MetadataSubmitted) {\n                newState = DatasetType.State.MetadataRejected;\n            }\n        } else if (_event == DatasetType.Event.NotEnoughCollateral) {\n            if (currentState == DatasetType.State.MetadataApproved) {\n                newState = DatasetType.State.CollateralNotEnough;\n            }\n        } else if (_event == DatasetType.Event.EnoughCollateral) {\n            if (currentState == DatasetType.State.CollateralNotEnough) {\n                newState = DatasetType.State.MetadataApproved;\n            }\n        } else if (_event == DatasetType.Event.SubmitDatasetProof) {\n            if (currentState == DatasetType.State.MetadataApproved) {\n                newState = DatasetType.State.DatasetProofSubmitted;\n            }\n        } else if (_event == DatasetType.Event.DatasetApproved) {\n            if (currentState == DatasetType.State.DatasetProofSubmitted) {\n                newState = DatasetType.State.DatasetApproved;\n            }\n        } else if (_event == DatasetType.Event.DatasetRejected) {\n            if (currentState == DatasetType.State.DatasetProofSubmitted) {\n                newState = DatasetType.State.MetadataApproved;\n            }\n        }\n\n        // Update the state if newState is not None (i.e., a valid transition)\n        if (newState != DatasetType.State.None) {\n            self.state = newState;\n        }\n    }\n\n    /// @notice Get the state of a dataset.\n    /// @dev This function returns the current state of a dataset.\n    /// @param self The dataset for which to retrieve the state.\n    /// @return The current state of the dataset.\n    function getDatasetState(\n        DatasetType.Dataset storage self\n    ) internal view returns (DatasetType.State) {\n        return self.state;\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/proof/DatasetProofInnerLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {DatasetStateMachineLIB} from \"src/v0.8/module/dataset/library/metadata/DatasetStateMachineLIB.sol\";\n\nlibrary DatasetProofInnerLIB {\n    using DatasetStateMachineLIB for DatasetType.Dataset;\n\n    /// @notice Set the root hash of the data's Merkle tree for a dataset proof.\n    /// @dev This function allows setting the root hash of the Merkle tree associated with a dataset proof.\n    /// @param self The dataset proof to which the root hash will be set.\n    /// @param _rootHash The root hash of the data's Merkle tree.\n    function setRootHash(\n        DatasetType.Proof storage self,\n        bytes32 _rootHash\n    ) internal {\n        self.rootHash = _rootHash;\n    }\n\n    /// @notice Get the root hash of the data's Merkle tree from a dataset proof.\n    /// @dev This function allows getting the root hash of the Merkle tree associated with a dataset proof.\n    /// @param self The dataset proof from which the root hash will be retrieved.\n    /// @return The root hash of the data's Merkle tree.\n    function getRootHash(\n        DatasetType.Proof storage self\n    ) internal view returns (bytes32) {\n        return self.rootHash;\n    }\n\n    /// @notice Set the completion status for all proof batches in a dataset proof.\n    /// @dev This function allows setting the completion status for all proof batches in a dataset proof.\n    /// @param self The dataset proof for which the completion status will be set.\n    /// @param _completed The completion status to be set.\n    function setAllCompleted(\n        DatasetType.Proof storage self,\n        bool _completed\n    ) internal {\n        self.allCompleted = _completed;\n    }\n\n    /// @notice Get the completion status for all proof batches in a dataset proof.\n    /// @dev This function allows getting the completion status for all proof batches in a dataset proof.\n    /// @param self The dataset proof from which the completion status will be retrieved.\n    /// @return The completion status for all proof batches.\n    function getAllCompleted(\n        DatasetType.Proof storage self\n    ) internal view returns (bool) {\n        return self.allCompleted;\n    }\n\n    /// @notice Set a specific proof batch for a dataset proof.\n    /// @dev This function allows setting a specific proof batch in a dataset proof.\n    /// @param self The dataset proof to which the proof batch will be added.\n    /// @param _leafHashes Array of leaf hashes representing items in the data.\n    /// @param _leafIndex The sizes of the leaf hashes.\n    function addProofBatch(\n        DatasetType.Proof storage self,\n        uint64[] memory _leafHashes,\n        uint64 _leafIndex\n    ) internal {\n        uint64 index = _leafIndex;\n        for (uint64 i; i < _leafHashes.length; i++) {\n            require(index == self.leafHashesCount, \"index must match Count\");\n            index++;\n            self.leafHashesCount++;\n            self.leafHashes.push(_leafHashes[i]);\n        }\n    }\n\n    /// @notice Get a specific proof batch from a dataset proof.\n    /// @dev This function allows getting a specific proof batch from a dataset proof.\n    /// @param self The dataset proof from which the proof batch will be retrieved.\n    function getProof(\n        DatasetType.Proof storage self,\n        uint64 _index,\n        uint64 _len\n    ) internal view returns (uint64[] memory) {\n        require(\n            _index + _len <= self.leafHashes.length,\n            \"Index+len out of bounds\"\n        );\n        require(\n            self.leafHashesCount == self.leafHashes.length,\n            \"length must matched\"\n        );\n        uint64[] memory result = new uint64[](_len);\n        for (uint64 i = 0; i < _len; i++) {\n            result[i] = self.leafHashes[i + _index];\n        }\n        return result;\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/proof/DatasetProofLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {DatasetProofInnerLIB} from \"src/v0.8/module/dataset/library/proof/DatasetProofInnerLIB.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\n\n/// @title DatasetProofLIB Library,include add,get,verify.\n/// @notice This library provides functions for managing proofs associated with datasets.\nlibrary DatasetProofLIB {\n    using DatasetProofInnerLIB for DatasetType.Proof;\n\n    /// @notice Submit a proof root for a dataset.\n    /// @dev This function allows submitting a proof root for a dataset and emits the SubmitDatasetProof event.\n    /// @param self The dataset to which the proof will be submitted.\n    /// @param _dataType The type of the dataset proof.\n    /// @param _rootHash The root hash of the dataset proofs.\n    function addDatasetProofRoot(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType,\n        bytes32 _rootHash\n    ) internal {\n        DatasetType.Proof storage proof;\n        if (_dataType == DatasetType.DataType.Source) {\n            proof = self.sourceProof;\n        } else {\n            proof = self.mappingFilesProof;\n        }\n        if (proof.leafHashesCount == 0) {\n            require(_rootHash.length == 32, \"length must matched\");\n            proof.rootHash = _rootHash;\n        }\n    }\n\n    /// @notice Submit a proof for a dataset.\n    /// @dev This function allows submitting a proof for a dataset and emits the SubmitDatasetProof event.\n    /// @param self The dataset to which the proof will be submitted.\n    /// @param _dataType The type of the dataset proof.\n    /// @param _leafHashes The leaf hashes of the proof.\n    /// @param _leafIndex The sizes of the leaf hashes.\n    /// @param _size The total size of the leaf hashes.\n    /// @param _allCompleted A boolean indicating if the proof is completed.\n    function addDatasetProofBatch(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType,\n        uint64[] memory _leafHashes,\n        uint64 _leafIndex,\n        uint64 _size,\n        bool _allCompleted\n    ) internal {\n        DatasetType.Proof storage proof;\n        if (_dataType == DatasetType.DataType.Source) {\n            proof = self.sourceProof;\n        } else {\n            proof = self.mappingFilesProof;\n        }\n\n        if (proof.allCompleted == false && _allCompleted == true)\n            proof.allCompleted = _allCompleted;\n        proof.addProofBatch(_leafHashes, _leafIndex);\n\n        proof.datasetSize += _size;\n    }\n\n    /// @notice Get the source dataset proof from the submitted dataset proof.\n    /// @dev This function returns the root hash and array of leaf hashes of the Merkle proof for the source dataset.\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param _dataType The type of the dataset proof.\n    /// @param _index The starting index to get dataset proof..\n    /// @param _len The length to get dataset proof..\n    /// @return The car hashs of the dataset proof.\n    function getDatasetProof(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) internal view returns (uint64[] memory) {\n        DatasetType.Proof storage proof;\n        if (_dataType == DatasetType.DataType.Source) {\n            proof = self.sourceProof;\n        } else {\n            proof = self.mappingFilesProof;\n        }\n        return proof.getProof(_index, _len);\n    }\n\n    /// @notice Get the source dataset proof from the submitted dataset proof.\n    /// @dev This function returns the root hash and array of leaf hashes of the Merkle proof for the source dataset.\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param _dataType The type of the dataset proof.\n    /// @param _index The starting index to get dataset proof..\n    /// @param _len The length to get dataset proof..\n    /// @return The car hashs of the dataset proof.\n    function getDatasetCars(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType,\n        uint64 _index,\n        uint64 _len\n    ) internal view returns (uint64[] memory) {\n        uint64[] memory hashes = getDatasetProof(self, _dataType, _index, _len);\n        //TODO: hashes to cid\n        return hashes;\n    }\n\n    /// @notice Get the source dataset proof from the submitted dataset proof.\n    /// @dev This function returns the root hash and array of leaf hashes of the Merkle proof for the source dataset.\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param _dataType The type of the dataset proof.\n    /// @return The count of the hashs of dataset proof.\n    function getDatasetCount(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType\n    ) internal view returns (uint64) {\n        DatasetType.Proof storage proof;\n        if (_dataType == DatasetType.DataType.Source) {\n            proof = self.sourceProof;\n        } else {\n            proof = self.mappingFilesProof;\n        }\n        return proof.leafHashesCount;\n    }\n\n    /// @notice Get the source dataset proof from the submitted dataset proof.\n    /// @dev This function returns the root hash and array of leaf hashes of the Merkle proof for the source dataset.\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param _dataType The type of the dataset proof.\n    function getDatasetSize(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType\n    ) internal view returns (uint64) {\n        DatasetType.Proof storage proof;\n        if (_dataType == DatasetType.DataType.Source) {\n            proof = self.sourceProof;\n        } else {\n            proof = self.mappingFilesProof;\n        }\n        return proof.datasetSize;\n    }\n\n    /// @notice Get submitter of dataset's proofs.\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @return The address of submitter\n    function getDatasetSubmitter(\n        DatasetType.DatasetProof storage self\n    ) internal view returns (address) {\n        return self.proofSubmitter;\n    }\n\n    /// @notice Check if a dataset has submitter\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param submitter The address being compared.\n    function isDatasetSubmitter(\n        DatasetType.DatasetProof storage self,\n        address submitter\n    ) internal view returns (bool) {\n        if (submitter == self.proofSubmitter) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Check if a dataset proof has completed\n    /// @param self The dataset from which to retrieve the source dataset proof.\n    /// @param _dataType The type of the dataset proof.\n    function isDatasetProofallCompleted(\n        DatasetType.DatasetProof storage self,\n        DatasetType.DataType _dataType\n    ) internal view returns (bool) {\n        if (_dataType == DatasetType.DataType.Source) {\n            return self.sourceProof.allCompleted;\n        } else {\n            return self.mappingFilesProof.allCompleted;\n        }\n    }\n}\n"
    },
    "src/v0.8/module/dataset/library/requirement/DatasetReplicaRequirementLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\n/// @title DatasetReplicaRequirementLIB Library,include add,get,verify.\n/// @notice This library provides functions for storage replica requirement of datasets.\nlibrary DatasetReplicaRequirementLIB {\n    /// @notice Submits replica requirement for a dataset.\n    /// @dev This function allows submitting replica requirement for a dataset.\n    function submitDatasetRequirements(\n        DatasetType.DatasetReplicasRequirement storage self,\n        address[][] memory _dataPreparers,\n        address[][] memory _storageProviders,\n        uint16[] memory _regions,\n        uint16[] memory _countrys,\n        uint32[][] memory _citys\n    ) internal {\n        for (uint32 i = 0; i < _regions.length; i++) {\n            self.replicasRequirement.push(\n                DatasetType.ReplicaRequirement(\n                    _dataPreparers[i],\n                    _storageProviders[i],\n                    GeolocationType.Geolocation(\n                        _regions[i],\n                        _countrys[i],\n                        _citys[i]\n                    )\n                )\n            );\n        }\n    }\n\n    ///@notice Get dataset replica requirement info\n    function getDatasetReplicaRequirement(\n        DatasetType.DatasetReplicasRequirement storage self,\n        uint64 _index\n    )\n        internal\n        view\n        returns (\n            address[] memory,\n            address[] memory,\n            uint16,\n            uint16,\n            uint32[] memory\n        )\n    {\n        require(_index < self.replicasRequirement.length, \"Invalid index\");\n        return (\n            self.replicasRequirement[_index].dataPreparers,\n            self.replicasRequirement[_index].storageProviders,\n            self.replicasRequirement[_index].geolocations.regionCode,\n            self.replicasRequirement[_index].geolocations.countryCode,\n            self.replicasRequirement[_index].geolocations.cityCodes\n        );\n    }\n\n    ///@notice Get dataset replica's count\n    function getDatasetReplicasCount(\n        DatasetType.DatasetReplicasRequirement storage self\n    ) internal view returns (uint16) {\n        return (uint16(self.replicasRequirement.length));\n    }\n}\n"
    },
    "src/v0.8/module/matching/library/MatchingBidsLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\nimport {MatchingStateMachineLIB} from \"src/v0.8/module/matching/library/MatchingStateMachineLIB.sol\";\n\n/// @title Matching Bids Library\n/// @notice This library provides functions for managing bids in matchings.\nlibrary MatchingBidsLIB {\n    using MatchingStateMachineLIB for MatchingType.Matching;\n\n    /// @notice Add a bid to the matching.\n    /// @dev This function adds a bid to the matching and updates the bids count.\n    /// @param self The bids in the matching.\n    /// @param _amount The bid amount.\n    function _matchingBidding(\n        MatchingType.MatchingBids storage self,\n        MatchingType.BidSelectionRule _bidSelectionRule,\n        uint256 _biddingThreshold,\n        uint64 _biddingAfterPauseHeight,\n        uint64 _biddingEndHeight,\n        uint256 _amount\n    ) internal {\n        if (\n            _bidSelectionRule == MatchingType.BidSelectionRule.HighestBid ||\n            _bidSelectionRule == MatchingType.BidSelectionRule.ImmediateAtLeast\n        ) {\n            require(_amount >= _biddingThreshold, \"Invalid amount\");\n        }\n        if (\n            _bidSelectionRule == MatchingType.BidSelectionRule.LowestBid ||\n            _bidSelectionRule == MatchingType.BidSelectionRule.ImmediateAtMost\n        ) {\n            require(_amount <= _biddingThreshold, \"Invalid amount\");\n        }\n        require(\n            block.number >= _biddingAfterPauseHeight,\n            \"Matching: Bidding is not start\"\n        );\n        require(block.number < _biddingEndHeight, \"Matching: Bidding is end\");\n        if (_hasMatchingBid(self, msg.sender)) {\n            if (_bidSelectionRule == MatchingType.BidSelectionRule.HighestBid) {\n                require(\n                    _amount > _getMatchingBidAmount(self, msg.sender),\n                    \"Invalid amount\"\n                );\n            }\n            if (_bidSelectionRule == MatchingType.BidSelectionRule.LowestBid) {\n                require(\n                    _amount < _getMatchingBidAmount(self, msg.sender),\n                    \"Invalid amount\"\n                );\n            }\n        }\n\n        MatchingType.Bid memory _bid = MatchingType.Bid(\n            msg.sender,\n            _amount,\n            true\n        );\n        self.bids.push(_bid);\n    }\n\n    /// @notice justify is has a winner for a closed matching.\n    /// @dev This internal function is used to choose a winner for a closed matching based on the specified rule.\n    function _chooseMatchingWinner(\n        MatchingType.MatchingBids storage self,\n        MatchingType.BidSelectionRule _bidSelectionRule,\n        uint256 _biddingThreshold,\n        uint64 _biddingAfterPauseHeight,\n        uint64 _biddingEndHeight\n    ) internal view returns (address) {\n        if (\n            _bidSelectionRule ==\n            MatchingType.BidSelectionRule.ImmediateAtLeast ||\n            _bidSelectionRule == MatchingType.BidSelectionRule.ImmediateAtMost\n        ) {\n            require(\n                block.number >= _biddingAfterPauseHeight,\n                \"Bidding too early\"\n            );\n        } else {\n            require(\n                block.number >= _biddingEndHeight,\n                \"Bidding period has not ended yet\"\n            );\n        }\n\n        uint256 winningBid = _biddingThreshold;\n        address winner = address(0);\n        for (uint64 i = 0; i < self.bids.length; i++) {\n            if (\n                _bidSelectionRule == MatchingType.BidSelectionRule.HighestBid ||\n                _bidSelectionRule ==\n                MatchingType.BidSelectionRule.ImmediateAtLeast\n            ) {\n                if (\n                    self.bids[i].bid > winningBid &&\n                    self.bids[i].complyFilplusRule\n                ) {\n                    winningBid = self.bids[i].bid;\n                    winner = self.bids[i].bidder;\n                }\n            } else if (\n                _bidSelectionRule == MatchingType.BidSelectionRule.LowestBid ||\n                _bidSelectionRule ==\n                MatchingType.BidSelectionRule.ImmediateAtMost\n            ) {\n                if (\n                    self.bids[i].bid < winningBid &&\n                    self.bids[i].complyFilplusRule\n                ) {\n                    winningBid = self.bids[i].bid;\n                    winner = self.bids[i].bidder;\n                }\n            }\n        }\n\n        return winner;\n    }\n\n    /// @notice Set the bidder not comply fileplus in the matching.\n    /// @dev This function set the comply fileplus to false of a bidder.\n    /// @param self The bids in the matching.\n    /// @param _bidder The address of the bidder.\n    function _setMatchingBidderNotComplyFilplusRule(\n        MatchingType.MatchingBids storage self,\n        address _bidder\n    ) internal {\n        for (uint64 i = uint64(self.bids.length - 1); i >= 0; i--) {\n            if (_bidder == self.bids[i].bidder) {\n                self.bids[i].complyFilplusRule = false;\n            }\n        }\n    }\n\n    /// @notice Get the bid amount of a bidder in the matching.\n    /// @dev This function retrieves the bid amount of a bidder.\n    /// @param self The bids in the matching.\n    /// @param _bidder The address of the bidder.\n    /// @return The bid amount.\n    function _getMatchingBidAmount(\n        MatchingType.MatchingBids storage self,\n        address _bidder\n    ) internal view returns (uint256) {\n        for (uint64 i = uint64(self.bids.length - 1); i >= 0; i--) {\n            if (_bidder == self.bids[i].bidder) {\n                return self.bids[i].bid;\n            }\n        }\n        return 0;\n    }\n\n    /// @notice Get the bids.\n    function _getMatchingBids(\n        MatchingType.MatchingBids storage self\n    ) internal view returns (address[] memory, uint256[] memory) {\n        address[] memory bidders = new address[](self.bids.length);\n        uint256[] memory amounts = new uint256[](self.bids.length);\n        for (uint64 i = 0; i < self.bids.length; i++) {\n            bidders[i] = self.bids[i].bidder;\n            amounts[i] = self.bids[i].bid;\n        }\n        return (bidders, amounts);\n    }\n\n    /// @notice Get the total number of bids in the matching.\n    /// @dev This function retrieves the total number of bids in the matching.\n    /// @param self The bids in the matching.\n    /// @return The total number of bids.\n    function _getMatchingBidsCount(\n        MatchingType.MatchingBids storage self\n    ) internal view returns (uint64) {\n        return uint64(self.bids.length);\n    }\n\n    /// @notice Check if a bidder has placed a bid in the matching.\n    /// @dev This function checks if a bidder has placed a bid.\n    /// @param self The bids in the matching.\n    /// @param _bidder The address of the bidder.\n    /// @return True if the bidder has placed a bid, otherwise false.\n    function _hasMatchingBid(\n        MatchingType.MatchingBids storage self,\n        address _bidder\n    ) internal view returns (bool) {\n        for (uint64 i = 0; i < self.bids.length; i++) {\n            if (_bidder == self.bids[i].bidder) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/v0.8/module/matching/library/MatchingLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\nimport {MatchingStateMachineLIB} from \"src/v0.8/module/matching/library/MatchingStateMachineLIB.sol\";\n\n/// @title Matching Library\n/// @notice This library provides functions for managing matchings and their states.\n/// @dev This library is used to manage the lifecycle and states of matchings.\nlibrary MatchingLIB {\n    using MatchingStateMachineLIB for MatchingType.Matching;\n\n    /// @notice Publish a matching.\n    /// @dev This function is used to publish a matching and initiate the matching process.\n    function _publishMatching(MatchingType.Matching storage self) internal {\n        require(self.state == MatchingType.State.None, \"Invalid state\");\n        self._emitMatchingEvent(MatchingType.Event.Publish);\n        //NOTE:consider that if need audit,so keep the FilPlusCheckSuccessed here.\n        self._emitMatchingEvent(MatchingType.Event.FilPlusCheckSuccessed);\n    }\n\n    /// @notice Pause a matching.\n    /// @dev This function is used to pause a matching that is in progress.\n    function _pauseMatching(MatchingType.Matching storage self) internal {\n        require(self.state == MatchingType.State.InProgress, \"Invalid state\");\n        require(self.pausedBlockCount == 0, \"only can paused one time\");\n        //@dev:NOTE: here set pausedBlockNumber as pausedBlockCount,will correct in resume\n        require(\n            uint64(block.number) <\n                self.createdBlockNumber + self.biddingDelayBlockCount,\n            \"alreay bidding,can't pause.\"\n        );\n\n        self.pausedBlockCount = uint64(block.number);\n        self._emitMatchingEvent(MatchingType.Event.Pause);\n    }\n\n    /// @notice Report that a pause has expired.\n    /// @dev This function is used to report that a pause has expired for a paused matching.\n    function _reportMatchingPauseExpired(\n        MatchingType.Matching storage self\n    ) internal {\n        require(self.state == MatchingType.State.Paused, \"Invalid state\");\n        self._emitMatchingEvent(MatchingType.Event.PauseExpired);\n    }\n\n    /// @notice Resume a paused matching.\n    /// @dev This function is used to resume a paused matching.\n    function _resumeMatching(MatchingType.Matching storage self) internal {\n        require(self.state == MatchingType.State.Paused, \"Invalid state\");\n        require(self.pausedBlockCount != 0, \"only can paused one time\");\n        //@dev:NOTE: set pausedBlockCount  as the dealy block count because paused\n        self.pausedBlockCount = uint64(block.number) - self.pausedBlockCount;\n\n        self._emitMatchingEvent(MatchingType.Event.Resume);\n    }\n\n    /// @notice Cancel a matching.\n    /// @dev This function is used to cancel a matching that is published, in progress, or paused.\n    function _cancelMatching(MatchingType.Matching storage self) internal {\n        require(\n            self.state == MatchingType.State.Published ||\n                self.state == MatchingType.State.InProgress ||\n                self.state == MatchingType.State.Paused,\n            \"Invalid state\"\n        );\n        require(\n            uint64(block.number) <\n                self.createdBlockNumber + self.biddingDelayBlockCount,\n            \"bid alreay start,can't cancel\"\n        );\n        self._emitMatchingEvent(MatchingType.Event.Cancel);\n    }\n\n    /// @notice Close a matching and choose a winner.\n    /// @dev This function is used to close a matching and choose a winner based on the specified rule.\n    function _closeMatching(MatchingType.Matching storage self) internal {\n        require(self.state == MatchingType.State.InProgress, \"Invalid state\");\n        if (\n            self.bidSelectionRule ==\n            MatchingType.BidSelectionRule.ImmediateAtLeast ||\n            self.bidSelectionRule ==\n            MatchingType.BidSelectionRule.ImmediateAtMost\n        ) {\n            require(\n                block.number >=\n                    self.createdBlockNumber +\n                        self.biddingDelayBlockCount +\n                        self.pausedBlockCount,\n                \"Bidding too early\"\n            );\n        } else {\n            require(\n                block.number >=\n                    self.createdBlockNumber +\n                        self.biddingDelayBlockCount +\n                        self.biddingPeriodBlockCount +\n                        self.pausedBlockCount,\n                \"Bidding period not expired\"\n            );\n        }\n        self._emitMatchingEvent(MatchingType.Event.Close);\n    }\n\n    /// @notice Report a matching is completed with winner.\n    /// @dev This function is used to complete a matching.\n    function _reportMatchingHasWinner(\n        MatchingType.Matching storage self\n    ) internal {\n        require(self.state == MatchingType.State.Closed, \"Invalid state\");\n        self._emitMatchingEvent(MatchingType.Event.HasWinner);\n    }\n\n    /// @notice Report a matching is completed without winner.\n    /// @dev This function is used to complete a matching.\n    function _reportMatchingNoWinner(\n        MatchingType.Matching storage self\n    ) internal {\n        require(self.state == MatchingType.State.Closed, \"Invalid state\");\n        self._emitMatchingEvent(MatchingType.Event.NoWinner);\n    }\n}\n"
    },
    "src/v0.8/module/matching/library/MatchingStateMachineLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title Matching Library\n/// @notice This library provides functions for managing matchings and their states.\n/// @dev This library is used to manage the lifecycle and states of matchings.\nlibrary MatchingStateMachineLIB {\n    /// @notice Post an event to update the matching's state.\n    /// @dev This internal function is used to update the matching's state based on the event.\n    /// @param _event The event that triggers the state update.\n    function _emitMatchingEvent(\n        MatchingType.Matching storage self,\n        MatchingType.Event _event\n    ) internal {\n        MatchingType.State currentState = self.state;\n        MatchingType.State newState;\n\n        // Apply the state transition based on the event\n        if (_event == MatchingType.Event.Publish) {\n            if (currentState == MatchingType.State.None) {\n                newState = MatchingType.State.Published;\n            }\n        } else if (_event == MatchingType.Event.FilPlusCheckSuccessed) {\n            if (currentState == MatchingType.State.Published) {\n                newState = MatchingType.State.InProgress;\n            }\n        } else if (_event == MatchingType.Event.FilPlusCheckFailed) {\n            if (currentState == MatchingType.State.Published) {\n                newState = MatchingType.State.Failed;\n            }\n        } else if (_event == MatchingType.Event.Pause) {\n            if (currentState == MatchingType.State.InProgress) {\n                newState = MatchingType.State.Paused;\n            }\n        } else if (_event == MatchingType.Event.Resume) {\n            if (currentState == MatchingType.State.Paused) {\n                newState = MatchingType.State.InProgress;\n            }\n        } else if (_event == MatchingType.Event.PauseExpired) {\n            if (currentState == MatchingType.State.Paused) {\n                newState = MatchingType.State.Failed;\n            }\n        } else if (_event == MatchingType.Event.Cancel) {\n            if (\n                currentState == MatchingType.State.Published ||\n                currentState == MatchingType.State.Paused ||\n                currentState == MatchingType.State.InProgress\n            ) {\n                newState = MatchingType.State.Cancelled;\n            }\n        } else if (_event == MatchingType.Event.Close) {\n            if (currentState == MatchingType.State.InProgress) {\n                newState = MatchingType.State.Closed;\n            }\n        } else if (_event == MatchingType.Event.HasWinner) {\n            if (currentState == MatchingType.State.Closed) {\n                newState = MatchingType.State.Completed;\n            }\n        } else if (_event == MatchingType.Event.NoWinner) {\n            if (currentState == MatchingType.State.Closed) {\n                newState = MatchingType.State.Failed;\n            }\n        }\n\n        // Update the state if newState is not None (i.e., a valid transition)\n        if (newState != MatchingType.State.None) {\n            self.state = newState;\n        }\n    }\n\n    /// @notice Get the current state of a matching.\n    /// @dev This internal function is used to retrieve the current state of a matching.\n    function _getMatchingState(\n        MatchingType.Matching storage self\n    ) internal view returns (MatchingType.State) {\n        return self.state;\n    }\n}\n"
    },
    "src/v0.8/module/matching/library/MatchingTargetLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title Matching Target Library\n/// @notice This library provides functions for managing targets.\n/// @dev This library is used to manage the targets of matchings.\nlibrary MatchingTargetLIB {\n    /// @notice Get the cars of a matching.\n    /// @return cars An array of CIDs representing the cars in the matching.\n    function _getCars(\n        MatchingType.MatchingTarget storage self\n    ) internal view returns (uint64[] memory) {\n        return self.cars;\n    }\n\n    /// @notice Get datasetId of matching.\n    /// @dev This function is used to get dataset id of matching.\n    function _getDatasetId(\n        MatchingType.MatchingTarget storage self\n    ) internal view returns (uint64) {\n        return self.datasetId;\n    }\n\n    /// @notice Get replica index of matching.\n    /// @dev This function is used to get dataset's replica index of matching.\n    function _getDatasetReplicaIndex(\n        MatchingType.MatchingTarget storage self\n    ) internal view returns (uint64) {\n        return self.replicaIndex;\n    }\n\n    /// @notice Push a car to matching.\n    /// @dev This function is used to push a car to target of matching.\n    function _pushCar(\n        MatchingType.MatchingTarget storage self,\n        uint64 _car\n    ) internal {\n        self.cars.push(_car);\n    }\n\n    /// @notice Update cars and size of a matching target.\n    /// @dev This function is used to update cars and size of target of matching.\n    function _updateTargetCars(\n        MatchingType.MatchingTarget storage self,\n        uint64[] memory _cars,\n        uint64 _size\n    ) internal {\n        for (uint64 i = 0; i < _cars.length; i++) {\n            _pushCar(self, _cars[i]);\n        }\n        self.size += _size;\n    }\n}\n"
    },
    "src/v0.8/module/matching/Matchings.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\n\n/// shared\nimport {MatchingsEvents} from \"src/v0.8/shared/events/MatchingsEvents.sol\";\nimport {MatchingsModifiers} from \"src/v0.8/shared/modifiers/MatchingsModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n\n/// library\nimport {MatchingLIB} from \"src/v0.8/module/matching/library/MatchingLIB.sol\";\nimport {MatchingStateMachineLIB} from \"src/v0.8/module/matching/library/MatchingStateMachineLIB.sol\";\nimport \"src/v0.8/shared/utils/array/ArrayLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Matchings Base Contract\n/// @notice This contract serves as the base for managing matchings, their states, and associated actions.\n/// @dev This contract is intended to be inherited by specific matching-related contracts.\n///      TODO: Missing fund proccess,need add later https://github.com/dataswap/core/issues/20\n///            1 bidder(when bidding) and initiator(when publish) should transfer FIL to payable function\n///            2 proccess the fund after matched\n///            3 proccess the fund after matchedsotre,step by step\ncontract Matchings is\n    Initializable,\n    UUPSUpgradeable,\n    IMatchings,\n    MatchingsModifiers\n{\n    /// @notice  Use libraries for different matching functionalities\n    using MatchingLIB for MatchingType.Matching;\n    using MatchingStateMachineLIB for MatchingType.Matching;\n    using ArrayAddressLIB for address[];\n\n    /// @notice  Declare private variables\n    uint64 public matchingsCount;\n    mapping(uint64 => MatchingType.Matching) private matchings;\n\n    address private governanceAddress;\n    IRoles private roles;\n    IDatasetsRequirement public datasetsRequirement;\n    IMatchingsTarget public matchingsTarget;\n    IMatchingsBids public matchingsBids;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    // solhint-disable-next-line\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _datasetsRequirement\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        datasetsRequirement = IDatasetsRequirement(_datasetsRequirement);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice The function to init the dependencies of a matchings.\n    function initDependencies(\n        address _matchingsTarget,\n        address _matchingsBids\n    ) external onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        matchingsTarget = IMatchingsTarget(_matchingsTarget);\n        matchingsBids = IMatchingsBids(_matchingsBids);\n    }\n\n    /// @notice Function for create a new matching.\n    /// @param _datasetId The dataset id to create matching.\n    /// @param _bidSelectionRule The rules for determining the winning bid.\n    /// @param _biddingDelayBlockCount The number of blocks to delay bidding.\n    /// @param _biddingPeriodBlockCount The number of blocks for bidding period.\n    /// @param _storageCompletionPeriodBlocks The number of blocks for storage period.\n    /// @param _biddingThreshold The threshold for bidding.\n    /// @param _replicaIndex The index of the replica in dataset.\n    /// @param _additionalInfo The additional information about the matching.\n    /// @return The matchingId.\n    function createMatching(\n        uint64 _datasetId,\n        MatchingType.BidSelectionRule _bidSelectionRule,\n        uint64 _biddingDelayBlockCount,\n        uint64 _biddingPeriodBlockCount,\n        uint64 _storageCompletionPeriodBlocks,\n        uint256 _biddingThreshold,\n        uint16 _replicaIndex,\n        string memory _additionalInfo\n    ) external onlyRole(roles, RolesType.DATASET_PROVIDER) returns (uint64) {\n        matchingsCount++;\n        MatchingType.Matching storage matching = matchings[matchingsCount];\n        require(\n            _replicaIndex <\n                datasetsRequirement.getDatasetReplicasCount(_datasetId),\n            \"Invalid matching replica\"\n        );\n\n        ///TODO: the dp must by client or submit proof\n        (address[] memory dp, , , , ) = datasetsRequirement\n            .getDatasetReplicaRequirement(_datasetId, _replicaIndex);\n\n        if (dp.length > 0) {\n            require(dp.isContains(msg.sender), \"Invalid DP submitter\");\n        }\n\n        matching.bidSelectionRule = _bidSelectionRule;\n        matching.biddingDelayBlockCount = _biddingDelayBlockCount;\n        matching.biddingPeriodBlockCount = _biddingPeriodBlockCount;\n        matching.storageCompletionPeriodBlocks = _storageCompletionPeriodBlocks;\n        matching.biddingThreshold = _biddingThreshold;\n        matching.additionalInfo = _additionalInfo;\n        matching.initiator = msg.sender;\n        matching.createdBlockNumber = uint64(block.number);\n        return matchingsCount;\n    }\n\n    /// @notice Function for pausing a matching\n    function pauseMatching(\n        uint64 _matchingId\n    ) external onlyMatchingInitiator(this, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._pauseMatching();\n        emit MatchingsEvents.MatchingPaused(_matchingId);\n    }\n\n    /// @notice Function for resuming a paused matching\n    function resumeMatching(\n        uint64 _matchingId\n    ) external onlyMatchingInitiator(this, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._resumeMatching();\n        emit MatchingsEvents.MatchingResumed(_matchingId);\n    }\n\n    /// @notice Function for publishing a matching\n    /// @param _matchingId The matching id to publish cars.\n    function reportPublishMatching(\n        uint64 _matchingId\n    ) external onlyMatchingsTarget(matchingsTarget, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._publishMatching();\n    }\n\n    /// @notice Function for report canceling a matching\n    function reportCancelMatching(\n        uint64 _matchingId\n    ) external onlyMatchingsBids(matchingsBids, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._cancelMatching();\n        emit MatchingsEvents.MatchingCancelled(_matchingId);\n    }\n\n    /// @notice Function for closing a matching\n    function reportCloseMatching(\n        uint64 _matchingId\n    ) external onlyMatchingsBids(matchingsBids, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._closeMatching();\n        emit MatchingsEvents.MatchingClosed(_matchingId);\n    }\n\n    /// @notice Function for report complete a matching with a winner\n    function reportMatchingHasWinner(\n        uint64 _matchingId,\n        address _winner\n    ) external onlyMatchingsBids(matchingsBids, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._reportMatchingHasWinner();\n        emit MatchingsEvents.MatchingHasWinner(_matchingId, _winner);\n    }\n\n    /// @notice Function for report complete a matching without winner.\n    function reportMatchingNoWinner(\n        uint64 _matchingId\n    ) external onlyMatchingsBids(matchingsBids, _matchingId) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        matching._reportMatchingNoWinner();\n        emit MatchingsEvents.MatchingNoWinner(_matchingId);\n    }\n\n    /// @notice Function for getting the initiator of a matching\n    function getMatchingInitiator(\n        uint64 _matchingId\n    ) public view returns (address) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return matching.initiator;\n    }\n\n    /// @notice Function for getting the state of a matching\n    function getMatchingState(\n        uint64 _matchingId\n    ) public view returns (MatchingType.State) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return matching._getMatchingState();\n    }\n\n    /// @notice Function for getting the selection rule of a matching\n    function getBidSelectionRule(\n        uint64 _matchingId\n    ) public view returns (MatchingType.BidSelectionRule) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return matching.bidSelectionRule;\n    }\n\n    /// @notice Function for getting the threshold of a matching\n    function getBiddingThreshold(\n        uint64 _matchingId\n    ) public view returns (uint256) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return matching.biddingThreshold;\n    }\n\n    /// @notice Function for getting the start height of a matching\n    function getBiddingStartHeight(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return matching.createdBlockNumber + matching.biddingDelayBlockCount;\n    }\n\n    /// @notice Function for getting the after pause height of a matching\n    function getBiddingAfterPauseHeight(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return\n            matching.createdBlockNumber +\n            matching.biddingDelayBlockCount +\n            matching.pausedBlockCount;\n    }\n\n    /// @notice Function for getting the end height of a matching\n    function getBiddingEndHeight(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        MatchingType.Matching storage matching = matchings[_matchingId];\n        return\n            matching.createdBlockNumber +\n            matching.biddingDelayBlockCount +\n            matching.biddingPeriodBlockCount +\n            matching.pausedBlockCount;\n    }\n}\n"
    },
    "src/v0.8/module/matching/MatchingsBids.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\n\n/// shared\nimport {MatchingsEvents} from \"src/v0.8/shared/events/MatchingsEvents.sol\";\nimport {MatchingsModifiers} from \"src/v0.8/shared/modifiers/MatchingsModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n\n/// library\nimport {MatchingBidsLIB} from \"src/v0.8/module/matching/library/MatchingBidsLIB.sol\";\nimport \"src/v0.8/shared/utils/array/ArrayLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Matchings Base Contract\n/// @notice This contract serves as the base for managing matchings, their states, and associated actions.\n/// @dev This contract is intended to be inherited by specific matching-related contracts.\n///      TODO: Missing fund proccess,need add later https://github.com/dataswap/core/issues/20\n///            1 bidder(when bidding) and initiator(when publish) should transfer FIL to payable function\n///            2 proccess the fund after matched\n///            3 proccess the fund after matchedsotre,step by step\ncontract MatchingsBids is\n    Initializable,\n    UUPSUpgradeable,\n    IMatchingsBids,\n    MatchingsModifiers\n{\n    /// @notice  Use libraries for different matching functionalities\n    using MatchingBidsLIB for MatchingType.MatchingBids;\n    using ArrayAddressLIB for address[];\n    using ArrayUint64LIB for uint64[];\n\n    /// @notice  Declare private variables\n    mapping(uint64 => MatchingType.MatchingBids) private matchingBids;\n\n    address private governanceAddress;\n    IRoles private roles;\n    IFilplus private filplus;\n    ICarstore private carstore;\n    IDatasets public datasets;\n    IDatasetsRequirement public datasetsRequirement;\n    IDatasetsProof public datasetsProof;\n    IMatchings public matchings;\n    IMatchingsTarget public matchingsTarget;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    // solhint-disable-next-line\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _carstore,\n        address _datasets,\n        address _datasetsRequirement,\n        address _datasetsProof\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        filplus = IFilplus(_filplus);\n        carstore = ICarstore(_carstore);\n        datasets = IDatasets(_datasets);\n        datasetsRequirement = IDatasetsRequirement(_datasetsRequirement);\n        datasetsProof = IDatasetsProof(_datasetsProof);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice The function to init the dependencies of a matchingsBids.\n    function initDependencies(\n        address _matchings,\n        address _matchingsTarget\n    ) external onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        matchings = IMatchings(_matchings);\n        matchingsTarget = IMatchingsTarget(_matchingsTarget);\n    }\n\n    /// @notice Function for bidding on a matching\n    function bidding(\n        uint64 _matchingId,\n        uint256 _amount\n    )\n        external\n        onlyRole(roles, RolesType.STORAGE_PROVIDER)\n        onlyMatchingState(matchings, _matchingId, MatchingType.State.InProgress)\n    {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        MatchingType.BidSelectionRule bidSelectionRule = matchings\n            .getBidSelectionRule(_matchingId);\n        bids._matchingBidding(\n            bidSelectionRule,\n            matchings.getBiddingThreshold(_matchingId),\n            matchings.getBiddingAfterPauseHeight(_matchingId),\n            matchings.getBiddingEndHeight(_matchingId),\n            _amount\n        );\n        (, address[] memory sp, , , ) = datasetsRequirement\n            .getDatasetReplicaRequirement(\n                matchingsTarget.getMatchingDatasetId(_matchingId),\n                matchingsTarget.getMatchingReplicaIndex(_matchingId)\n            );\n\n        if (sp.length > 0) {\n            require(sp.isContains(msg.sender), \"Invalid SP submitter\");\n        }\n\n        emit MatchingsEvents.MatchingBidPlaced(\n            _matchingId,\n            msg.sender,\n            _amount\n        );\n        if (\n            bidSelectionRule ==\n            MatchingType.BidSelectionRule.ImmediateAtLeast ||\n            bidSelectionRule == MatchingType.BidSelectionRule.ImmediateAtMost\n        ) {\n            closeMatching(_matchingId);\n        }\n    }\n\n    ///@dev update cars info to carStore after matching failed\n    function _afterMatchingFailed(uint64 _matchingId) internal {\n        uint64[] memory cars = matchingsTarget.getMatchingCars(_matchingId);\n        for (uint64 i; i < cars.length; i++) {\n            carstore.reportCarReplicaMatchingState(cars[i], _matchingId, false);\n        }\n    }\n\n    ///@dev update cars info to carStore before matching complete\n    function _beforeMatchingCompleted(uint64 _matchingId) internal {\n        uint64[] memory cars = matchingsTarget.getMatchingCars(_matchingId);\n        for (uint64 i; i < cars.length; i++) {\n            carstore.reportCarReplicaMatchingState(cars[i], _matchingId, true);\n        }\n    }\n\n    /// @notice Function for canceling a matching\n    /// @param _matchingId The ID of the matching.\n    function cancelMatching(\n        uint64 _matchingId\n    ) external onlyMatchingInitiator(matchings, _matchingId) {\n        _afterMatchingFailed(_matchingId);\n        try matchings.reportCancelMatching(_matchingId) {} catch Error(\n            string memory err\n        ) {\n            revert(err);\n        } catch {\n            revert(\"report cancel matching failed\");\n        }\n    }\n\n    /// @notice Function for closing a matching and choosing a winner\n    function closeMatching(uint64 _matchingId) public {\n        if (\n            matchings.getMatchingState(_matchingId) ==\n            MatchingType.State.InProgress\n        ) {\n            try matchings.reportCloseMatching(_matchingId) {} catch {\n                revert(\"close matching failed\");\n            }\n        }\n\n        require(\n            matchings.getMatchingState(_matchingId) ==\n                MatchingType.State.Closed,\n            \"Invalid state\"\n        );\n\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        address winner = bids._chooseMatchingWinner(\n            matchings.getBidSelectionRule(_matchingId),\n            matchings.getBiddingThreshold(_matchingId),\n            matchings.getBiddingAfterPauseHeight(_matchingId),\n            matchings.getBiddingEndHeight(_matchingId)\n        );\n\n        if (winner != address(0)) {\n            if (\n                !matchingsTarget.isMatchingTargetMeetsFilPlusRequirements(\n                    _matchingId,\n                    winner\n                )\n            ) {\n                bids._setMatchingBidderNotComplyFilplusRule(winner);\n                revert Errors\n                    .NotCompliantRuleMatchingTargetMeetsFilPlusRequirements(\n                        _matchingId,\n                        winner\n                    );\n            }\n\n            _beforeMatchingCompleted(_matchingId);\n            bids.winner = winner;\n            matchings.reportMatchingHasWinner(_matchingId, winner);\n        } else {\n            _afterMatchingFailed(_matchingId);\n            matchings.reportMatchingNoWinner(_matchingId);\n        }\n    }\n\n    /// @notice Function for getting bids in a matching\n    function getMatchingBids(\n        uint64 _matchingId\n    ) public view returns (address[] memory, uint256[] memory) {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        return bids._getMatchingBids();\n    }\n\n    /// @notice Function for getting bid amount of a bidder in a matching\n    function getMatchingBidAmount(\n        uint64 _matchingId,\n        address _bidder\n    ) public view returns (uint256) {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        return bids._getMatchingBidAmount(_bidder);\n    }\n\n    /// @notice Function for getting the count of bids in a matching\n    function getMatchingBidsCount(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        return bids._getMatchingBidsCount();\n    }\n\n    /// @notice Function for getting winner of a matching\n    function getMatchingWinner(\n        uint64 _matchingId\n    ) public view returns (address) {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        return bids.winner;\n    }\n\n    /// @notice Function for getting winners of a matchings\n    function getMatchingWinners(\n        uint64[] memory _matchingIds\n    ) public view returns (address[] memory) {\n        (uint256 count, uint64[] memory matchingIds) = _matchingIds\n            .removeElement(0);\n        address[] memory winners = new address[](count);\n        for (uint64 i = 0; i < count; i++) {\n            winners[i] = getMatchingWinner(matchingIds[i]);\n        }\n        return winners;\n    }\n\n    /// @notice Function for checking if a bidder has a bid in a matching\n    function hasMatchingBid(\n        uint64 _matchingId,\n        address _bidder\n    ) public view returns (bool) {\n        MatchingType.MatchingBids storage bids = matchingBids[_matchingId];\n        return bids._hasMatchingBid(_bidder);\n    }\n}\n"
    },
    "src/v0.8/module/matching/MatchingsTarget.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IDatasetsRequirement} from \"src/v0.8/interfaces/module/IDatasetsRequirement.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\n/// shared\nimport {MatchingsEvents} from \"src/v0.8/shared/events/MatchingsEvents.sol\";\nimport {MatchingsModifiers} from \"src/v0.8/shared/modifiers/MatchingsModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n\n/// library\nimport {MatchingTargetLIB} from \"src/v0.8/module/matching/library/MatchingTargetLIB.sol\";\nimport \"src/v0.8/shared/utils/array/ArrayLIB.sol\";\n\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Matchings Base Contract\n/// @notice This contract serves as the base for managing matchings, their states, and associated actions.\n/// @dev This contract is intended to be inherited by specific matching-related contracts.\n///      TODO: Missing fund proccess,need add later https://github.com/dataswap/core/issues/20\n///            1 bidder(when bidding) and initiator(when publish) should transfer FIL to payable function\n///            2 proccess the fund after matched\n///            3 proccess the fund after matchedsotre,step by step\ncontract MatchingsTarget is\n    Initializable,\n    UUPSUpgradeable,\n    IMatchingsTarget,\n    MatchingsModifiers\n{\n    /// @notice  Use libraries for different matching functionalities\n    using MatchingTargetLIB for MatchingType.MatchingTarget;\n    using ArrayAddressLIB for address[];\n\n    /// @notice  Declare private variables\n    mapping(uint64 => MatchingType.MatchingTarget) private targets;\n\n    address private governanceAddress;\n    IRoles private roles;\n    IFilplus private filplus;\n    ICarstore private carstore;\n    IDatasets public datasets;\n    IDatasetsRequirement public datasetsRequirement;\n    IDatasetsProof public datasetsProof;\n    IMatchings public matchings;\n    IMatchingsBids public matchingsBids;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    // solhint-disable-next-line\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _carstore,\n        address _datasets,\n        address _datasetsRequirement,\n        address _datasetsProof\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        filplus = IFilplus(_filplus);\n        carstore = ICarstore(_carstore);\n        datasets = IDatasets(_datasets);\n        datasetsRequirement = IDatasetsRequirement(_datasetsRequirement);\n        datasetsProof = IDatasetsProof(_datasetsProof);\n\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice The function to init the dependencies of a matchingsTarget.\n    function initDependencies(\n        address _matchings,\n        address _matchingsBids\n    ) external onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) {\n        matchings = IMatchings(_matchings);\n        matchingsBids = IMatchingsBids(_matchingsBids);\n    }\n\n    ///@dev update cars info  to carStore before bidding\n    function _beforeBidding(uint64 _matchingId) internal {\n        uint64[] memory cars = getMatchingCars(_matchingId);\n        uint16 replicaIndex = getMatchingReplicaIndex(_matchingId);\n        for (uint64 i; i < cars.length; i++) {\n            carstore.registCarReplica(cars[i], _matchingId, replicaIndex);\n        }\n    }\n\n    /// @notice Function for create a new matching target.\n    /// @param _matchingId The matching id to publish cars.\n    /// @param _datasetId The dataset id to create matching.\n    /// @param _dataType Identify the data type of \"cars\", which can be either \"Source\" or \"MappingFiles\".\n    /// @param _associatedMappingFilesMatchingID The matching ID that associated with mapping files of dataset of _datasetId\n    /// @param _replicaIndex The index of the replica in dataset.\n    function createTarget(\n        uint64 _matchingId,\n        uint64 _datasetId,\n        DatasetType.DataType _dataType,\n        uint64 _associatedMappingFilesMatchingID,\n        uint16 _replicaIndex\n    )\n        external\n        onlyRole(roles, RolesType.DATASET_PROVIDER)\n        //onlyMatchingState(matchings, _matchingId, MatchingType.State.None)\n        onlyMatchingInitiator(matchings, _matchingId)\n    {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        target.datasetId = _datasetId;\n        target.cars = new uint64[](0);\n        target.size = 0;\n        target.dataType = _dataType;\n        target\n            .associatedMappingFilesMatchingID = _associatedMappingFilesMatchingID;\n        target.replicaIndex = _replicaIndex;\n    }\n\n    /// @notice  Function for parse cars from indexes.\n    /// @param _starts The starts of cars to publish.\n    /// @param _ends The ends of cars to publish.\n    /// @return The cars of the indexes.\n    function parseCars(\n        uint64[] memory _starts,\n        uint64[] memory _ends\n    ) public pure returns (uint64[] memory) {\n        require(_starts.length == _ends.length, \"start and end not match\");\n        uint64 total;\n        for (uint64 i = 0; i < _starts.length; i++) {\n            require(_starts[i] <= _ends[i], \"start must be greater than end\");\n            total += _ends[i] - _starts[i] + 1;\n        }\n        uint64 cnt;\n        uint64[] memory _cars = new uint64[](total);\n        for (uint64 i = 0; i < _starts.length; i++) {\n            for (uint64 j = _starts[i]; j <= _ends[i]; j++) {\n                _cars[cnt] = j;\n                cnt++;\n            }\n        }\n        return _cars;\n    }\n\n    /// @notice  Function for publishing a matching\n    /// @param _matchingId The matching id to publish cars.\n    /// @param _datasetId The dataset id of matching.\n    /// @param _carsStarts The cars to publish.\n    /// @param _carsEnds The cars to publish.\n    /// @param complete If the publish is complete.\n    function publishMatching(\n        uint64 _matchingId,\n        uint64 _datasetId,\n        uint64[] memory _carsStarts,\n        uint64[] memory _carsEnds,\n        bool complete\n    )\n        external\n        onlyRole(roles, RolesType.DATASET_PROVIDER)\n        onlyMatchingInitiator(matchings, _matchingId)\n    {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        uint64[] memory _cars = parseCars(_carsStarts, _carsEnds);\n        uint64 _size;\n        try carstore.getCarsSize(_cars) returns (uint64 carSize) {\n            _size = carSize;\n        } catch {\n            revert(\"Get cars size failed\");\n        }\n        require(target.datasetId == _datasetId, \"invalid dataset id\");\n\n        target._updateTargetCars(_cars, _size);\n\n        require(\n            isMatchingTargetValid(\n                _datasetId,\n                _cars,\n                _size,\n                target.dataType,\n                target.associatedMappingFilesMatchingID\n            ),\n            \"Target invalid\"\n        );\n\n        if (complete) {\n            _beforeBidding(_matchingId);\n            matchings.reportPublishMatching(_matchingId);\n            emit MatchingsEvents.MatchingPublished(_matchingId, msg.sender);\n        }\n    }\n\n    /// @notice Get the cars of a matching.\n    /// @param _matchingId The ID of the matching.\n    /// @return cars An array of CIDs representing the cars in the matching.\n    function getMatchingCars(\n        uint64 _matchingId\n    ) public view returns (uint64[] memory) {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        return target._getCars();\n    }\n\n    /// @notice  Function for getting the dataset id in a matching\n    /// @param _matchingId The ID of the matching.\n    /// @return The ID of the matching's dataset.\n    function getMatchingDatasetId(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        return target._getDatasetId();\n    }\n\n    /// @notice Get the index of matching's replica.\n    /// @param _matchingId The ID of the matching.\n    /// @return index The index of the matching's replica.\n    function getMatchingReplicaIndex(\n        uint64 _matchingId\n    ) public view returns (uint16) {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        return target.replicaIndex;\n    }\n\n    /// @notice  Function for getting the total data size of bids in a matching\n    /// @param _matchingId The ID of the matching to check.\n    /// @return The size of the matching cars.\n    function getMatchingSize(uint64 _matchingId) public view returns (uint64) {\n        (, , uint64 datasize, , ) = getMatchingTarget(_matchingId);\n        return datasize;\n    }\n\n    /// @notice Get the target information of a matching.\n    /// @param _matchingId The ID of the matching.\n    /// @return datasetID The ID of the associated dataset.\n    /// @return cars An array of CIDs representing the cars in the matching.\n    /// @return size The size of the matching.\n    /// @return dataType The data type of the matching.\n    /// @return associatedMappingFilesMatchingID The ID of the associated mapping files matching.\n    function getMatchingTarget(\n        uint64 _matchingId\n    )\n        public\n        view\n        returns (\n            uint64 datasetID,\n            uint64[] memory cars,\n            uint64 size,\n            DatasetType.DataType dataType,\n            uint64 associatedMappingFilesMatchingID\n        )\n    {\n        // Access the matching with the specified ID and retrieve the target information\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        return (\n            target.datasetId,\n            target.cars,\n            target.size,\n            target.dataType,\n            target.associatedMappingFilesMatchingID\n        );\n    }\n\n    /// @notice Check if a matching with the given matching ID contains a specific CID.\n    /// @param _matchingId The ID of the matching to check.\n    /// @param _cid The CID (Content Identifier) to check for.\n    /// @return True if the matching contains the specified CID, otherwise false.\n    function isMatchingContainsCar(\n        uint64 _matchingId,\n        uint64 _cid\n    ) public view returns (bool) {\n        uint64[] memory cids = getMatchingCars(_matchingId);\n        for (uint64 i = 0; i < cids.length; i++) {\n            if (_cid == cids[i]) return true;\n        }\n        return false;\n    }\n\n    /// @notice Check if a matching with the given matching ID contains multiple CIDs.\n    /// @param _matchingId The ID of the matching to check.\n    /// @param _cids An array of CIDs (Content Identifiers) to check for.\n    /// @return True if the matching contains all the specified CIDs, otherwise false.\n    function isMatchingContainsCars(\n        uint64 _matchingId,\n        uint64[] memory _cids\n    ) public view returns (bool) {\n        for (uint64 i = 0; i < _cids.length; i++) {\n            if (!isMatchingContainsCar(_matchingId, _cids[i])) return false;\n        }\n        return true;\n    }\n\n    /// @notice check is matching targe valid\n    function isMatchingTargetValid(\n        uint64 _datasetId,\n        uint64[] memory _cars,\n        uint64 _size,\n        DatasetType.DataType _dataType,\n        uint64 _associatedMappingFilesMatchingID\n    ) public view returns (bool) {\n        require(\n            datasets.getDatasetState(_datasetId) ==\n                DatasetType.State.DatasetApproved,\n            \"datasetId is not approved!\"\n        );\n        require(\n            datasetsProof.isDatasetContainsCars(_datasetId, _cars),\n            \"Invalid cids!\"\n        );\n        require(_size > 0, \"Invalid size!\");\n\n        // Source data needs to ensure that the associated mapping files data has been stored\n        if (_dataType == DatasetType.DataType.Source) {\n            (\n                ,\n                uint64[] memory mappingsCars,\n                ,\n                DatasetType.DataType dataType,\n\n            ) = getMatchingTarget(_associatedMappingFilesMatchingID);\n\n            require(\n                dataType == DatasetType.DataType.MappingFiles,\n                \"Need a associated matching\"\n            );\n\n            require(\n                datasetsProof.isDatasetContainsCars(_datasetId, mappingsCars),\n                \"Invalid mapping files cars\"\n            );\n\n            require(\n                matchings.getMatchingState(_associatedMappingFilesMatchingID) ==\n                    MatchingType.State.Completed,\n                \"datasetId is not completed!\"\n            );\n        }\n        return true;\n    }\n\n    /// @notice Check if a matching meets the requirements of Fil+.\n    function isMatchingTargetMeetsFilPlusRequirements(\n        uint64 _matchingId,\n        address candidate\n    ) external view returns (bool) {\n        MatchingType.MatchingTarget storage target = targets[_matchingId];\n        uint64[] memory cars = getMatchingCars(_matchingId);\n        uint16 requirementReplicaCount = datasetsRequirement\n            .getDatasetReplicasCount(target.datasetId);\n        for (uint64 i; i < cars.length; i++) {\n            address[] memory winners = matchingsBids.getMatchingWinners(\n                carstore.getCarMatchingIds(cars[i])\n            );\n\n            uint256 alreadyStoredReplicasByWinner = winners.countOccurrences(\n                candidate\n            );\n\n            if (\n                !filplus.isCompliantRuleMaxReplicasPerSP(\n                    uint16(alreadyStoredReplicasByWinner + 1)\n                )\n            ) {\n                return false;\n            }\n\n            uint256 uniqueCount = winners.countUniqueElements();\n\n            if (winners.isContains(candidate)) {\n                uniqueCount++;\n            }\n\n            if (\n                !filplus.isCompliantRuleMinSPsPerDataset(\n                    requirementReplicaCount,\n                    uint16(winners.length),\n                    uint16(uniqueCount)\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "src/v0.8/module/storage/Storages.sol": {
      "content": "/// SPDX-License-Identifier: GPL-3.0-or-later\n/// (c) 2023 Dataswap\n///\n/// Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     https://www.gnu.org/licenses/gpl-3.0.en.html\n///\n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n\npragma solidity ^0.8.21;\n\n/// interface\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\nimport {IStorages} from \"src/v0.8/interfaces/module/IStorages.sol\";\n/// shared\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\nimport {StoragesEvents} from \"src/v0.8/shared/events/StoragesEvents.sol\";\nimport {StoragesModifiers} from \"src/v0.8/shared/modifiers/StoragesModifiers.sol\";\nimport {CidUtils} from \"src/v0.8/shared/utils/cid/CidUtils.sol\";\n/// type\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\nimport {StorageType} from \"src/v0.8/types/StorageType.sol\";\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract Storages is\n    Initializable,\n    UUPSUpgradeable,\n    IStorages,\n    StoragesModifiers\n{\n    mapping(uint64 => StorageType.Storage) private storages; //matchingId=>Matchedstore\n\n    address private governanceAddress;\n    IRoles private roles;\n    IFilplus private filplus;\n    IFilecoin private filecoin;\n    ICarstore private carstore;\n    IMatchings public matchings;\n    IMatchingsTarget public matchingsTarget;\n    IMatchingsBids public matchingsBids;\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    uint256[32] private __gap;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(\n        address _governanceAddress,\n        address _roles,\n        address _filplus,\n        address _filecoin,\n        address _carstore,\n        address _matchings,\n        address _matchingsTarget,\n        address _matchingsBids\n    ) public initializer {\n        governanceAddress = _governanceAddress;\n        roles = IRoles(_roles);\n        filplus = IFilplus(_filplus);\n        filecoin = IFilecoin(_filecoin);\n        carstore = ICarstore(_carstore);\n        matchings = IMatchings(_matchings);\n        matchingsTarget = IMatchingsTarget(_matchingsTarget);\n        matchingsBids = IMatchingsBids(_matchingsBids);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @dev Submits a Filecoin claim Id for a matchedstore after successful matching.\n    /// @param _matchingId The ID of the matching.\n    /// @param _provider A provider of storage provider of matching.\n    /// @param _id The content identifier of the matched data.\n    /// @param _claimId The ID of the successful Filecoin storage deal.\n    function submitStorageClaimId(\n        uint64 _matchingId,\n        uint64 _provider,\n        uint64 _id,\n        uint64 _claimId\n    )\n        public\n        onlyAddress(matchingsBids.getMatchingWinner(_matchingId))\n        onlyUnsetCarReplicaFilecoinClaimId(carstore, _id, _matchingId)\n    {\n        require(\n            CarReplicaType.State.Matched ==\n                carstore.getCarReplicaState(_id, _matchingId),\n            \"Invalid Replica State\"\n        );\n\n        StorageType.Storage storage storage_ = storages[_matchingId];\n\n        bytes memory dataCid = filecoin.getReplicaClaimData(\n            _provider,\n            _claimId\n        );\n        bytes32 _hash = carstore.getCarHash(_id);\n        bytes memory cid = CidUtils.hashToCID(_hash);\n\n        require(keccak256(dataCid) == keccak256(cid), \"cid mismatch\");\n\n        storage_.doneCars.push(_id);\n\n        /// Note:set claim id in carstore berfore submitClaimid\n        carstore.setCarReplicaFilecoinClaimId(_id, _matchingId, _claimId);\n\n        emit StoragesEvents.StorageClaimIdSubmitted(_matchingId, _id, _claimId);\n    }\n\n    /// @dev Submits multiple Filecoin claim Ids for a matchedstore after successful matching.\n    /// @param _matchingId The ID of the matching.\n    /// @param _provider A provider of storage provider of matching.\n    /// @param _ids An array of content identifiers of the matched data.\n    /// @param _claimIds An array of IDs of successful Filecoin storage deals.\n    function submitStorageClaimIds(\n        uint64 _matchingId,\n        uint64 _provider,\n        uint64[] memory _ids,\n        uint64[] memory _claimIds\n    ) external {\n        if (_ids.length != _claimIds.length) {\n            revert Errors.ParamLengthMismatch(_ids.length, _claimIds.length);\n        }\n        for (uint64 i = 0; i < _ids.length; i++) {\n            submitStorageClaimId(_matchingId, _provider, _ids[i], _claimIds[i]);\n        }\n    }\n\n    /// @dev Gets the list of done cars in the matchedstore.\n    function getStoredCars(\n        uint64 _matchingId\n    ) public view returns (uint64[] memory) {\n        StorageType.Storage storage storage_ = storages[_matchingId];\n        return storage_.doneCars;\n    }\n\n    /// @dev Gets the count of done cars in the matchedstore.\n    function getStoredCarCount(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        StorageType.Storage storage storage_ = storages[_matchingId];\n        return uint64(storage_.doneCars.length);\n    }\n\n    /// @dev Gets the stored size in the matchedstore.\n    function getTotalStoredSize(\n        uint64 _matchingId\n    ) public view returns (uint64) {\n        StorageType.Storage storage storage_ = storages[_matchingId];\n        uint64 size = 0;\n        for (uint64 i = 0; i < storage_.doneCars.length; i++) {\n            size += carstore.getCarSize(storage_.doneCars[i]);\n        }\n        return size;\n    }\n\n    /// @dev Gets the car size in the matchedstore.\n    function getStoredCarSize(\n        uint64 _matchingId,\n        uint64 _id\n    ) public view returns (uint64) {\n        StorageType.Storage storage storage_ = storages[_matchingId];\n        for (uint64 i = 0; i < storage_.doneCars.length; i++) {\n            if (storage_.doneCars[i] == _id) {\n                return carstore.getCarSize(_id);\n            }\n        }\n        return 0;\n    }\n\n    /// @dev Checks if all cars are done in the matchedstore.\n    function isAllStoredDone(uint64 _matchingId) public view returns (bool) {\n        StorageType.Storage storage storage_ = storages[_matchingId];\n        return\n            storage_.doneCars.length ==\n            matchingsTarget.getMatchingCars(_matchingId).length;\n    }\n}\n"
    },
    "src/v0.8/shared/errors/Errors.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\nlibrary Errors {\n    /// @notice commmon errors\n    error ParamLengthMismatch(uint256 _expectedLength, uint256 _actualLength);\n\n    /// @notice car errors\n    error CarNotExist(uint64 _id);\n    error CarAlreadyExists(uint64 _id, bytes32 _hash);\n    error ReplicaNotExist(uint64 _id, uint64 _matchingId);\n    error ReplicaAlreadyExists(uint64 _id, uint64 _matchingId);\n    error ReplicaFilecoinClaimIdExists(uint64 _id, uint64 _matchingId);\n    error InvalidReplicaState(uint64 _id, uint64 _matchingId);\n    error InvalidReplicaFilecoinDealState(uint64 _id, uint64 _filecoinId);\n\n    /// @notice Dataset errors\n    error DatasetMetadataNotExist(string accessMethod);\n    error DatasetMetadataAlreadyExist(string accessMethod);\n    error InvalidDatasetState(uint64 datasetId);\n    error InvalidDatasetProofsSubmitter(uint64 datasetId, address submitter);\n\n    /// @notice matching errors\n    error InvalidMatchingState(\n        uint64 matchingId,\n        MatchingType.State expectedState,\n        MatchingType.State actualState\n    );\n    error NotMatchingInitiator(\n        uint64 matchingId,\n        address expectedInitiator,\n        address actualInitiator\n    );\n\n    error NotMatchingsTarget(uint64 _matchingId, address actualAddress);\n    error NotMatchingsBids(uint64 _matchingId, address actualAddress);\n\n    /// @notice storage errors\n    error StorageDealNotSuccessful(uint64 _claimId);\n    error StorageClaimIdAlreadySet(\n        uint64 _matchingId,\n        bytes32 _cid,\n        uint64 _claimId\n    );\n\n    /// @notice datacap errors\n    error AllocatedDatacapExceedsTotalRequirement(\n        uint64 _allocatedDatacap,\n        uint64 _totalDatacapAllocationRequirement\n    );\n    error AvailableDatacapExceedAllocationThreshold(\n        uint64 availableDatacap,\n        uint64 allocationThreshold\n    );\n    error NextDatacapAllocationInvalid(uint64 _matchingId);\n    error StoredExceedsAllocatedDatacap(\n        uint64 reallyStored,\n        uint64 allocatedDatacap\n    );\n    error NotCompliantRuleMaxReplicasPerSP(address winner, bytes32 cid);\n    error NotCompliantRuleMatchingTargetMeetsFilPlusRequirements(\n        uint64 matchingId,\n        address winner\n    );\n    error NotEnough(uint256 amount, uint256 append);\n}\n"
    },
    "src/v0.8/shared/events/CarstoreEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title Filplus\nlibrary CarstoreEvents {\n    /// @notice Emitted when multiple cars are added to the storage.\n    event CarsAdded(bytes32[] _cids);\n\n    /// @notice Emitted when a replica is registed to a car.\n    event CarReplicaRegisted(\n        uint64 indexed _id,\n        uint64 _matchingId,\n        uint16 _replicaIndex\n    );\n\n    /// @notice Report that matching for a replica has failed.\n    /// @dev This function allows reporting that the matching for a replica has failed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    /// @param _matchingState Matching state of the replica.\n    event CarReplicaMatchingState(\n        uint64 indexed _id,\n        uint64 _matchingId,\n        string _matchingState\n    );\n\n    /// @notice Report that storage deal for a replica has expired.\n    /// @dev This function allows reporting that the storage deal for a replica has expired.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    event CarReplicaExpired(uint64 indexed _id, uint64 _matchingId);\n\n    /// @notice Report that storage of a replica has failed.\n    /// @dev This function allows reporting that the storage of a replica has failed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    event CarReplicaFailed(uint64 indexed _id, uint64 _matchingId);\n\n    /// @notice Emitted when the Filecoin claim ID is set for a replica's storage.\n    event CarReplicaFilecoinClaimIdSet(\n        uint64 indexed _id,\n        uint64 _matchingId,\n        uint64 _claimId\n    );\n\n    /// @notice Report that storage of a replica has been slashed.\n    /// @dev This function allows reporting that the storage of a replica has been slashed.\n    /// @param _id Car ID associated with the replica.\n    /// @param _matchingId Matching ID of the replica.\n    event CarReplicaSlashed(uint64 indexed _id, uint64 _matchingId);\n}\n"
    },
    "src/v0.8/shared/events/DatacapsEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary DatacapsEvents {\n    ///notice:  Event emitted when datacap is allocated to a matching\n    event DatacapAllocated(uint64 indexed matchingId, uint64 allocatedCapacity);\n}\n"
    },
    "src/v0.8/shared/events/DatasetsEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary DatasetsEvents {\n    /// @notice Event emitted when metadata is approved for a dataset.\n    event DatasetMetadataApproved(uint64 indexed _datasetId);\n\n    /// @notice Event emitted when metadata is rejected for a dataset.\n    event DatasetMetadataRejected(uint64 indexed _datasetId);\n\n    /// @notice Event emitted when a dataset is approved.\n    event DatasetApproved(uint64 indexed _datasetId);\n\n    /// @notice Event emitted when a dataset is rejected.\n    event DatasetRejected(uint64 indexed _datasetId);\n\n    /// @notice Event emitted when metadata is submitted for a new dataset.\n    event DatasetMetadataSubmitted(\n        uint64 indexed _datasetId,\n        address indexed _provider\n    );\n\n    /// @notice Event emitted when replica requirement is submitted for a new dataset.\n    event DatasetReplicaRequirementSubmitted(\n        uint64 indexed _datasetId,\n        address indexed _provider\n    );\n\n    /// @notice Event emitted when a dataset has not enough collateral.\n    event CollateralNotEnough(\n        uint64 indexed _datasetId,\n        address indexed _provider\n    );\n\n    /// @notice Event emitted when a dataset has enough collateral.\n    event CollateralEnough(\n        uint64 indexed _datasetId,\n        address indexed _provider\n    );\n\n    /// @notice Event emitted when a proof is submitted for a dataset.\n    event DatasetProofSubmitted(\n        uint64 indexed _datasetId,\n        address indexed _provider\n    );\n\n    /// @notice Event emitted when a dataset is verified.\n    event DatasetChallengeProofsSubmitted(\n        uint64 indexed _datasetId,\n        address indexed _verifier\n    );\n    event LogMessage(\n        address indexed sender,\n        string message,\n        uint256 v1,\n        uint256 v2\n    );\n}\n"
    },
    "src/v0.8/shared/events/EscrowEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {EscrowType} from \"src/v0.8/types/EscrowType.sol\";\n\n/// @title EscrowEvents\nlibrary EscrowEvents {\n    /// @notice Report a collateral event.\n    /// @dev This function allows report the collateral event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event Collateral(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a withdrawal event.\n    /// @dev This function allows report the withdrawal event of funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event Withdrawn(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a update collateral event.\n    /// @dev This function allows report the update collateral event of funds.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event UpdateCollateral(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a burn event.\n    /// @dev This function allows report the burn event.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event Burn(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a payment event.\n    /// @dev This function allows report the payment event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event PaymentCollateral(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a single beneficiary payment event.\n    /// @dev This function allows report the payment event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event PaymentSingleBeneficiaryCollateral(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        address indexed _beneficiary,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a PaymentWithdrawn event.\n    /// @dev This function allows report the payment withdrawn event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event PaymentWithdrawn(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        address indexed _beneficiary,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a UpdatePaymentCollateral made by a _beneficiary.\n    /// @dev This function allows report the payment collateral event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event UpdatePaymentCollateral(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        address indexed _beneficiary,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a UpdatePaymentBeneficiaries.\n    /// @dev This function allows report the payment collateral event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _attoFILAmount The payment funds.\n    event UpdatePaymentBeneficiary(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        address _beneficiary,\n        uint256 _attoFILAmount\n    );\n\n    /// @notice Report a PaymentRefund event.\n    /// @dev This function allows report the payment refund event of a specific amount in attoFIL.\n    /// @param _type The Escrow type for the credited funds.\n    /// @param _owner The destination address for the credited funds.\n    /// @param _id The business id associated with the credited funds.\n    /// @param _beneficiary The beneficiary address for the payment credited funds.\n    /// @param _attoFILAmount The amount of attoFIL.\n    event PaymentRefund(\n        EscrowType.Type _type,\n        address indexed _owner,\n        uint64 _id,\n        address indexed _beneficiary,\n        uint256 _attoFILAmount\n    );\n}\n"
    },
    "src/v0.8/shared/events/FilplusEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title Filplus\nlibrary FilplusEvents {\n    // Event emitted when the maximum number of car replicas per car rule is set\n    event SetCarRuleMaxCarReplicas(uint32 _newValue);\n\n    // Event emitted when the minimum regions per dataset rule is set\n    event SetDatasetRuleMinRegionsPerDataset(uint32 _newValue);\n\n    // Event emitted when the default maximum replicas per country rule is set for a dataset\n    event SetDatasetRuleDefaultMaxReplicasPerCountry(uint32 _newValue);\n\n    // Event emitted when the maximum replicas per country rule is set for a dataset\n    event SetDatasetRuleMaxReplicasInCountry(\n        uint16 _countryCode,\n        uint16 _newValue\n    );\n\n    // Event emitted when the maximum replicas per city rule is set for a dataset\n    event SetDatasetRuleMaxReplicasPerCity(uint32 _newValue);\n\n    // Event emitted when the maximum proportion of dataset mapping files rule is set for a dataset\n    event SetDatasetRuleMaxProportionOfMappingFilesToDataset(uint8 _newValue);\n\n    // Event emitted when the minimum service providers (SPs) per dataset rule is set\n    event SetDatasetRuleMinSPsPerDataset(uint32 _newValue);\n\n    // Event emitted when the maximum replicas per SP (service provider) rule is set for a dataset\n    event SetDatasetRuleMaxReplicasPerSP(uint32 _newValue);\n\n    // Event emitted when the minimum total replicas per dataset rule is set\n    event SetDatasetRuleMinTotalReplicasPerDataset(uint32 _newValue);\n\n    // Event emitted when the maximum total replicas per dataset rule is set\n    event SetDatasetRuleMaxTotalReplicasPerDataset(uint32 _newValue);\n\n    // Event emitted when the maximum allocated datacap size per time rule is set\n    event SetDatacapRulesMaxAllocatedSizePerTime(uint64 _newValue);\n\n    // Event emitted when the maximum remaining percentage for the next allocation rule is set\n    event SetDatacapRulesMaxRemainingPercentageForNext(uint64 _newValue);\n}\n"
    },
    "src/v0.8/shared/events/MatchingsEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary MatchingsEvents {\n    /// @notice Declare events for external monitoring\n\n    // Event emitted when a matching is published\n    event MatchingPublished(\n        uint64 indexed matchingId,\n        address indexed initiator\n    );\n\n    // Event emitted when a matching is paused\n    event MatchingPaused(uint64 indexed _matchingId);\n\n    // Event emitted when a matching's pause expires\n    event MatchingPauseExpired(uint64 indexed _matchingId);\n\n    // Event emitted when a matching is resumed\n    event MatchingResumed(uint64 indexed _matchingId);\n\n    // Event emitted when a matching is cancelled\n    event MatchingCancelled(uint64 indexed _matchingId);\n\n    event MatchingClosed(uint64 indexed _matchingId);\n\n    // Event emitted when a matching has a winner\n    event MatchingHasWinner(\n        uint64 indexed _matchingId,\n        address indexed _winner\n    );\n\n    // Event emitted when a matching has no winner\n    event MatchingNoWinner(uint64 indexed _matchingId);\n\n    // Event emitted when a bid is placed in a matching\n    event MatchingBidPlaced(\n        uint64 indexed _matchingId,\n        address _bidder,\n        uint256 _amount\n    );\n}\n"
    },
    "src/v0.8/shared/events/StoragesEvents.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary StoragesEvents {\n    /// @dev Submits a Filecoin claim ID for a matched store after successful matching.\n    /// @param _matchingId The ID of the matching store.\n    /// @param _id The ID of the file.\n    /// @param _claimId The Filecoin claim ID.\n    event StorageClaimIdSubmitted(\n        uint64 indexed _matchingId,\n        uint64 indexed _id,\n        uint64 _claimId\n    );\n}\n"
    },
    "src/v0.8/shared/modifiers/CarstoreModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n///interface\nimport {IFilecoin} from \"src/v0.8/interfaces/core/IFilecoin.sol\";\nimport {ICarstore} from \"src/v0.8/interfaces/core/ICarstore.sol\";\n///shared\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {FilplusModifiers} from \"src/v0.8/shared/modifiers/FilplusModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n///types\nimport {CarReplicaType} from \"src/v0.8/types/CarReplicaType.sol\";\nimport {FilecoinType} from \"src/v0.8/types/FilecoinType.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract CarstoreModifiers is RolesModifiers, FilplusModifiers {\n    /// @dev Modifier to ensure that a car with the given ID exists.\n    modifier onlyCarExist(ICarstore _carstore, uint64 _id) {\n        if (!_carstore.hasCar(_id)) {\n            revert Errors.CarNotExist(_id);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a car with the given hash does not exist.\n    modifier onlyCarNotExist(ICarstore _carstore, bytes32 _hash) {\n        if (_carstore.hasCarHash(_hash)) {\n            revert Errors.CarAlreadyExists(_carstore.getCarId(_hash), _hash);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a replica of a car exists.\n    modifier onlyCarReplicaExist(\n        ICarstore _carstore,\n        uint64 _id,\n        uint64 _matchingId\n    ) {\n        if (!_carstore.hasCarReplica(_id, _matchingId)) {\n            revert Errors.ReplicaNotExist(_id, _matchingId);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a replica of a car not exists.\n    modifier onlyCarReplicaNotExist(\n        ICarstore _carstore,\n        uint64 _id,\n        uint64 _matchingId\n    ) {\n        if (_carstore.hasCarReplica(_id, _matchingId)) {\n            revert Errors.ReplicaAlreadyExists(_id, _matchingId);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a replica of a car exists.\n    modifier onlyUnsetCarReplicaFilecoinClaimId(\n        ICarstore _carstore,\n        uint64 _id,\n        uint64 _matchingId\n    ) {\n        if (_carstore.getCarReplicaFilecoinClaimId(_id, _matchingId) != 0) {\n            revert Errors.ReplicaFilecoinClaimIdExists(_id, _matchingId);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a replica state before function do.\n    modifier onlyCarReplicaState(\n        ICarstore _carstore,\n        uint64 _id,\n        uint64 _matchingId,\n        CarReplicaType.State _state\n    ) {\n        if (_state != _carstore.getCarReplicaState(_id, _matchingId)) {\n            revert Errors.InvalidReplicaState(_id, _matchingId);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a replica filecoin deal state before function do.\n    modifier onlyCarReplicaFilecoinDealState(\n        ICarstore _carstore,\n        IFilecoin _filecoin,\n        uint64 _id,\n        uint64 _claimId,\n        FilecoinType.DealState _filecoinDealState\n    ) {\n        if (\n            _filecoinDealState !=\n            _filecoin.getReplicaDealState(_carstore.getCarHash(_id), _claimId)\n        ) {\n            revert Errors.InvalidReplicaFilecoinDealState(_id, _claimId);\n        }\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/CommonModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @title ModifierCommon\ncontract CommonModifiers {\n    /// @dev Modifier to check if an ID is not zero.\n    modifier onlyNotZero(uint64 _value) {\n        require(_value != 0, \"Value must not be zero\");\n        _;\n    }\n\n    /// @dev Modifier to check if an address is not zero\n    modifier onlyNotZeroAddress(address _address) {\n        require(address(0) != _address, \"Address must not be zero\");\n        _;\n    }\n\n    /// @dev Modifier to check the sender's address\n    modifier onlyAddress(address allowedAddress) {\n        require(msg.sender == allowedAddress, \"Only allowed address can call\");\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/DatacapsModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n///interface\nimport {IDatacaps} from \"src/v0.8/interfaces/module/IDatacaps.sol\";\n///shared\nimport {StoragesModifiers} from \"src/v0.8/shared/modifiers/StoragesModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract DatacapsModifiers is StoragesModifiers {\n    /// @notice  validNextDatacapAllocation\n    modifier validNextDatacapAllocation(\n        IDatacaps _datacaps,\n        uint64 _matchingId\n    ) {\n        if (!_datacaps.isNextDatacapAllocationValid(_matchingId)) {\n            revert Errors.NextDatacapAllocationInvalid(_matchingId);\n        }\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/DatasetsModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n///interface\nimport {IDatasets} from \"src/v0.8/interfaces/module/IDatasets.sol\";\nimport {IDatasetsProof} from \"src/v0.8/interfaces/module/IDatasetsProof.sol\";\n///shared\nimport {CarstoreModifiers} from \"src/v0.8/shared/modifiers/CarstoreModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n\n///types\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract DatasetsModifiers is CarstoreModifiers {\n    /// @dev Modifier to ensure that a dataset metadata  with the given accessMethod exists.\n    modifier onlyDatasetMetadataExsits(\n        IDatasets _datasets,\n        string memory _accessMethod\n    ) {\n        if (!_datasets.hasDatasetMetadata(_accessMethod)) {\n            revert Errors.DatasetMetadataNotExist(_accessMethod);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that a dataset metadata with the given accessMethod not exists.\n    modifier onlyDatasetMetadataNotExsits(\n        IDatasets _datasets,\n        string memory _accessMethod\n    ) {\n        if (_datasets.hasDatasetMetadata(_accessMethod)) {\n            revert Errors.DatasetMetadataAlreadyExist(_accessMethod);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure that dataset has the special state\n    modifier onlyDatasetState(\n        IDatasets _datasets,\n        uint64 _datasetId,\n        DatasetType.State _state\n    ) {\n        if (_state != _datasets.getDatasetState(_datasetId)) {\n            revert Errors.InvalidDatasetState(_datasetId);\n        }\n        _;\n    }\n\n    /// @notice The sender of the dataset proof transaction must be the submitter of the proof.\n    modifier onlyDatasetProofSubmitterOrSubmitterNotExsits(\n        IDatasetsProof _datasetsProof,\n        uint64 _datasetId,\n        address _sender\n    ) {\n        if (\n            _datasetsProof.getDatasetProofCount(\n                _datasetId,\n                DatasetType.DataType.Source\n            ) !=\n            0 ||\n            _datasetsProof.getDatasetProofCount(\n                _datasetId,\n                DatasetType.DataType.MappingFiles\n            ) !=\n            0\n        ) {\n            if (\n                _datasetsProof.isDatasetProofSubmitter(_datasetId, _sender) !=\n                true\n            ) {\n                revert Errors.InvalidDatasetProofsSubmitter(\n                    _datasetId,\n                    _sender\n                );\n            }\n        }\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/FilplusModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n///interface\nimport {IFilplus} from \"src/v0.8/interfaces/core/IFilplus.sol\";\n///shared\nimport {CommonModifiers} from \"src/v0.8/shared/modifiers/CommonModifiers.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract FilplusModifiers is CommonModifiers {\n\n}\n"
    },
    "src/v0.8/shared/modifiers/MatchingsModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n///interface\nimport {IMatchings} from \"src/v0.8/interfaces/module/IMatchings.sol\";\nimport {IMatchingsTarget} from \"src/v0.8/interfaces/module/IMatchingsTarget.sol\";\nimport {IMatchingsBids} from \"src/v0.8/interfaces/module/IMatchingsBids.sol\";\n///shared\nimport {CarstoreModifiers} from \"src/v0.8/shared/modifiers/CarstoreModifiers.sol\";\nimport {Errors} from \"src/v0.8/shared/errors/Errors.sol\";\n///types\nimport {MatchingType} from \"src/v0.8/types/MatchingType.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract MatchingsModifiers is CarstoreModifiers {\n    /// @notice Modifier to restrict access to the matching initiator\n    modifier onlyMatchingInitiator(IMatchings _matchings, uint64 _matchingId) {\n        address initiator = _matchings.getMatchingInitiator(_matchingId);\n        if (initiator != msg.sender) {\n            revert Errors.NotMatchingInitiator(\n                _matchingId,\n                initiator,\n                msg.sender\n            );\n        }\n        _;\n    }\n\n    /// @notice Modifier to restrict access based on matching state\n    modifier onlyMatchingState(\n        IMatchings _matchings,\n        uint64 _matchingId,\n        MatchingType.State _state\n    ) {\n        MatchingType.State matchingState = _matchings.getMatchingState(\n            _matchingId\n        );\n        if (matchingState != _state) {\n            revert Errors.InvalidMatchingState(\n                _matchingId,\n                _state,\n                matchingState\n            );\n        }\n        _;\n    }\n\n    /// @notice Modifier to restrict access to the matching target\n    modifier onlyMatchingsTarget(\n        IMatchingsTarget _matchingsTarget,\n        uint64 _matchingId\n    ) {\n        if (address(_matchingsTarget) != msg.sender) {\n            revert Errors.NotMatchingsTarget(_matchingId, msg.sender);\n        }\n        _;\n    }\n    /// @notice Modifier to restrict access to the matching target\n    modifier onlyMatchingsBids(\n        IMatchingsBids _matchingsBids,\n        uint64 _matchingId\n    ) {\n        if (address(_matchingsBids) != msg.sender) {\n            revert Errors.NotMatchingsTarget(_matchingId, msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Modifier to restrict access to the matching initiator\n    modifier onlyMatchingContainsCar(\n        IMatchingsTarget _matchingsTarget,\n        uint64 _matchingId,\n        uint64 _id\n    ) {\n        if (!_matchingsTarget.isMatchingContainsCar(_matchingId, _id)) {\n            revert Errors.ReplicaNotExist(_id, _matchingId);\n        }\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/RolesModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {CommonModifiers} from \"src/v0.8/shared/modifiers/CommonModifiers.sol\";\n\n/// @title RolesModifier\ncontract RolesModifiers is CommonModifiers {\n    modifier onlyRole(IRoles _roles, bytes32 _role) {\n        // roles.checkRole(_role);\n        require(\n            _roles.hasRole(_role, msg.sender),\n            \"Only allowed role can call\"\n        );\n        _;\n    }\n}\n"
    },
    "src/v0.8/shared/modifiers/StoragesModifiers.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n///shared\nimport {MatchingsModifiers} from \"src/v0.8/shared/modifiers/MatchingsModifiers.sol\";\n\n/// @title storages\n/// @dev Manages the storage of matched data after successful matching with Filecoin storage deals.\ncontract StoragesModifiers is MatchingsModifiers {\n\n}\n"
    },
    "src/v0.8/shared/utils/array/ArrayLIB.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary ArrayUint16LIB {\n    /// @notice Retrieve the count of unique elements in an array.\n    function countUniqueElements(\n        uint16[] memory _elements\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n        uint16[] memory uniques = new uint16[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Retrieve the count of unique elements in an array and the array of unique elements after deduplication.\n    /// @return The count of unique elements and the array of unique elements after deduplication.\n    function uniqueElements(\n        uint16[] memory _elements\n    ) internal pure returns (uint256, uint16[] memory) {\n        uint256 uniqueCount = 0;\n        uint16[] memory uniques = new uint16[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        // Create a new array with only unique elements\n        uint16[] memory result = new uint16[](uniqueCount);\n        for (uint256 i = 0; i < uniqueCount; i++) {\n            result[i] = uniques[i];\n        }\n\n        return (uniqueCount, result);\n    }\n\n    /// @notice The number of times a particular element appears in an array.\n    function countOccurrences(\n        uint16[] memory _elements,\n        uint16 _target\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == _target) {\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Calculate the number of elements remaining after removing a specific element from an array.\n    /// @return The count of elements remaining.\n    function countAfterRemoval(\n        uint16[] memory _elements,\n        uint16 _elementToRemove\n    ) internal pure returns (uint256) {\n        uint256 countRemaining = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                countRemaining++;\n            }\n        }\n        return countRemaining;\n    }\n\n    /// @notice Remove a specific element from an array.\n    /// @return The modified array with the specified element removed.\n    function removeElement(\n        uint16[] memory _elements,\n        uint16 _elementToRemove\n    ) internal pure returns (uint256, uint16[] memory) {\n        uint16[] memory updatedArray = new uint16[](_elements.length);\n\n        uint256 newSize = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                updatedArray[newSize] = _elements[i];\n                newSize++;\n            }\n        }\n\n        // Create a new array with only the elements that are not equal to _elementToRemove\n        uint16[] memory result = new uint16[](newSize);\n        for (uint256 i = 0; i < newSize; i++) {\n            result[i] = updatedArray[i];\n        }\n\n        return (newSize, result);\n    }\n\n    /// @notice Check if an array has duplicate elements.\n    /// @return True if there are duplicates, false otherwise.\n    function hasDuplicates(\n        uint16[] memory _elements\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            for (uint256 j = i + 1; j < _elements.length; j++) {\n                if (_elements[i] == _elements[j]) {\n                    return true; // Found a duplicate element\n                }\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /// @notice Check if a specified element exists in the array.\n    function isContains(\n        uint16[] memory _elements,\n        uint16 target\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nlibrary ArrayUint32LIB {\n    /// @notice Retrieve the count of unique elements in an array.\n    function countUniqueElements(\n        uint32[] memory _elements\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n        uint32[] memory uniques = new uint32[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Retrieve the count of unique elements in an array and the array of unique elements after deduplication.\n    /// @return The count of unique elements and the array of unique elements after deduplication.\n    function uniqueElements(\n        uint32[] memory _elements\n    ) internal pure returns (uint256, uint32[] memory) {\n        uint256 uniqueCount = 0;\n        uint32[] memory uniques = new uint32[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        // Create a new array with only unique elements\n        uint32[] memory result = new uint32[](uniqueCount);\n        for (uint256 i = 0; i < uniqueCount; i++) {\n            result[i] = uniques[i];\n        }\n\n        return (uniqueCount, result);\n    }\n\n    /// @notice The number of times a particular element appears in an array.\n    function countOccurrences(\n        uint32[] memory _elements,\n        uint32 _target\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == _target) {\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Calculate the number of elements remaining after removing a specific element from an array.\n    /// @return The count of elements remaining.\n    function countAfterRemoval(\n        uint32[] memory _elements,\n        uint32 _elementToRemove\n    ) internal pure returns (uint256) {\n        uint256 countRemaining = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                countRemaining++;\n            }\n        }\n        return countRemaining;\n    }\n\n    /// @notice Remove a specific element from an array.\n    /// @return The modified array with the specified element removed.\n    function removeElement(\n        uint32[] memory _elements,\n        uint32 _elementToRemove\n    ) internal pure returns (uint256, uint32[] memory) {\n        uint32[] memory updatedArray = new uint32[](_elements.length);\n\n        uint256 newSize = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                updatedArray[newSize] = _elements[i];\n                newSize++;\n            }\n        }\n\n        // Create a new array with only the elements that are not equal to _elementToRemove\n        uint32[] memory result = new uint32[](newSize);\n        for (uint256 i = 0; i < newSize; i++) {\n            result[i] = updatedArray[i];\n        }\n\n        return (newSize, result);\n    }\n\n    /// @notice Check if an array has duplicate elements.\n    /// @return True if there are duplicates, false otherwise.\n    function hasDuplicates(\n        uint32[] memory _elements\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            for (uint256 j = i + 1; j < _elements.length; j++) {\n                if (_elements[i] == _elements[j]) {\n                    return true; // Found a duplicate element\n                }\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /// @notice Check if a specified element exists in the array.\n    function isContains(\n        uint32[] memory _elements,\n        uint32 target\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nlibrary ArrayUint64LIB {\n    /// @notice Retrieve the count of unique elements in an array.\n    function countUniqueElements(\n        uint64[] memory _elements\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n        uint64[] memory uniques = new uint64[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Retrieve the count of unique elements in an array and the array of unique elements after deduplication.\n    /// @return The count of unique elements and the array of unique elements after deduplication.\n    function uniqueElements(\n        uint64[] memory _elements\n    ) internal pure returns (uint256, uint64[] memory) {\n        uint256 uniqueCount = 0;\n        uint64[] memory uniques = new uint64[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        // Create a new array with only unique elements\n        uint64[] memory result = new uint64[](uniqueCount);\n        for (uint256 i = 0; i < uniqueCount; i++) {\n            result[i] = uniques[i];\n        }\n\n        return (uniqueCount, result);\n    }\n\n    /// @notice The number of times a particular element appears in an array.\n    function countOccurrences(\n        uint64[] memory _elements,\n        uint64 _target\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == _target) {\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Calculate the number of elements remaining after removing a specific element from an array.\n    /// @return The count of elements remaining.\n    function countAfterRemoval(\n        uint64[] memory _elements,\n        uint64 _elementToRemove\n    ) internal pure returns (uint256) {\n        uint256 countRemaining = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                countRemaining++;\n            }\n        }\n        return countRemaining;\n    }\n\n    /// @notice Remove a specific element from an array.\n    /// @return The modified array with the specified element removed.\n    function removeElement(\n        uint64[] memory _elements,\n        uint64 _elementToRemove\n    ) internal pure returns (uint256, uint64[] memory) {\n        uint64[] memory updatedArray = new uint64[](_elements.length);\n\n        uint256 newSize = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                updatedArray[newSize] = _elements[i];\n                newSize++;\n            }\n        }\n\n        // Create a new array with only the elements that are not equal to _elementToRemove\n        uint64[] memory result = new uint64[](newSize);\n        for (uint256 i = 0; i < newSize; i++) {\n            result[i] = updatedArray[i];\n        }\n\n        return (newSize, result);\n    }\n\n    /// @notice Check if an array has duplicate elements.\n    /// @return True if there are duplicates, false otherwise.\n    function hasDuplicates(\n        uint64[] memory _elements\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            for (uint256 j = i + 1; j < _elements.length; j++) {\n                if (_elements[i] == _elements[j]) {\n                    return true; // Found a duplicate element\n                }\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /// @notice Check if a specified element exists in the array.\n    function isContains(\n        uint64[] memory _elements,\n        uint64 target\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nlibrary ArrayAddressLIB {\n    /// @notice Retrieve the count of unique elements in an array.\n    function countUniqueElements(\n        address[] memory _elements\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n        address[] memory uniques = new address[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Retrieve the count of unique elements in an array and the array of unique elements after deduplication.\n    /// @return The count of unique elements and the array of unique elements after deduplication.\n    function uniqueElements(\n        address[] memory _elements\n    ) internal pure returns (uint256, address[] memory) {\n        uint256 uniqueCount = 0;\n        address[] memory uniques = new address[](_elements.length);\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            bool isUnique = true;\n            for (uint256 j = 0; j < uniqueCount; j++) {\n                if (_elements[i] == uniques[j]) {\n                    isUnique = false;\n                    break;\n                }\n            }\n            if (isUnique) {\n                uniques[uniqueCount] = _elements[i];\n                uniqueCount++;\n            }\n        }\n\n        // Create a new array with only unique elements\n        address[] memory result = new address[](uniqueCount);\n        for (uint256 i = 0; i < uniqueCount; i++) {\n            result[i] = uniques[i];\n        }\n\n        return (uniqueCount, result);\n    }\n\n    /// @notice The number of times a particular element appears in an array.\n    function countOccurrences(\n        address[] memory _elements,\n        address _target\n    ) internal pure returns (uint256) {\n        uint256 uniqueCount = 0;\n\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == _target) {\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    /// @notice Calculate the number of elements remaining after removing a specific element from an array.\n    /// @return The count of elements remaining.\n    function countAfterRemoval(\n        address[] memory _elements,\n        address _elementToRemove\n    ) internal pure returns (uint256) {\n        uint256 countRemaining = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                countRemaining++;\n            }\n        }\n        return countRemaining;\n    }\n\n    /// @notice Remove a specific element from an array.\n    /// @return The modified array with the specified element removed.\n    function removeElement(\n        address[] memory _elements,\n        address _elementToRemove\n    ) internal pure returns (uint256, address[] memory) {\n        address[] memory updatedArray = new address[](_elements.length);\n\n        uint256 newSize = 0;\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] != _elementToRemove) {\n                updatedArray[newSize] = _elements[i];\n                newSize++;\n            }\n        }\n\n        // Create a new array with only the elements that are not equal to _elementToRemove\n        address[] memory result = new address[](newSize);\n        for (uint256 i = 0; i < newSize; i++) {\n            result[i] = updatedArray[i];\n        }\n\n        return (newSize, result);\n    }\n\n    /// @notice Check if an array has duplicate elements.\n    /// @return True if there are duplicates, false otherwise.\n    function hasDuplicates(\n        address[] memory _elements\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            for (uint256 j = i + 1; j < _elements.length; j++) {\n                if (_elements[i] == _elements[j]) {\n                    return true; // Found a duplicate element\n                }\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /// @notice Check if a specified element exists in the array.\n    function isContains(\n        address[] memory _elements,\n        address target\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _elements.length; i++) {\n            if (_elements[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/v0.8/shared/utils/cid/CidUtils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @title CidUtils\nlibrary CidUtils {\n    /// @notice Convert a bytes32 hash to a CID.\n    /// @dev This function converts a bytes32 hash to a CID using the specified encoding.\n    /// @return The CID corresponding to the input hash.\n    function hashToCID(bytes32 _hash) internal pure returns (bytes memory) {\n        // Hardcoded, to be refined for full implementation.\n        // From https://github.com/filecoin-project/go-fil-commcid/blob/master/commcid.go#CommitmentToCID\n        uint64 filCommitmentUnsealed = 0xf101;\n        uint64 sha256Trunc254Padded = 0x1012;\n\n        bytes memory fBuf = bytes.concat(\n            putUvarint(1),\n            putUvarint(filCommitmentUnsealed)\n        );\n\n        bytes memory result = bytes.concat(\n            putUvarint(sha256Trunc254Padded),\n            putUvarint(_hash.length)\n        );\n        result = bytes.concat(result, _hash);\n\n        return bytes.concat(fBuf, result);\n    }\n\n    /// @notice Convert an array of bytes32 hashes to an array of CIDs.\n    /// @dev This function converts an array of bytes32 hashes to an array of CIDs using the specified encoding.\n    /// @param _hashes The array of bytes32 hashes to convert.\n    /// @return The array of CIDs corresponding to the input hashes.\n    function hashesToCIDs(\n        bytes32[] memory _hashes\n    ) internal pure returns (bytes[] memory) {\n        bytes[] memory cids = new bytes[](_hashes.length);\n        for (uint256 i = 0; i < _hashes.length; i++) {\n            cids[i] = hashToCID(bytes32(_hashes[i]));\n        }\n        return cids;\n    }\n\n    /// @notice Function to encode an unsigned integer as a Uvarint byte array\n    /// @dev Encode an unsigned integer as a Uvarint byte array\n    /// @param _x input parameter an unsigned integer\n    /// @return the return of Uvarint byte array\n    function putUvarint(uint64 _x) public pure returns (bytes memory) {\n        uint8 i = 0;\n        uint8[] memory buffer = new uint8[](10); // Requires up to 10 bytes\n\n        while (_x >= 0x80) {\n            buffer[i] = uint8(_x) | 0x80;\n            _x >>= 7;\n            i++;\n        }\n        buffer[i] = uint8(_x);\n\n        bytes memory result = new bytes(i + 1);\n        for (uint8 j = 0; j <= i; j++) {\n            result[j] = bytes1(buffer[j]);\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/v0.8/shared/utils/merkle/MerkleUtils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport {IRoles} from \"src/v0.8/interfaces/core/IRoles.sol\";\nimport {RolesType} from \"src/v0.8/types/RolesType.sol\";\nimport {RolesModifiers} from \"src/v0.8/shared/modifiers/RolesModifiers.sol\";\nimport {IMerkleUtils} from \"src/v0.8/interfaces/utils/IMerkleUtils.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title MerkleUtils\ncontract MerkleUtils is\n    Initializable,\n    UUPSUpgradeable,\n    IMerkleUtils,\n    RolesModifiers\n{\n    IRoles private roles;\n\n    /// @notice initialize function to initialize the contract and grant the default admin role to the deployer.\n    function initialize(address _roles) public initializer {\n        roles = IRoles(_roles);\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice UUPS Upgradeable function to update the roles implementation\n    /// @dev Only triggered by contract admin\n    function _authorizeUpgrade(\n        address newImplementation\n    )\n        internal\n        override\n        onlyRole(roles, RolesType.DEFAULT_ADMIN_ROLE) // solhint-disable-next-line\n    {}\n\n    /// @notice Returns the implementation contract\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Validate a Merkle proof.\n    /// @dev This function checks if a given Merkle proof is valid.\n    function isValidMerkleProof(\n        bytes32 _root,\n        bytes32 _leaf,\n        bytes32[] memory _siblings,\n        uint32 _path\n    ) external pure returns (bool) {\n        return processProof(_siblings, _path, _leaf) == _root;\n    }\n\n    /// @notice processProof generate proof root hash\n    /// @dev Generate proof root hash to verify\n    /// @param _siblings Merkle proof _siblings\n    /// @param _path Merkle proof _path\n    /// @param _leaf Merkle proof _leaf\n    /// @return Merkle proof rootHash\n    function processProof(\n        bytes32[] memory _siblings,\n        uint32 _path,\n        bytes32 _leaf\n    ) internal pure returns (bytes32) {\n        bytes32 computedHash = _leaf;\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            if ((_path & 1) == 1) {\n                computedHash = _hashFunction(\n                    concatHash(computedHash, _siblings[i])\n                );\n            } else {\n                computedHash = _hashFunction(\n                    concatHash(_siblings[i], computedHash)\n                );\n            }\n            _path >>= 1;\n        }\n        return computedHash;\n    }\n\n    /// @notice concatHash concatenates two bytes32, b1 and b2, in a sorted order.\n    /// @dev Concatenates two bytes32, b1 and b2, in a sorted order.\n    /// @param _b1 concat first hash.\n    /// @param _b2 concat second hash.\n    /// @return concat hash value.\n    function concatHash(\n        bytes32 _b1,\n        bytes32 _b2\n    ) internal pure returns (bytes memory) {\n        return bytes.concat(_b1, _b2);\n    }\n\n    /// @notice Hash generate function\n    /// @dev Hash generate function\n    /// @param _data Input hash generate value.\n    /// @return Output hash generate value.\n    function _hashFunction(bytes memory _data) internal pure returns (bytes32) {\n        bytes32 result = sha256(_data);\n\n        // Extract the byte to modify\n        bytes32 intermediate = result & (~bytes32(uint256(0xFF)));\n        // Add the modified byte\n        result = result & (intermediate | bytes32(uint256(0x3F)));\n\n        return result;\n    }\n\n    /// @notice Mock function\n    function setMockValidState(\n        bool _state // solhint-disable-next-line\n    ) external {}\n}\n"
    },
    "src/v0.8/types/CarReplicaType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @title CarReplicaType Library\n/// @notice This library defines data structures and enums related to car replicas and their states.\n/// @dev This library provides enums for different states and events related to car replicas.\nlibrary CarReplicaType {\n    /// @notice Enum representing the possible states of a car replica.\n    enum State {\n        None, //justify if Replica exsits\n        Matched, // Replica has been matched for storage\n        Stored, // Replica has been successfully stored\n        StorageFailed, // The filecoin claim id's verification failed.\n        Slashed, // The filecoin storage has been slashed.\n        Expired // The filecoin storage has expired.\n    }\n\n    /// @notice Enum representing the events associated with car replicas.\n    enum Event {\n        MatchingFailed, // Matching for a replica has been failed\n        MatchingCompleted, // Matching for a replica has been completed\n        StorageCompleted, // Storage for a replica has been completed\n        StorageFailed, // Storage for a replica has failed\n        StorageDealExpired, // Storage for a replica has expired\n        StorageSlashed // Storage for a replica has been slashed\n    }\n\n    /// @notice Struct representing a car replica.\n    struct Replica {\n        uint64 matchingId; // The matchingId associated with the replica.\n        uint64 filecoinClaimId; // ID of the Filecoin claim associated with the replica's storage\n        State state; // Current state of the replica\n    }\n\n    /// @notice Struct representing a car and its associated replicas.\n    struct Car {\n        uint64 id; // The id associated with the car.\n        uint64 datasetId; // Index of approved dataset\n        uint64 size; //car size\n        mapping(uint64 => uint16) replicaIndex; // Mapping from matchingId => Replica index\n        Replica[] replicas; // replicas associated with the car.\n    }\n}\n"
    },
    "src/v0.8/types/DatasetDAOType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @notice Enum: Proposal Types\nenum ProposalType {\n    MetadataAudit, // Proposal for Metadata Audit\n    MetadataDispute, // Proposal for Metadata Dispute\n    DatasetAudit, // Proposal for Dataset Audit\n    DatasetDispute, // Proposal for Dataset Dispute\n    DatasetMappingFilesDisput // Proposal for Dataset MappingFiles Disputee\n}\n\n/// @notice Struct: Proposal\nstruct Proposal {\n    uint64 datasetId; // ID of the dataset\n    ProposalType proposalType; // Type of the proposal\n}\n"
    },
    "src/v0.8/types/DatasetType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {GeolocationType} from \"src/v0.8/types/GeolocationType.sol\";\n\n/// @title DatasetType Library\n/// @notice This library defines data structures for managing datasets, their metadata, states, and events.\nlibrary DatasetType {\n    /// @notice Enum representing the possible states of a dataset.\n    enum State {\n        None, // No specific state.\n        MetadataSubmitted, // Metadata submitted but not approved.\n        MetadataApproved, // Metadata has been approved.\n        MetadataRejected, // Metadata submission has been rejected.\n        CollateralNotEnough, // Not enough collateral when submit proof or challenge proof.\n        DatasetProofSubmitted, // Proof of dataset submitted.\n        DatasetApproved // Dataset has been approved.\n    }\n\n    /// @notice Enum representing the events related to dataset management.\n    enum Event {\n        SubmitMetadata, // Metadata submission event.\n        MetadataApproved, // Metadata approval event.\n        MetadataRejected, // Metadata rejection event.\n        NotEnoughCollateral, // Dataset not enough collateral event.\n        EnoughCollateral, // Dataset enough collateral event.\n        SubmitDatasetProof, // Dataset proof submission event.\n        DatasetApproved, // Dataset approval event.\n        DatasetRejected // Dataset rejection event.\n    }\n\n    /// @notice Enum representing the type of data associated with a matching.\n    enum DataType {\n        Source, // Matching is associated with a dataset\n        MappingFiles // Matching is associated with mapping files\n    }\n\n    /// @notice Struct representing metadata associated with a dataset.\n    struct Metadata {\n        string title; // Title of the dataset.\n        string industry; // Industry category of the dataset.\n        string name; // Name of the dataset.\n        string description; // Description of the dataset.\n        string source; // Source of the dataset.\n        string accessMethod; // Method of accessing the dataset (e.g., URL, API).\n        address submitter; // Address of the dataset's submitter.\n        uint64 client; // Filecoin actor id of the dataset's client.\n        uint64 createdBlockNumber; // Block number at which the dataset was created.\n        uint64 sizeInBytes; // Size of the dataset in bytes.\n        bool isPublic; // Boolean indicating if the dataset is public.\n        uint64 version; // Version number of the dataset.\n    }\n\n    struct Dataset {\n        Metadata metadata;\n        State state; // Current state of the dataset.\n    }\n\n    /// @notice Struct representing proofs associated with a dataset challenge submitted by reviewers.\n    struct Proof {\n        uint64 datasetSize;\n        bytes32 rootHash; // Root hash of the data's Merkle tree.\n        bool allCompleted;\n        uint64 leafHashesCount;\n        uint64[] leafHashes; // Proof associated with the dataset.\n    }\n\n    struct DatasetProof {\n        //proof\n        string mappingFilesAccessMethod; // Method of accessing data (e.g., URL, API).\n        Proof sourceProof; // Proof associated with the dataset.\n        Proof mappingFilesProof; // Note:mappingFiles includes mappingFiles and CarMerkleTree,Proof associated with the dataset.\n        address proofSubmitter; // Address of the dataset proof's submitter.\n    }\n\n    /// @notice Struct representing proofs associated with a dataset challenge submitted by reviewers.\n    struct Challenge {\n        bytes32 leaf;\n        bytes32[] siblings;\n        uint32 path;\n    }\n\n    /// @notice Struct representing verification details of a dataset.\n    struct ChallengeProof {\n        uint64 randomSeed; // Random seed used for verification. This seed determines which nodes need to be challenged.\n        Challenge[] challenges; // Merkle proof provided by the auditor to support their challenge.\n    }\n\n    struct DatasetChallengeProof {\n        // challenges\n        uint16 challengesCount;\n        mapping(address => ChallengeProof) challengeProofs; // Address of the auditor who submits challenges.\n        address[] auditors; // Records of auditors submitting verifications.\n    }\n\n    /// @notice The struct describes the storage requirements specified by the client.\n    struct ReplicaRequirement {\n        address[] dataPreparers; // The client can specify DP or choose not to specify\n        address[] storageProviders; //The client can specify SP or choose not to specify.\n        GeolocationType.Geolocation geolocations; // Geolocation requested by the client.\n    }\n\n    struct DatasetReplicasRequirement {\n        ReplicaRequirement[] replicasRequirement; // Replica requirements requested by the client.\n    }\n}\n"
    },
    "src/v0.8/types/DataswapStorageType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title Dataswap Storage Types Library\n/// @notice This library defines enums and structs related to dataswap storage service.\nlibrary DataswapStorageType {\n    /// @notice Enum representing dataswap storage environments.\n    enum Environment {\n        Normal,\n        MockFilecoinAndMerkle,\n        MockFilecoin,\n        MockMerkle,\n        EndIdentifier\n    }\n}\n"
    },
    "src/v0.8/types/EscrowType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title EscrowType Library\n/// @notice This library defines escrow type within the system.\nlibrary EscrowType {\n    /// @notice Enum escrow object types.\n    enum Type {\n        DatacapCollateral, // The storage client collateral.\n        DatacapChunkCollateral, // The storage provider collateral.\n        DataAuditCollateral, // The data auditor collateral, for dispute\n        DataPrepareCollateral, // The data preparer collateral,for dispute\n        DataAuditFee, // The data auditor calculate fees.\n        DataPrepareFeeByClient, // The data preparer calculate fees paid by storage client.\n        DataPrepareFeeByProvider // The data preparer calculate fees paid by storage provider.\n    }\n\n    /// @notice Enum representing the events related to collateral management.\n    enum CollateralEvent {\n        SyncBurn, // Escrow synchronize collateral burn event.\n        SyncCollateral // Escrow synchronize collateral event.\n    }\n\n    /// @notice Enum representing the events related to payment management.\n    enum PaymentEvent {\n        SyncPaymentRefund, // Escrow synchronize payment refund event.\n        SyncPaymentCollateral, // Escrow synchronize payment collateral event.\n        SyncPaymentBeneficiaries // Escrow synchronize payment beneficiaries list.\n    }\n\n    /// @notice Struct the beneficiary of escrow\n    struct Fund {\n        uint256 total; // Total amount in fund account\n        uint256 lock; // Lock amount in fund account for payment beneficiaries\n        uint256 collateral; // Collateral amount in fund account for withdraw and punishment\n        uint256 burned; // burned amount in fund account\n        uint64 createdBlockNumber; // Fund account created block number\n    }\n\n    /// @notice Struct the escrow\n    struct Escrow {\n        Fund owner; // fund owner\n        address[] beneficiariesList; // Retrieves beneficiaries list\n        mapping(address beneficiary => Fund) beneficiaries; // Beneficiaries information\n    }\n}\n"
    },
    "src/v0.8/types/FilecoinType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\nlibrary FilecoinType {\n    /// @notice Enum representing the possible states of a Filecoin storage deal.\n    enum DealState {\n        Stored, // The filecoin deal's verification was successful.\n        StorageFailed, // The filecoin deal's verification failed.\n        Slashed, // The filecoin deal has been slashed.\n        Expired // The filecoin deal has expired.\n    }\n\n    /// @notice filecoin network type\n    enum Network {\n        Mainnet,\n        CalibrationTestnet,\n        EndIdentifier\n    }\n}\n"
    },
    "src/v0.8/types/GeolocationType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.21;\n\n/// @title GeolocationType Library\n/// @notice This library defines common data structures used for geolocation information.\n/// @dev This library provides structs to represent geolocation details.\nlibrary GeolocationType {\n    /// @notice Struct representing geolocation information.\n    struct Geolocation {\n        uint16 regionCode; // Code representing the region\n        uint16 countryCode; // Code representing the country\n        uint32[] cityCodes; // Code representing the city\n    }\n}\n"
    },
    "src/v0.8/types/GovernanceType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n"
    },
    "src/v0.8/types/MatchingType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\nimport {DatasetType} from \"src/v0.8/types/DatasetType.sol\";\n\n/// @title MatchingType Library\n/// @notice This library defines data structures and enums related to dataset matching and their states.\nlibrary MatchingType {\n    /// @notice Enum representing the possible states of a dataset matching.\n    enum State {\n        None,\n        Published, // Matching is published and open for bids\n        InProgress, // Matching is currently in progress\n        Paused, // Matching is paused\n        Closed, // Matching is closed and no longer accepting bids\n        Completed, // Matching is completed\n        Cancelled, // Matching is cancelled\n        Failed // Matching has failed\n    }\n\n    /// @notice Enum representing the events associated with dataset matching.\n    enum Event {\n        Publish, // Matching is published\n        FilPlusCheckSuccessed, // Fil+ check succeeded\n        FilPlusCheckFailed, // Fil+ check failed\n        Pause, // Matching is paused\n        PauseExpired, // Pause period expired\n        Resume, // Matching is resumed\n        Cancel, // Matching is cancelled\n        Close, // Matching is closed\n        HasWinner, // Matching has a winner\n        NoWinner // No winner in the matching\n    }\n\n    /// @notice Enum representing the rules for determining the winning bid.\n    enum BidSelectionRule {\n        HighestBid, // Note: Auction, Winner is determined by the highest bid\n        LowestBid, // Note: Tender, Winner is determined by the lowest bid\n        ImmediateAtLeast, // Note: Auction Immediate winning condition: Bid amount is at least the threshold\n        ImmediateAtMost // Note: Render Immediate winning condition: Bid amount is at most the threshold\n    }\n\n    /// @notice Struct representing a dataset matching.\n    struct Matching {\n        BidSelectionRule bidSelectionRule;\n        uint64 biddingDelayBlockCount; // Number of blocks to delay bidding\n        uint64 biddingPeriodBlockCount; // Number of blocks for bidding period\n        uint64 storageCompletionPeriodBlocks; // Number of blocks for storage period, representing the duration of the storage completion time period.\n        uint256 biddingThreshold; // Threshold for bidding\n        uint64 createdBlockNumber; // Block number at which the matching was created\n        string additionalInfo; // Additional information about the matching\n        address initiator; // Address of the initiator of the matching\n        uint64 pausedBlockCount; // Number of blocks to paused\n        State state; // Current state of the matching\n    }\n\n    /// @notice Struct representing the target of a matching.\n    struct MatchingTarget {\n        uint64 datasetId; // ID of the dataset associated with the matching\n        uint64[] cars; // Array of car IDs associated with the matching\n        uint64 size; // Size of the matching target，Note:total datacap size that this matching need allocate\n        DatasetType.DataType dataType; // Type of data associated with the matching\n        uint64 associatedMappingFilesMatchingID; // ID of the matching associated with mapping files\n        uint16 replicaIndex; // index of dataset's replica\n    }\n\n    /// @notice Struct representing a bid in a matching.\n    struct Bid {\n        address bidder; // Address of the bidder\n        uint256 bid; // Bid amount\n        bool complyFilplusRule; //If the bidder comply with filplus rules\n    }\n\n    /// @notice Struct representing a bids of matching.\n    struct MatchingBids {\n        Bid[] bids; // Array of bids in the matching\n        address winner; // Address of the winner in the matching\n    }\n}\n"
    },
    "src/v0.8/types/RolesType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @title RolesType Library\n/// @notice This library defines constants for different roles within the system.\nlibrary RolesType {\n    /// @notice Default admin role\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /// @notice Bytes32 constant representing the role of a storage provider.\n    bytes32 public constant STORAGE_PROVIDER = keccak256(\"SP\");\n\n    /// @notice Bytes32 constant representing the role of a retrieve provider.\n    bytes32 public constant RETRIEVE_PROVIDER = keccak256(\"RP\");\n\n    /// @notice Bytes32 constant representing the role of a compute provider.\n    bytes32 public constant COMPUTE_PROVIDER = keccak256(\"CP\");\n\n    /// @notice Bytes32 constant representing the role of a metadata dataset provider.\n    bytes32 public constant METADATA_DATASET_PROVIDER = keccak256(\"MDP\");\n\n    /// @notice Bytes32 constant representing the role of a dataset provider.\n    bytes32 public constant DATASET_PROVIDER = keccak256(\"DP\");\n\n    /// @notice Bytes32 constant representing the role of a metadata dataset auditor.\n    bytes32 public constant METADATA_DATASET_AUDITOR = keccak256(\"MDA\");\n\n    /// @notice Bytes32 constant representing the role of a dataset auditor.\n    bytes32 public constant DATASET_AUDITOR = keccak256(\"DA\");\n\n    /// @notice Bytes32 constant representing the role of a reviewer client.\n    bytes32 public constant REVIEWER_CLIENT = keccak256(\"RC\");\n\n    /// @notice Bytes32 constant representing the role of a compute client.\n    bytes32 public constant COMPUTE_CLIENT = keccak256(\"CC\");\n}\n"
    },
    "src/v0.8/types/StorageType.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Dataswap\n *\n *  Licensed under the GNU General Public License, Version 3.0 or later (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.gnu.org/licenses/gpl-3.0.en.html\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.21;\n\n/// @notice This library defines enums and structs related to storage deals and their states.\nlibrary StorageType {\n    /// @notice Struct representing a storage deal.\n    struct Storage {\n        uint64[] doneCars;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/AccountAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/AccountTypes.sol\";\nimport \"./cbor/AccountCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to the Account actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary AccountAPI {\n    using AccountCBOR for *;\n    using BytesCBOR for bytes;\n\n    /// @notice Authenticates whether the provided signature is valid for the provided message.\n    /// @dev Should be called with the raw bytes of a signature, NOT a serialized Signature object that includes a SignatureType.\n    /// @dev Errors if the authentication is invalid.\n    /// @param target The account actor id you want to interact with\n    /// @param params message to be authenticated\n    function authenticateMessage(CommonTypes.FilActorId target, AccountTypes.AuthenticateMessageParams memory params) internal {\n        bytes memory raw_request = params.serializeAuthenticateMessageParams();\n\n        bytes memory data = Actor.callNonSingletonByID(target, AccountTypes.AuthenticateMessageMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n        require(data.deserializeBool());\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/AccountCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/AccountTypes.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Account actor exported methods.\n/// @author Zondax AG\nlibrary AccountCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    /// @notice serialize AuthenticateMessageParams struct to cbor in order to pass as arguments to an account actor\n    /// @param params AuthenticateMessageParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeAuthenticateMessageParams(AccountTypes.AuthenticateMessageParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.signature);\n        capacity += Misc.getBytesSize(params.message);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.signature);\n        buf.writeBytes(params.message);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize AuthenticateMessageParams struct from cbor encoded bytes coming from an account actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of AuthenticateMessageParams created based on parsed data\n    function deserializeAuthenticateMessageParams(bytes memory rawResp) internal pure returns (AccountTypes.AuthenticateMessageParams memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.signature, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.message, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for BigInt type\n/// @author Zondax AG\nlibrary BigIntCBOR {\n    /// @notice serialize BigInt instance to bytes\n    /// @param num BigInt instance to serialize\n    /// @return serialized BigInt as bytes\n    function serializeBigInt(CommonTypes.BigInt memory num) internal pure returns (bytes memory) {\n        bytes memory raw = new bytes(num.val.length + 1);\n\n        raw[0] = num.neg == true ? bytes1(0x01) : bytes1(0x00);\n\n        uint index = 1;\n        for (uint i = 0; i < num.val.length; i++) {\n            raw[index] = num.val[i];\n            index++;\n        }\n\n        return raw;\n    }\n\n    /// @notice deserialize big int (encoded as bytes) to BigInt instance\n    /// @param raw as bytes to parse\n    /// @return parsed BigInt instance\n    function deserializeBigInt(bytes memory raw) internal pure returns (CommonTypes.BigInt memory) {\n        if (raw.length == 0) {\n            return CommonTypes.BigInt(hex\"00\", false);\n        }\n\n        bytes memory val = new bytes(raw.length - 1);\n        bool neg = false;\n\n        if (raw[0] == 0x01) {\n            neg = true;\n        }\n\n        for (uint i = 1; i < raw.length; i++) {\n            val[i - 1] = raw[i];\n        }\n\n        return CommonTypes.BigInt(val, neg);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/BytesCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"../types/CommonTypes.sol\";\n\nimport \"./BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for bytes\n/// @author Zondax AG\nlibrary BytesCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    /// @notice serialize raw bytes as cbor bytes string encoded\n    /// @param data raw data in bytes\n    /// @return encoded cbor bytes\n    function serializeBytes(bytes memory data) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getBytesSize(data);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeBytes(data);\n\n        return buf.data();\n    }\n\n    /// @notice serialize raw address (in bytes) as cbor bytes string encoded (how an address is passed to filecoin actors)\n    /// @param addr raw address in bytes\n    /// @return encoded address as cbor bytes\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        return serializeBytes(addr);\n    }\n\n    /// @notice encoded null value as cbor\n    /// @return cbor encoded null\n    function serializeNull() internal pure returns (bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(1);\n\n        buf.writeNull();\n\n        return buf.data();\n    }\n\n    /// @notice deserialize cbor encoded filecoin address to bytes\n    /// @param ret cbor encoded filecoin address\n    /// @return raw bytes representing a filecoin address\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n\n    /// @notice deserialize cbor encoded string\n    /// @param ret cbor encoded string (in bytes)\n    /// @return decoded string\n    function deserializeString(bytes memory ret) internal pure returns (string memory) {\n        string memory response;\n        uint byteIdx = 0;\n\n        (response, byteIdx) = ret.readString(byteIdx);\n\n        return response;\n    }\n\n    /// @notice deserialize cbor encoded bool\n    /// @param ret cbor encoded bool (in bytes)\n    /// @return decoded bool\n    function deserializeBool(bytes memory ret) internal pure returns (bool) {\n        bool response;\n        uint byteIdx = 0;\n\n        (response, byteIdx) = ret.readBool(byteIdx);\n\n        return response;\n    }\n\n    /// @notice deserialize cbor encoded BigInt\n    /// @param ret cbor encoded BigInt (in bytes)\n    /// @return decoded BigInt\n    /// @dev BigInts are cbor encoded as bytes string first. That is why it unwraps the cbor encoded bytes first, and then parse the result into BigInt\n    function deserializeBytesBigInt(bytes memory ret) internal pure returns (CommonTypes.BigInt memory) {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        if (ret.length > 0) {\n            (tmp, byteIdx) = ret.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                return tmp.deserializeBigInt();\n            }\n        }\n\n        return CommonTypes.BigInt(new bytes(0), false);\n    }\n\n    /// @notice deserialize cbor encoded uint64\n    /// @param rawResp cbor encoded uint64 (in bytes)\n    /// @return decoded uint64\n    function deserializeUint64(bytes memory rawResp) internal pure returns (uint64) {\n        uint byteIdx = 0;\n        uint64 value;\n\n        (value, byteIdx) = rawResp.readUInt64(byteIdx);\n        return value;\n    }\n\n    /// @notice deserialize cbor encoded int64\n    /// @param rawResp cbor encoded int64 (in bytes)\n    /// @return decoded int64\n    function deserializeInt64(bytes memory rawResp) internal pure returns (int64) {\n        uint byteIdx = 0;\n        int64 value;\n\n        (value, byteIdx) = rawResp.readInt64(byteIdx);\n        return value;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/DataCapCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/CommonTypes.sol\";\nimport \"../types/DataCapTypes.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"./BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for DataCap actor exported methods.\n/// @author Zondax AG\nlibrary DataCapCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for CommonTypes.BigInt;\n    using BigIntCBOR for bytes;\n\n    /// @notice serialize GetAllowanceParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params GetAllowanceParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeGetAllowanceParams(DataCapTypes.GetAllowanceParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.owner.data);\n        capacity += Misc.getBytesSize(params.operator.data);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.owner.data);\n        buf.writeBytes(params.operator.data);\n\n        return buf.data();\n    }\n\n    /// @notice serialize TransferParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params TransferParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeTransferParams(DataCapTypes.TransferParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory amount = params.amount.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(3);\n        capacity += Misc.getBytesSize(params.to.data);\n        capacity += Misc.getBytesSize(amount);\n        capacity += Misc.getBytesSize(params.operator_data);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(3);\n        buf.writeBytes(params.to.data);\n        buf.writeBytes(amount);\n        buf.writeBytes(params.operator_data);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize TransferReturn struct from cbor encoded bytes coming from a datacap actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of TransferReturn created based on parsed data\n    function deserializeTransferReturn(bytes memory rawResp) internal pure returns (DataCapTypes.TransferReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.from_balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.to_balance = tmp.deserializeBigInt();\n\n        (ret.recipient_data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize TransferFromParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params TransferFromParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeTransferFromParams(DataCapTypes.TransferFromParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory amount = params.amount.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(4);\n        capacity += Misc.getBytesSize(params.from.data);\n        capacity += Misc.getBytesSize(params.to.data);\n        capacity += Misc.getBytesSize(amount);\n        capacity += Misc.getBytesSize(params.operator_data);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(4);\n        buf.writeBytes(params.from.data);\n        buf.writeBytes(params.to.data);\n        buf.writeBytes(amount);\n        buf.writeBytes(params.operator_data);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize TransferFromReturn struct from cbor encoded bytes coming from a datacap actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of TransferFromReturn created based on parsed data\n    function deserializeTransferFromReturn(bytes memory rawResp) internal pure returns (DataCapTypes.TransferFromReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 4);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.from_balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.to_balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.allowance = tmp.deserializeBigInt();\n\n        (ret.recipient_data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize IncreaseAllowanceParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params IncreaseAllowanceParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeIncreaseAllowanceParams(DataCapTypes.IncreaseAllowanceParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory increase = params.increase.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.operator.data);\n        capacity += Misc.getBytesSize(increase);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.operator.data);\n        buf.writeBytes(increase);\n\n        return buf.data();\n    }\n\n    /// @notice serialize DecreaseAllowanceParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params DecreaseAllowanceParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeDecreaseAllowanceParams(DataCapTypes.DecreaseAllowanceParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory decrease = params.decrease.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.operator.data);\n        capacity += Misc.getBytesSize(decrease);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.operator.data);\n        buf.writeBytes(decrease);\n\n        return buf.data();\n    }\n\n    /// @notice serialize BurnFromParams struct to cbor in order to pass as arguments to the datacap actor\n    /// @param params BurnFromParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeBurnFromParams(DataCapTypes.BurnFromParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory amount = params.amount.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.owner.data);\n        capacity += Misc.getBytesSize(amount);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.owner.data);\n        buf.writeBytes(amount);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize BurnFromReturn struct from cbor encoded bytes coming from a datacap actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of BurnFromReturn created based on parsed data\n    function deserializeBurnFromReturn(bytes memory rawResp) internal pure returns (DataCapTypes.BurnFromReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.allowance = tmp.deserializeBigInt();\n\n        return ret;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/FilecoinCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"../types/CommonTypes.sol\";\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for general data types on the filecoin network.\n/// @author Zondax AG\nlibrary FilecoinCBOR {\n    using Buffer for Buffer.buffer;\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for *;\n    using BigIntCBOR for *;\n\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant TAG_TYPE_CID_CODE = 42;\n    uint8 private constant PAYLOAD_LEN_8_BITS = 24;\n\n    /// @notice Write a CID into a CBOR buffer.\n    /// @dev The CBOR major will be 6 (type 'tag') and the tag type value is 42, as per CBOR tag assignments.\n    /// @dev https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml\n    /// @param buf buffer containing the actual CBOR serialization process\n    /// @param value CID value to serialize as CBOR\n    function writeCid(CBOR.CBORBuffer memory buf, bytes memory value) internal pure {\n        buf.buf.appendUint8(uint8(((MAJOR_TYPE_TAG << 5) | PAYLOAD_LEN_8_BITS)));\n        buf.buf.appendUint8(TAG_TYPE_CID_CODE);\n        // See https://ipld.io/specs/codecs/dag-cbor/spec/#links for explanation on 0x00 prefix.\n        buf.writeBytes(bytes.concat(hex'00', value));\n    }\n\n    function readCid(bytes memory cborData, uint byteIdx) internal pure returns (CommonTypes.Cid memory, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = cborData.parseCborHeader(byteIdx);\n        require(maj == MAJOR_TYPE_TAG, \"expected major type tag when parsing cid\");\n        require(value == TAG_TYPE_CID_CODE, \"expected tag 42 when parsing cid\");\n\n        bytes memory raw;\n        (raw, byteIdx) = cborData.readBytes(byteIdx);\n        require(raw[0] == 0x00, \"expected first byte to be 0 when parsing cid\");\n\n        // Pop off the first byte, which corresponds to the historical multibase 0x00 byte.\n        // https://ipld.io/specs/codecs/dag-cbor/spec/#links\n        CommonTypes.Cid memory ret;\n        ret.data = new bytes(raw.length - 1);\n        for (uint256 i = 1; i < raw.length; i++) {\n            ret.data[i-1] = raw[i];\n        }\n\n        return (ret, byteIdx);\n    }\n\n    /// @notice serialize filecoin address to cbor encoded\n    /// @param addr filecoin address to serialize\n    /// @return cbor serialized data as bytes\n    function serializeAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getBytesSize(addr.data);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeBytes(addr.data);\n\n        return buf.data();\n    }\n\n    /// @notice serialize a BigInt value wrapped in a cbor fixed array.\n    /// @param value BigInt to serialize as cbor inside an\n    /// @return cbor serialized data as bytes\n    function serializeArrayBigInt(CommonTypes.BigInt memory value) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory valueBigInt = value.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getBytesSize(valueBigInt);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(value.serializeBigInt());\n\n        return buf.data();\n    }\n\n    /// @notice serialize a FilAddress value wrapped in a cbor fixed array.\n    /// @param addr FilAddress to serialize as cbor inside an\n    /// @return cbor serialized data as bytes\n    function serializeArrayFilAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getBytesSize(addr.data);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(addr.data);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize a FilAddress wrapped on a cbor fixed array coming from a actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of FilAddress created based on parsed data\n    function deserializeArrayFilAddress(bytes memory rawResp) internal pure returns (CommonTypes.FilAddress memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        require(len == 1, \"Wrong numbers of parameters (should find 1)\");\n\n        (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice deserialize a BigInt wrapped on a cbor fixed array coming from a actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of BigInt created based on parsed data\n    function deserializeArrayBigInt(bytes memory rawResp) internal pure returns (CommonTypes.BigInt memory) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        return tmp.deserializeBigInt();\n    }\n\n    /// @notice serialize UniversalReceiverParams struct to cbor in order to pass as arguments to an actor\n    /// @param params UniversalReceiverParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeUniversalReceiverParams(CommonTypes.UniversalReceiverParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getPrefixSize(params.type_);\n        capacity += Misc.getBytesSize(params.payload);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.type_);\n        buf.writeBytes(params.payload);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize UniversalReceiverParams cbor to struct when receiving a message\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of UniversalReceiverParams created based on parsed data\n    function deserializeUniversalReceiverParams(bytes memory rawResp) internal pure returns (CommonTypes.UniversalReceiverParams memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        require(len == 2, \"Wrong numbers of parameters (should find 2)\");\n\n        (ret.type_, byteIdx) = rawResp.readUInt32(byteIdx);\n        (ret.payload, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n\n    /// @notice attempt to read a FilActorId value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a FilActorId decoded from input bytes and the byte index after moving past the value\n    function readFilActorId(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.FilActorId, uint) {\n        uint64 tmp = 0;\n\n        (tmp, byteIdx) = rawResp.readUInt64(byteIdx);\n        return (CommonTypes.FilActorId.wrap(tmp), byteIdx);\n    }\n\n    /// @notice write FilActorId into a cbor buffer\n    /// @dev FilActorId is just wrapping a uint64\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param id FilActorId to serialize as cbor\n    function writeFilActorId(CBOR.CBORBuffer memory buf, CommonTypes.FilActorId id) internal pure {\n        buf.writeUInt64(CommonTypes.FilActorId.unwrap(id));\n    }\n\n    /// @notice attempt to read a ChainEpoch value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a ChainEpoch decoded from input bytes and the byte index after moving past the value\n    function readChainEpoch(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.ChainEpoch, uint) {\n        int64 tmp = 0;\n\n        (tmp, byteIdx) = rawResp.readInt64(byteIdx);\n        return (CommonTypes.ChainEpoch.wrap(tmp), byteIdx);\n    }\n\n    /// @notice write ChainEpoch into a cbor buffer\n    /// @dev ChainEpoch is just wrapping a int64\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param id ChainEpoch to serialize as cbor\n    function writeChainEpoch(CBOR.CBORBuffer memory buf, CommonTypes.ChainEpoch id) internal pure {\n        buf.writeInt64(CommonTypes.ChainEpoch.unwrap(id));\n    }\n\n    /// @notice write DealLabel into a cbor buffer\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param label DealLabel to serialize as cbor\n    function writeDealLabel(CBOR.CBORBuffer memory buf, CommonTypes.DealLabel memory label) internal pure {\n        label.isString ? buf.writeString(string(label.data)) : buf.writeBytes(label.data);\n    }\n\n    /// @notice deserialize DealLabel cbor to struct when receiving a message\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of DealLabel created based on parsed data\n    function deserializeDealLabel(bytes memory rawResp) internal pure returns (CommonTypes.DealLabel memory) {\n        uint byteIdx = 0;\n        CommonTypes.DealLabel memory label;\n\n        (label, byteIdx) = readDealLabel(rawResp, byteIdx);\n        return label;\n    }\n\n    /// @notice attempt to read a DealLabel value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a DealLabel decoded from input bytes and the byte index after moving past the value\n    function readDealLabel(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.DealLabel memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = CBORDecoder.parseCborHeader(rawResp, byteIdx);\n        require(maj == MajByteString || maj == MajTextString, \"invalid maj (expected MajByteString or MajTextString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = rawResp[i];\n            slice_index++;\n        }\n\n        return (CommonTypes.DealLabel(slice, maj == MajTextString), byteIdx + len);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/IntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for uint64 type\n/// @author Zondax AG\nlibrary Uint64CBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    /// @notice serialize uint64 to cbor\n    /// @param id value to serialize\n    /// @return cbor encoded bytes\n    function serialize(uint64 id) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getPrefixSize(uint256(id));\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeUInt64(id);\n\n        return buf.data();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/MarketTypes.sol\";\nimport \"../types/CommonTypes.sol\";\n\nimport \"../utils/Misc.sol\";\nimport \"../utils/FilAddresses.sol\";\nimport \"../utils/CborDecode.sol\";\n\nimport \"./FilecoinCbor.sol\";\nimport \"./BigIntCbor.sol\";\nimport \"./FilecoinCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Market actor exported methods.\n/// @author Zondax AG\nlibrary MarketCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice serialize WithdrawBalanceParams struct to cbor in order to pass as arguments to the market actor\n    /// @param params WithdrawBalanceParams to serialize as cbor\n    /// @return response cbor serialized data as bytes\n    function serializeWithdrawBalanceParams(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory tokenAmount = params.tokenAmount.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.provider_or_client.data);\n        capacity += Misc.getBytesSize(tokenAmount);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.provider_or_client.data);\n        buf.writeBytes(tokenAmount);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize GetBalanceReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetBalanceReturn created based on parsed data\n    function deserializeGetBalanceReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetBalanceReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.locked = tmp.deserializeBigInt();\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealDataCommitmentReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealDataCommitmentReturn created based on parsed data\n    function deserializeGetDealDataCommitmentReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealDataCommitmentReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n\n        if (len > 0) {\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\n        } else {\n            ret.data = new bytes(0);\n            ret.size = 0;\n        }\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealTermReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealTermReturn created based on parsed data\n    function deserializeGetDealTermReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealTermReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.start, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.end, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealActivationReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealActivationReturn created based on parsed data\n    function deserializeGetDealActivationReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealActivationReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.activated, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.terminated, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize PublishStorageDealsParams struct to cbor in order to pass as arguments to the market actor\n    /// @param params PublishStorageDealsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializePublishStorageDealsParams(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getPrefixSize(params.deals.length);\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            capacity += Misc.getPrefixSize(2);\n            capacity += Misc.getPrefixSize(11);\n\n            capacity += Misc.getCidSize(params.deals[i].proposal.piece_cid.data);\n            capacity += Misc.getPrefixSize(params.deals[i].proposal.piece_size);\n            capacity += Misc.getBoolSize();\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client.data);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider.data);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.label.data);\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.start_epoch);\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.end_epoch);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider_collateral.serializeBigInt());\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client_collateral.serializeBigInt());\n\n            capacity += Misc.getBytesSize(params.deals[i].client_signature);\n        }\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.deals.length));\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            buf.startFixedArray(2);\n\n            buf.startFixedArray(11);\n\n            buf.writeCid(params.deals[i].proposal.piece_cid.data);\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\n            buf.writeBool(params.deals[i].proposal.verified_deal);\n            buf.writeBytes(params.deals[i].proposal.client.data);\n            buf.writeBytes(params.deals[i].proposal.provider.data);\n            buf.writeDealLabel(params.deals[i].proposal.label);\n            buf.writeChainEpoch(params.deals[i].proposal.start_epoch);\n            buf.writeChainEpoch(params.deals[i].proposal.end_epoch);\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigInt());\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigInt());\n\n            buf.writeBytes(params.deals[i].client_signature);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize PublishStorageDealsReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of PublishStorageDealsReturn created based on parsed data\n    function deserializePublishStorageDealsReturn(bytes memory rawResp) internal pure returns (MarketTypes.PublishStorageDealsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.ids = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize deal id (uint64) to cbor in order to pass as arguments to the market actor\n    /// @param id deal id to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeDealID(uint64 id) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getPrefixSize(uint256(id));\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeUInt64(id);\n\n        return buf.data();\n    }\n\n    function deserializeMarketDealNotifyParams(bytes memory rawResp) internal pure returns (MarketTypes.MarketDealNotifyParams memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.dealProposal, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.dealId, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n\n    function serializeDealProposal(MarketTypes.DealProposal memory dealProposal) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory storage_price_per_epoch = dealProposal.storage_price_per_epoch.serializeBigInt();\n        bytes memory provider_collateral = dealProposal.provider_collateral.serializeBigInt();\n        bytes memory client_collateral = dealProposal.client_collateral.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(11);\n        capacity += Misc.getCidSize(dealProposal.piece_cid.data);\n        capacity += Misc.getPrefixSize(dealProposal.piece_size);\n        capacity += Misc.getBoolSize();\n        capacity += Misc.getBytesSize(dealProposal.client.data);\n        capacity += Misc.getBytesSize(dealProposal.provider.data);\n        capacity += Misc.getBytesSize(dealProposal.label.data);\n        capacity += Misc.getChainEpochSize(dealProposal.start_epoch);\n        capacity += Misc.getChainEpochSize(dealProposal.end_epoch);\n        capacity += Misc.getBytesSize(storage_price_per_epoch);\n        capacity += Misc.getBytesSize(provider_collateral);\n        capacity += Misc.getBytesSize(client_collateral);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(11);\n\n        buf.writeCid(dealProposal.piece_cid.data);\n        buf.writeUInt64(dealProposal.piece_size);\n        buf.writeBool(dealProposal.verified_deal);\n        buf.writeBytes(dealProposal.client.data);\n        buf.writeBytes(dealProposal.provider.data);\n        buf.writeDealLabel(dealProposal.label);\n        buf.writeChainEpoch(dealProposal.start_epoch);\n        buf.writeChainEpoch(dealProposal.end_epoch);\n        buf.writeBytes(storage_price_per_epoch);\n        buf.writeBytes(provider_collateral);\n        buf.writeBytes(client_collateral);\n\n        return buf.data();\n    }\n\n    function deserializeDealProposal(bytes memory rawResp) internal pure returns (MarketTypes.DealProposal memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 11);\n\n        (ret.piece_cid, byteIdx) = rawResp.readCid(byteIdx);\n        (ret.piece_size, byteIdx) = rawResp.readUInt64(byteIdx);\n        (ret.verified_deal, byteIdx) = rawResp.readBool(byteIdx);\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.client = FilAddresses.fromBytes(tmp);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.provider = FilAddresses.fromBytes(tmp);\n\n        (ret.label, byteIdx) = rawResp.readDealLabel(byteIdx);\n\n        (ret.start_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.end_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        bytes memory storage_price_per_epoch_bytes;\n        (storage_price_per_epoch_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.storage_price_per_epoch = storage_price_per_epoch_bytes.deserializeBigInt();\n\n        bytes memory provider_collateral_bytes;\n        (provider_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.provider_collateral = provider_collateral_bytes.deserializeBigInt();\n\n        bytes memory client_collateral_bytes;\n        (client_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.client_collateral = client_collateral_bytes.deserializeBigInt();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/MinerCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"./BigIntCbor.sol\";\nimport \"./FilecoinCbor.sol\";\n\nimport \"../types/MinerTypes.sol\";\nimport \"../types/CommonTypes.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Miner actor exported methods.\n/// @author Zondax AG\nlibrary MinerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice serialize ChangeBeneficiaryParams struct to cbor in order to pass as arguments to the miner actor\n    /// @param params ChangeBeneficiaryParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeChangeBeneficiaryParams(MinerTypes.ChangeBeneficiaryParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory new_quota = params.new_quota.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(3);\n        capacity += Misc.getBytesSize(params.new_beneficiary.data);\n        capacity += Misc.getBytesSize(new_quota);\n        capacity += Misc.getChainEpochSize(params.new_expiration);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(3);\n        buf.writeBytes(params.new_beneficiary.data);\n        buf.writeBytes(new_quota);\n        buf.writeChainEpoch(params.new_expiration);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize GetOwnerReturn struct from cbor encoded bytes coming from a miner actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetOwnerReturn created based on parsed data\n    function deserializeGetOwnerReturn(bytes memory rawResp) internal pure returns (MinerTypes.GetOwnerReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.owner.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (ret.proposed.data, byteIdx) = rawResp.readBytes(byteIdx);\n        } else {\n            ret.proposed.data = new bytes(0);\n        }\n\n        return ret;\n    }\n\n    /// @notice deserialize GetBeneficiaryReturn struct from cbor encoded bytes coming from a miner actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetBeneficiaryReturn created based on parsed data\n    function deserializeGetBeneficiaryReturn(bytes memory rawResp) internal pure returns (MinerTypes.GetBeneficiaryReturn memory ret) {\n        bytes memory tmp;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.active.beneficiary.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.quota = tmp.deserializeBigInt();\n        } else {\n            ret.active.term.quota = CommonTypes.BigInt(new bytes(0), false);\n        }\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.used_quota = tmp.deserializeBigInt();\n        } else {\n            ret.active.term.used_quota = CommonTypes.BigInt(new bytes(0), false);\n        }\n\n        (ret.active.term.expiration, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 5);\n\n            (ret.proposed.new_beneficiary.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                ret.proposed.new_quota = tmp.deserializeBigInt();\n            } else {\n                ret.proposed.new_quota = CommonTypes.BigInt(new bytes(0), false);\n            }\n\n            (ret.proposed.new_expiration, byteIdx) = rawResp.readChainEpoch(byteIdx);\n            (ret.proposed.approved_by_beneficiary, byteIdx) = rawResp.readBool(byteIdx);\n            (ret.proposed.approved_by_nominee, byteIdx) = rawResp.readBool(byteIdx);\n        }\n\n        return ret;\n    }\n\n    /// @notice deserialize GetVestingFundsReturn struct from cbor encoded bytes coming from a miner actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetVestingFundsReturn created based on parsed data\n    function deserializeGetVestingFundsReturn(bytes memory rawResp) internal pure returns (MinerTypes.GetVestingFundsReturn memory ret) {\n        CommonTypes.ChainEpoch epoch;\n        CommonTypes.BigInt memory amount;\n        bytes memory tmp;\n\n        uint byteIdx = 0;\n        uint len;\n        uint leni;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.vesting_funds = new MinerTypes.VestingFunds[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (leni, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(leni == 2);\n\n            (epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n\n            amount = tmp.deserializeBigInt();\n            ret.vesting_funds[i] = MinerTypes.VestingFunds(epoch, amount);\n        }\n\n        return ret;\n    }\n\n    /// @notice serialize ChangeWorkerAddressParams struct to cbor in order to pass as arguments to the miner actor\n    /// @param params ChangeWorkerAddressParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeChangeWorkerAddressParams(MinerTypes.ChangeWorkerAddressParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.new_worker.data);\n        capacity += Misc.getPrefixSize(uint256(params.new_control_addresses.length));\n        for (uint64 i = 0; i < params.new_control_addresses.length; i++) {\n            capacity += Misc.getBytesSize(params.new_control_addresses[i].data);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.new_worker.data);\n        buf.startFixedArray(uint64(params.new_control_addresses.length));\n\n        for (uint64 i = 0; i < params.new_control_addresses.length; i++) {\n            buf.writeBytes(params.new_control_addresses[i].data);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice serialize ChangeMultiaddrsParams struct to cbor in order to pass as arguments to the miner actor\n    /// @param params ChangeMultiaddrsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeChangeMultiaddrsParams(MinerTypes.ChangeMultiaddrsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getPrefixSize(uint256(params.new_multi_addrs.length));\n        for (uint64 i = 0; i < params.new_multi_addrs.length; i++) {\n            capacity += Misc.getBytesSize(params.new_multi_addrs[i].data);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.new_multi_addrs.length));\n\n        for (uint64 i = 0; i < params.new_multi_addrs.length; i++) {\n            buf.writeBytes(params.new_multi_addrs[i].data);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize GetMultiaddrsReturn struct from cbor encoded bytes coming from a miner actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetMultiaddrsReturn created based on parsed data\n    function deserializeGetMultiaddrsReturn(bytes memory rawResp) internal pure returns (MinerTypes.GetMultiaddrsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.multi_addrs = new CommonTypes.FilAddress[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.multi_addrs[i].data, byteIdx) = rawResp.readBytes(byteIdx);\n        }\n\n        return ret;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/PowerCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/CommonTypes.sol\";\nimport \"../types/PowerTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Power actor exported methods.\n/// @author Zondax AG\nlibrary PowerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for CommonTypes.BigInt;\n    using BigIntCBOR for bytes;\n\n    /// @notice serialize CreateMinerParams struct to cbor in order to pass as arguments to the power actor\n    /// @param params CreateMinerParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeCreateMinerParams(PowerTypes.CreateMinerParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        uint multiaddrsLen = params.multiaddrs.length;\n\n        capacity += Misc.getPrefixSize(5);\n        capacity += Misc.getBytesSize(params.owner.data);\n        capacity += Misc.getBytesSize(params.worker.data);\n        capacity += Misc.getPrefixSize(uint256(params.window_post_proof_type));\n        capacity += Misc.getBytesSize(params.peer.data);\n        capacity += Misc.getPrefixSize(multiaddrsLen);\n        for (uint i = 0; i < multiaddrsLen; i++) {\n            capacity += Misc.getBytesSize(params.multiaddrs[i].data);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(5);\n        buf.writeBytes(params.owner.data);\n        buf.writeBytes(params.worker.data);\n        buf.writeInt64(int64(uint64(params.window_post_proof_type)));\n        buf.writeBytes(params.peer.data);\n        buf.startFixedArray(uint64(multiaddrsLen));\n        for (uint i = 0; i < multiaddrsLen; i++) {\n            buf.writeBytes(params.multiaddrs[i].data);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize CreateMinerReturn struct from cbor encoded bytes coming from a power actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of CreateMinerReturn created based on parsed data\n    function deserializeCreateMinerReturn(bytes memory rawResp) internal pure returns (PowerTypes.CreateMinerReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.id_address.data, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.robust_address.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice deserialize MinerRawPowerReturn struct from cbor encoded bytes coming from a power actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of MinerRawPowerReturn created based on parsed data\n    function deserializeMinerRawPowerReturn(bytes memory rawResp) internal pure returns (PowerTypes.MinerRawPowerReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.raw_byte_power = tmp.deserializeBigInt();\n        } else {\n            ret.raw_byte_power = CommonTypes.BigInt(new bytes(0), false);\n        }\n\n        (ret.meets_consensus_minimum, byteIdx) = rawResp.readBool(byteIdx);\n\n        return ret;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/cbor/VerifRegCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/CommonTypes.sol\";\nimport \"../types/VerifRegTypes.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"./BigIntCbor.sol\";\nimport \"./FilecoinCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for VerifReg actor exported methods.\n/// @author Zondax AG\nlibrary VerifRegCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice serialize GetClaimsParams struct to cbor in order to pass as arguments to the verified registry actor\n    /// @param params GetClaimsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeGetClaimsParams(VerifRegTypes.GetClaimsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        uint claimIdsLen = params.claim_ids.length;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getFilActorIdSize(params.provider);\n        capacity += Misc.getPrefixSize(claimIdsLen);\n        for (uint i = 0; i < claimIdsLen; i++) {\n            capacity += Misc.getFilActorIdSize(params.claim_ids[i]);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeFilActorId(params.provider);\n        buf.startFixedArray(uint64(claimIdsLen));\n        for (uint i = 0; i < claimIdsLen; i++) {\n            buf.writeFilActorId(params.claim_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize GetClaimsReturn struct from cbor encoded bytes coming from a verified registry actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetClaimsReturn created based on parsed data\n    function deserializeGetClaimsReturn(bytes memory rawResp) internal pure returns (VerifRegTypes.GetClaimsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.batch_info.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.batch_info.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.batch_info.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.batch_info.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.claims = new VerifRegTypes.Claim[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 8);\n\n            (ret.claims[i].provider, byteIdx) = rawResp.readFilActorId(byteIdx);\n            (ret.claims[i].client, byteIdx) = rawResp.readFilActorId(byteIdx);\n            (ret.claims[i].data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.claims[i].size, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.claims[i].term_min, byteIdx) = rawResp.readChainEpoch(byteIdx);\n            (ret.claims[i].term_max, byteIdx) = rawResp.readChainEpoch(byteIdx);\n            (ret.claims[i].term_start, byteIdx) = rawResp.readChainEpoch(byteIdx);\n            (ret.claims[i].sector, byteIdx) = rawResp.readFilActorId(byteIdx);\n        }\n\n        return ret;\n    }\n\n    /// @notice serialize AddVerifiedClientParams struct to cbor in order to pass as arguments to the verified registry actor\n    /// @param params AddVerifiedClientParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeAddVerifiedClientParams(VerifRegTypes.AddVerifiedClientParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory allowance = params.allowance.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.addr.data);\n        capacity += Misc.getBytesSize(allowance);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.addr.data);\n        buf.writeBytes(allowance);\n\n        return buf.data();\n    }\n\n    /// @notice serialize RemoveExpiredAllocationsParams struct to cbor in order to pass as arguments to the verified registry actor\n    /// @param params RemoveExpiredAllocationsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeRemoveExpiredAllocationsParams(VerifRegTypes.RemoveExpiredAllocationsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        uint allocationIdsLen = params.allocation_ids.length;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getFilActorIdSize(params.client);\n        capacity += Misc.getPrefixSize(allocationIdsLen);\n        for (uint i = 0; i < allocationIdsLen; i++) {\n            capacity += Misc.getFilActorIdSize(params.allocation_ids[i]);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeFilActorId(params.client);\n        buf.startFixedArray(uint64(allocationIdsLen));\n        for (uint i = 0; i < allocationIdsLen; i++) {\n            buf.writeFilActorId(params.allocation_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize RemoveExpiredAllocationsReturn struct from cbor encoded bytes coming from a verified registry actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of RemoveExpiredAllocationsReturn created based on parsed data\n    function deserializeRemoveExpiredAllocationsReturn(bytes memory rawResp) internal pure returns (VerifRegTypes.RemoveExpiredAllocationsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.considered = new CommonTypes.FilActorId[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.considered[i], byteIdx) = rawResp.readFilActorId(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.datacap_recovered = tmp.deserializeBigInt();\n\n        return ret;\n    }\n\n    /// @notice serialize ExtendClaimTermsParams struct to cbor in order to pass as arguments to the verified registry actor\n    /// @param params ExtendClaimTermsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeExtendClaimTermsParams(VerifRegTypes.ExtendClaimTermsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        uint termsLen = params.terms.length;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getPrefixSize(termsLen);\n        for (uint i = 0; i < termsLen; i++) {\n            capacity += Misc.getFilActorIdSize(params.terms[i].provider);\n            capacity += Misc.getFilActorIdSize(params.terms[i].claim_id);\n            capacity += Misc.getChainEpochSize(params.terms[i].term_max);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(termsLen));\n        for (uint i = 0; i < termsLen; i++) {\n            buf.startFixedArray(3);\n            buf.writeFilActorId(params.terms[i].provider);\n            buf.writeFilActorId(params.terms[i].claim_id);\n            buf.writeChainEpoch(params.terms[i].term_max);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize BatchReturn struct from cbor encoded bytes coming from a verified registry actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of BatchReturn created based on parsed data\n    function deserializeBatchReturn(bytes memory rawResp) internal pure returns (CommonTypes.BatchReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        return ret;\n    }\n\n    /// @notice serialize RemoveExpiredClaimsParams struct to cbor in order to pass as arguments to the verified registry actor\n    /// @param params RemoveExpiredClaimsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeRemoveExpiredClaimsParams(VerifRegTypes.RemoveExpiredClaimsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        uint claimIdsLen = params.claim_ids.length;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getFilActorIdSize(params.provider);\n        capacity += Misc.getPrefixSize(claimIdsLen);\n        for (uint i = 0; i < claimIdsLen; i++) {\n            capacity += Misc.getFilActorIdSize(params.claim_ids[i]);\n        }\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeFilActorId(params.provider);\n        buf.startFixedArray(uint64(claimIdsLen));\n        for (uint i = 0; i < claimIdsLen; i++) {\n            buf.writeFilActorId(params.claim_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize RemoveExpiredClaimsReturn struct from cbor encoded bytes coming from a verified registry actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of RemoveExpiredClaimsReturn created based on parsed data\n    function deserializeRemoveExpiredClaimsReturn(bytes memory rawResp) internal pure returns (VerifRegTypes.RemoveExpiredClaimsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.considered = new CommonTypes.FilActorId[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.considered[i], byteIdx) = rawResp.readFilActorId(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        return ret;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/DataCapAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/DataCapTypes.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./cbor/FilecoinCbor.sol\";\nimport \"./cbor/DataCapCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to the singleton DataCap actor (address: f0X). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary DataCapAPI {\n    using DataCapCBOR for *;\n    using BytesCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice Return the name of DataCap token which is 'DataCap'.\n    function name() internal returns (string memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.NameMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeString();\n    }\n\n    /// @notice Return the symbol of DataCap token which is 'DCAP'.\n    function symbol() internal returns (string memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.SymbolMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeString();\n    }\n\n    /// @notice Return the total supply of DataCap token.\n    function totalSupply() internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.TotalSupplyMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Return the DataCap token balance for the wallet address.\n    function balance(CommonTypes.FilAddress memory addr) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.BalanceOfMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Return the allowance between owner and operator address.\n    function allowance(DataCapTypes.GetAllowanceParams memory params) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = params.serializeGetAllowanceParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.AllowanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Transfers data cap tokens to an address.\n    /// @notice Data cap tokens are not generally transferable.\n    /// @notice Succeeds if the to or from address is the governor, otherwise always fails.\n    function transfer(DataCapTypes.TransferParams memory params) internal returns (DataCapTypes.TransferReturn memory) {\n        bytes memory raw_request = params.serializeTransferParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.TransferMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeTransferReturn();\n    }\n\n    /// @notice Transfers data cap tokens between addresses.\n    /// @notice Data cap tokens are not generally transferable between addresses.\n    /// @notice Succeeds if the to address is the governor, otherwise always fails.\n    function transferFrom(DataCapTypes.TransferFromParams memory params) internal returns (DataCapTypes.TransferFromReturn memory) {\n        bytes memory raw_request = params.serializeTransferFromParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.TransferFromMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeTransferFromReturn();\n    }\n\n    /// @notice Increase the DataCap token allowance that an operator can control of the owner's balance by the requested amount.\n    function increaseAllowance(DataCapTypes.IncreaseAllowanceParams memory params) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = params.serializeIncreaseAllowanceParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.IncreaseAllowanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Decrease the DataCap token allowance that an operator controls of the owner's balance by the requested amount.\n    function decreaseAllowance(DataCapTypes.DecreaseAllowanceParams memory params) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = params.serializeDecreaseAllowanceParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.DecreaseAllowanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Revoke the DataCap token allowance from the operator and set the operator's allowance in behave of owner/caller address to 0.\n    function revokeAllowance(CommonTypes.FilAddress memory operator) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = operator.serializeArrayFilAddress();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.RevokeAllowanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Burn an amount of DataCap token from the owner/caller address, decreasing total token supply.\n    function burn(CommonTypes.BigInt memory amount) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = amount.serializeArrayBigInt();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.BurnMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeArrayBigInt();\n    }\n\n    /// @notice Burn an amount of DataCap token from the specified address (owner address), decrease the allowance of operator/caller, and decrease total token supply.\n    function burnFrom(DataCapTypes.BurnFromParams memory params) internal returns (DataCapTypes.BurnFromReturn memory) {\n        bytes memory raw_request = params.serializeBurnFromParams();\n\n        bytes memory result = Actor.callByID(DataCapTypes.ActorID, DataCapTypes.BurnFromMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBurnFromReturn();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/MarketAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/MarketTypes.sol\";\nimport \"./cbor/MarketCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./cbor/FilecoinCbor.sol\";\n\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MarketAPI {\n    using BytesCBOR for bytes;\n    using MarketCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    function addBalance(CommonTypes.FilAddress memory providerOrClient, uint256 value) internal {\n        bytes memory raw_request = providerOrClient.serializeAddress();\n\n        bytes memory data = Actor.callByID(MarketTypes.ActorID, MarketTypes.AddBalanceMethodNum, Misc.CBOR_CODEC, raw_request, value, false);\n        if (data.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = params.serializeWithdrawBalanceParams();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.WithdrawBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Return the escrow balance and locked amount for an address.\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(CommonTypes.FilAddress memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetBalanceReturn();\n    }\n\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    /// @return the data commitment and size of a deal proposal.\n    function getDealDataCommitment(uint64 dealID) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealDataCommitmentMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealDataCommitmentReturn();\n    }\n\n    /// @notice get the client of the deal proposal.\n    /// @return the client of a deal proposal.\n    function getDealClient(uint64 dealID) internal returns (uint64) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @notice get the provider of a deal proposal.\n    /// @return the provider of a deal proposal.\n    function getDealProvider(uint64 dealID) internal returns (uint64) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @notice Get the label of a deal proposal.\n    /// @return the label of a deal proposal.\n    function getDealLabel(uint64 dealID) internal returns (CommonTypes.DealLabel memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealLabelMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeDealLabel();\n    }\n\n    /// @notice Get the start epoch and duration(in epochs) of a deal proposal.\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(uint64 dealID) internal returns (MarketTypes.GetDealTermReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTermMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealTermReturn();\n    }\n\n    /// @notice get the total price that will be paid from the client to the provider for this deal.\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTotalPriceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the client collateral requirement for a deal proposal.\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the provide collateral requirement for a deal proposal.\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    /// @return the verified flag for a deal proposal.\n    function getDealVerified(uint64 dealID) internal returns (bool) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealVerifiedMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBool();\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(uint64 dealID) internal returns (MarketTypes.GetDealActivationReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealActivationMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealActivationReturn();\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(MarketTypes.PublishStorageDealsParams memory params) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\n        bytes memory raw_request = params.serializePublishStorageDealsParams();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.PublishStorageDealsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializePublishStorageDealsReturn();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/MinerAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/MinerTypes.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./cbor/MinerCbor.sol\";\nimport \"./cbor/FilecoinCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @notice During miner initialization, a miner actor is created on the chain, and this actor gives the miner its ID f0.... The miner actor is in charge of collecting all the payments sent to the miner.\n/// @dev For more info about the miner actor, please refer to https://lotus.filecoin.io/storage-providers/operate/addresses/\n/// @author Zondax AG\nlibrary MinerAPI {\n    using MinerCBOR for *;\n    using FilecoinCBOR for *;\n    using BytesCBOR for bytes;\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @param target The miner actor id you want to interact with\n    /// @return the owner address of a Miner\n    function getOwner(CommonTypes.FilActorId target) internal returns (MinerTypes.GetOwnerReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetOwnerMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetOwnerReturn();\n    }\n\n    /// @param target  The miner actor id you want to interact with\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function changeOwnerAddress(CommonTypes.FilActorId target, CommonTypes.FilAddress memory addr) internal {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ChangeOwnerAddressMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target  The miner actor id you want to interact with\n    /// @param addr The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function isControllingAddress(CommonTypes.FilActorId target, CommonTypes.FilAddress memory addr) internal returns (bool) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.IsControllingAddressMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBool();\n    }\n\n    /// @return the miner's sector size.\n    /// @param target The miner actor id you want to interact with\n    /// @dev For more information about sector sizes, please refer to https://spec.filecoin.io/systems/filecoin_mining/sector/#section-systems.filecoin_mining.sector\n    function getSectorSize(CommonTypes.FilActorId target) internal returns (uint64) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetSectorSizeMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function getAvailableBalance(CommonTypes.FilActorId target) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetAvailableBalanceMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function getVestingFunds(CommonTypes.FilActorId target) internal returns (MinerTypes.GetVestingFundsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetVestingFundsMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetVestingFundsReturn();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function changeBeneficiary(CommonTypes.FilActorId target, MinerTypes.ChangeBeneficiaryParams memory params) internal {\n        bytes memory raw_request = params.serializeChangeBeneficiaryParams();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ChangeBeneficiaryMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function getBeneficiary(CommonTypes.FilActorId target) internal returns (MinerTypes.GetBeneficiaryReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetBeneficiaryMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetBeneficiaryReturn();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function changeWorkerAddress(CommonTypes.FilActorId target, MinerTypes.ChangeWorkerAddressParams memory params) internal {\n        bytes memory raw_request = params.serializeChangeWorkerAddressParams();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ChangeWorkerAddressMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function changePeerId(CommonTypes.FilActorId target, CommonTypes.FilAddress memory newId) internal {\n        bytes memory raw_request = newId.serializeArrayFilAddress();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ChangePeerIDMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function changeMultiaddresses(CommonTypes.FilActorId target, MinerTypes.ChangeMultiaddrsParams memory params) internal {\n        bytes memory raw_request = params.serializeChangeMultiaddrsParams();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ChangeMultiaddrsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function repayDebt(CommonTypes.FilActorId target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.RepayDebtMethodNum, Misc.NONE_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function confirmChangeWorkerAddress(CommonTypes.FilActorId target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.ConfirmChangeWorkerAddressMethodNum, Misc.NONE_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function getPeerId(CommonTypes.FilActorId target) internal returns (CommonTypes.FilAddress memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetPeerIDMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeArrayFilAddress();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    function getMultiaddresses(CommonTypes.FilActorId target) internal returns (MinerTypes.GetMultiaddrsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.GetMultiaddrsMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetMultiaddrsReturn();\n    }\n\n    /// @param target The miner actor id you want to interact with\n    /// @param amount the amount you want to withdraw\n    function withdrawBalance(CommonTypes.FilActorId target, CommonTypes.BigInt memory amount) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = amount.serializeArrayBigInt();\n\n        bytes memory result = Actor.callNonSingletonByID(target, MinerTypes.WithdrawBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/mocks/MarketMockAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/MarketTypes.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"./types/MockTypes.sol\";\n\nimport \"src/v0.8/vendor/solidity-bignumber/src/BigNumbers.sol\";\n\n/// @title This library is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MarketMockAPI {\n    mapping(string => BigNumber) balances;\n    mapping(uint64 => MockTypes.Deal) deals;\n\n    constructor() {\n        mockGenerateDeals();\n    }\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    /// @dev Because this is a mock method, no real balance is being deducted from the caller, nor incremented in the Storage Market actor (f05).\n    function addBalance(bytes memory provider_or_client, uint256 value) public payable {\n        BigNumber memory newValue = BigNumbers.init(value, false);\n        balances[string(provider_or_client)] = BigNumbers.add(balances[string(provider_or_client)], newValue);\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    /// @dev This method should be called by an approved address, but the mock does not check that the caller is an approved party.\n    /// @dev Because this is a mock method, no real balance is deposited in the designated address, nor decremented from the Storage Market actor (f05).\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) public returns (CommonTypes.BigInt memory) {\n        BigNumber memory balance = balances[string(params.provider_or_client.data)];\n        BigNumber memory tokenAmount = BigNumbers.init(params.tokenAmount.val, params.tokenAmount.neg);\n\n        if (BigNumbers.gte(balance, tokenAmount)) {\n            balances[string(params.provider_or_client.data)] = BigNumbers.sub(balance, tokenAmount);\n            balance = tokenAmount;\n        } else {\n            balances[string(params.provider_or_client.data)] = BigNumbers.zero();\n        }\n\n        return CommonTypes.BigInt(balance.val, balance.neg);\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(bytes memory addr) public view returns (MarketTypes.GetBalanceReturn memory) {\n        BigNumber memory actualBalance = balances[string(addr)];\n        BigNumber memory zero = BigNumbers.zero();\n\n        return MarketTypes.GetBalanceReturn(CommonTypes.BigInt(actualBalance.val, actualBalance.neg), CommonTypes.BigInt(zero.val, zero.neg));\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    /// @dev set data values correctly, currently returning fixed data, feel free to adjust in your local mock.\n    function getDealDataCommitment(uint64 dealID) public view returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        require(deals[dealID].id > 0);\n\n        return MarketTypes.GetDealDataCommitmentReturn(bytes(\"0x111111\"), deals[dealID].size);\n    }\n\n    /// @return the client of a deal proposal.\n    function getDealClient(uint64 dealID) public view returns (uint64) {\n        require(deals[dealID].id > 0);\n\n        return deals[dealID].client;\n    }\n\n    /// @return the provider of a deal proposal.\n    function getDealProvider(uint64 dealID) public view returns (uint64) {\n        require(deals[dealID].id > 0);\n\n        return deals[dealID].provider;\n    }\n\n    /// @return the label of a deal proposal.\n    function getDealLabel(uint64 dealID) public view returns (string memory) {\n        require(deals[dealID].id > 0);\n\n        return deals[dealID].label;\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(uint64 dealID) public view returns (MarketTypes.GetDealTermReturn memory) {\n        require(deals[dealID].id > 0);\n\n        return MarketTypes.GetDealTermReturn(deals[dealID].start, deals[dealID].end);\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(uint64 dealID) public view returns (CommonTypes.BigInt memory) {\n        require(deals[dealID].id > 0);\n\n        BigNumber memory price_per_epoch = BigNumbers.init(deals[dealID].price_per_epoch, false);\n        return CommonTypes.BigInt(price_per_epoch.val, price_per_epoch.neg);\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(uint64 dealID) public view returns (CommonTypes.BigInt memory) {\n        require(deals[dealID].id > 0);\n\n        BigNumber memory client_collateral = BigNumbers.init(deals[dealID].client_collateral, false);\n        return CommonTypes.BigInt(client_collateral.val, client_collateral.neg);\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(uint64 dealID) public view returns (CommonTypes.BigInt memory) {\n        require(deals[dealID].id > 0);\n\n        BigNumber memory provider_collateral = BigNumbers.init(deals[dealID].provider_collateral, false);\n        return CommonTypes.BigInt(provider_collateral.val, provider_collateral.neg);\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function getDealVerified(uint64 dealID) public view returns (bool) {\n        require(deals[dealID].id > 0);\n\n        return deals[dealID].verified;\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(uint64 dealID) public view returns (MarketTypes.GetDealActivationReturn memory) {\n        require(deals[dealID].id > 0);\n\n        return MarketTypes.GetDealActivationReturn(deals[dealID].activated, deals[dealID].terminated);\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(bytes memory raw_auth_params, address callee) public {\n        // calls standard filecoin receiver on message authentication api method number\n        (bool success, ) = callee.call(abi.encodeWithSignature(\"handle_filecoin_method(uint64,uint64,bytes)\", 0, 2643134072, raw_auth_params));\n        require(success, \"client contract failed to authorize deal publish\");\n    }\n\n    /// @notice Adds mock deal data to the internal state of this mock.\n    /// @dev Feel free to adjust the data here to make it align with deals in your network.\n    function mockGenerateDeals() internal {\n        MockTypes.Deal memory deal_67;\n        deal_67.id = 67;\n        deal_67.cid = \"baga6ea4seaqlkg6mss5qs56jqtajg5ycrhpkj2b66cgdkukf2qjmmzz6ayksuci\";\n        deal_67.size = 8388608;\n        deal_67.verified = false;\n        deal_67.client = 101;\n        deal_67.provider = 103;\n        deal_67.label = \"mAXCg5AIg8YBXbFjtdBy1iZjpDYAwRSt0elGLF5GvTqulEii1VcM\";\n        deal_67.start = CommonTypes.ChainEpoch.wrap(25245);\n        deal_67.end = CommonTypes.ChainEpoch.wrap(545150);\n        deal_67.price_per_epoch = 1100000000000;\n        deal_67.provider_collateral = 0;\n        deal_67.client_collateral = 0;\n        deal_67.activated = CommonTypes.ChainEpoch.wrap(1);\n        deal_67.terminated = CommonTypes.ChainEpoch.wrap(0);\n\n        deals[deal_67.id] = deal_67;\n\n        // As EVM smart contract has a limited capacity for size (24KiB), we cannot set all deals directly here.\n        // Please, take them from docs.\n\n        // Add or replace more deals here.\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/mocks/MinerMockAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"src/v0.8/vendor/solidity-bignumber/src/BigNumbers.sol\";\n\nimport \"../types/MinerTypes.sol\";\nimport \"../types/CommonTypes.sol\";\n\n/// @title This library is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MinerMockAPI {\n    bytes owner;\n    bool isBeneficiarySet = false;\n    MinerTypes.ActiveBeneficiary activeBeneficiary;\n    mapping(MinerTypes.SectorSize => uint64) sectorSizesBytes;\n\n    /// @notice (Mock method) Sets the owner of a Miner on contract deployment, which will be returned via get_owner().\n    constructor(bytes memory _owner) {\n        owner = _owner;\n\n        sectorSizesBytes[MinerTypes.SectorSize._2KiB] = 2 << 10;\n        sectorSizesBytes[MinerTypes.SectorSize._8MiB] = 8 << 20;\n        sectorSizesBytes[MinerTypes.SectorSize._512MiB] = 512 << 20;\n        sectorSizesBytes[MinerTypes.SectorSize._32GiB] = 32 << 30;\n        sectorSizesBytes[MinerTypes.SectorSize._64GiB] = 2 * (32 << 30);\n    }\n\n    /// @notice (Mock method) Sets the owner of a Miner, which will be returned via get_owner().\n    function mockSetOwner(bytes memory addr) public {\n        require(owner.length == 0);\n        owner = addr;\n    }\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @return the owner address of a Miner\n    function getOwner() public view returns (MinerTypes.GetOwnerReturn memory) {\n        require(owner.length != 0);\n\n        bytes memory proposed = \"0x00\";\n\n        return\n            MinerTypes.GetOwnerReturn(\n                CommonTypes.FilAddress(owner),\n                CommonTypes.FilAddress(proposed)\n            );\n    }\n\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function changeOwnerAddress(bytes memory addr) public {\n        owner = addr;\n    }\n\n    /// @param addr The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function isControllingAddress(\n        CommonTypes.FilAddress memory addr\n    ) public pure returns (bool) {\n        require(addr.data[0] >= 0x00);\n\n        return false;\n    }\n\n    /// @return the miner's sector size.\n    function getSectorSize() public view returns (uint64) {\n        return sectorSizesBytes[MinerTypes.SectorSize._8MiB];\n    }\n\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function getAvailableBalance()\n        public\n        pure\n        returns (CommonTypes.BigInt memory)\n    {\n        return CommonTypes.BigInt(hex\"021E19E0C9BAB2400000\", false);\n    }\n\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function getVestingFunds()\n        public\n        pure\n        returns (MinerTypes.GetVestingFundsReturn memory)\n    {\n        MinerTypes.VestingFunds[]\n            memory vesting_funds = new MinerTypes.VestingFunds[](1);\n        vesting_funds[0] = MinerTypes.VestingFunds(\n            CommonTypes.ChainEpoch.wrap(1668514825),\n            CommonTypes.BigInt(hex\"6C6B935B8BBD400000\", false)\n        );\n\n        return MinerTypes.GetVestingFundsReturn(vesting_funds);\n    }\n\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function changeBeneficiary(\n        MinerTypes.ChangeBeneficiaryParams memory params\n    ) public {\n        if (!isBeneficiarySet) {\n            BigNumber memory zero = BigNumbers.zero();\n            MinerTypes.BeneficiaryTerm memory term = MinerTypes.BeneficiaryTerm(\n                params.new_quota,\n                CommonTypes.BigInt(zero.val, zero.neg),\n                params.new_expiration\n            );\n            activeBeneficiary = MinerTypes.ActiveBeneficiary(\n                params.new_beneficiary,\n                term\n            );\n            isBeneficiarySet = true;\n        } else {\n            activeBeneficiary.beneficiary = params.new_beneficiary;\n            activeBeneficiary.term.quota = params.new_quota;\n            activeBeneficiary.term.expiration = params.new_expiration;\n        }\n    }\n\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function getBeneficiary()\n        public\n        view\n        returns (MinerTypes.GetBeneficiaryReturn memory)\n    {\n        require(isBeneficiarySet);\n\n        MinerTypes.PendingBeneficiaryChange memory proposed;\n        return MinerTypes.GetBeneficiaryReturn(activeBeneficiary, proposed);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/mocks/tests/market.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport {MarketMockAPI} from \"../MarketMockAPI.sol\";\nimport {CommonTypes} from \"../../types/CommonTypes.sol\";\nimport {MarketTypes} from \"../../types/MarketTypes.sol\";\n\ncontract MarketTestApi {\n    address marketApiAddress;\n\n    constructor(address _marketApiAddress) {\n        marketApiAddress = _marketApiAddress;\n    }\n\n    function test_add_balance() public payable {\n        bytes memory provider_or_client = hex\"0066\";\n\n        MarketMockAPI marketApiInstance = MarketMockAPI(marketApiAddress);\n        marketApiInstance.addBalance(provider_or_client, 100);\n    }\n\n    function test_get_balance() public view {\n        bytes memory addr = hex\"0066\";\n\n        MarketMockAPI marketApiInstance = MarketMockAPI(marketApiAddress);\n        marketApiInstance.getBalance(addr);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/mocks/tests/miner.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport {MinerMockAPI} from \"../MinerMockAPI.sol\";\nimport {CommonTypes} from \"../../types/CommonTypes.sol\";\nimport {MinerTypes} from \"../../types/MinerTypes.sol\";\n\ncontract MinerTestApi {\n    address minerApiAddress;\n\n    constructor(address _minerApiAddress) {\n        minerApiAddress = _minerApiAddress;\n    }\n\n    function test_get_owner() public view {\n        MinerMockAPI marketApiInstance = MinerMockAPI(minerApiAddress);\n        marketApiInstance.getOwner();\n    }\n\n    function test_get_sector_size() public view {\n        MinerMockAPI marketApiInstance = MinerMockAPI(minerApiAddress);\n        marketApiInstance.getSectorSize();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/mocks/types/MockTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../../types/CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MockTypes {\n    struct Deal {\n        uint64 id;\n        bytes cid;\n        uint64 size;\n        bool verified;\n        uint64 client;\n        uint64 provider;\n        string label;\n        CommonTypes.ChainEpoch start;\n        CommonTypes.ChainEpoch end;\n        uint256 price_per_epoch;\n        uint256 provider_collateral;\n        uint256 client_collateral;\n        CommonTypes.ChainEpoch activated;\n        CommonTypes.ChainEpoch terminated;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/PowerAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/CommonTypes.sol\";\nimport \"./types/PowerTypes.sol\";\nimport \"./cbor/PowerCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./cbor/IntCbor.sol\";\n\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to a built-in Power actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary PowerAPI {\n    using Uint64CBOR for uint64;\n    using BytesCBOR for bytes;\n    using PowerCBOR for *;\n\n    /// @notice create a new miner for the owner address and worker address.\n    /// @param params data required to create the miner\n    /// @param value the amount of token the new miner will receive\n    function createMiner(PowerTypes.CreateMinerParams memory params, uint256 value) internal returns (PowerTypes.CreateMinerReturn memory) {\n        bytes memory raw_request = params.serializeCreateMinerParams();\n\n        bytes memory result = Actor.callByID(PowerTypes.ActorID, PowerTypes.CreateMinerMethodNum, Misc.CBOR_CODEC, raw_request, value, false);\n\n        return result.deserializeCreateMinerReturn();\n    }\n\n    /// @notice get the total number of miners created, regardless of whether or not they have any pledged storage.\n    function minerCount() internal returns (uint64) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(PowerTypes.ActorID, PowerTypes.MinerCountMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @notice get the total number of miners that have more than the consensus minimum amount of storage active.\n    function minerConsensusCount() internal returns (int64) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(PowerTypes.ActorID, PowerTypes.MinerConsensusCountMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeInt64();\n    }\n\n    /// @notice get the total raw power of the network.\n    function networkRawPower() internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory result = Actor.callByID(PowerTypes.ActorID, PowerTypes.NetworkRawPowerMethodNum, Misc.NONE_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the raw power claimed by the specified miner, and whether the miner has more than the consensus minimum amount of storage active.\n    /// @param minerID the miner id you want to get information from\n    function minerRawPower(uint64 minerID) internal returns (PowerTypes.MinerRawPowerReturn memory) {\n        bytes memory raw_request = minerID.serialize();\n\n        bytes memory result = Actor.callByID(PowerTypes.ActorID, PowerTypes.MinerRawPowerMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeMinerRawPowerReturn();\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/PrecompilesAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./types/CommonTypes.sol\";\n\n/// @title This library simplify the call of FEVM precompiles contracts.\n/// @author Zondax AG\nlibrary PrecompilesAPI {\n    address constant RESOLVE_ADDRESS_PRECOMPILE_ADDR = 0xFE00000000000000000000000000000000000001;\n    address constant LOOKUP_DELEGATED_ADDRESS_PRECOMPILE_ADDR = 0xfE00000000000000000000000000000000000002;\n\n    /// @notice an error happened trying to call the actor\n    error FailToCallActor();\n\n    /// @notice get the actor id from an actor address\n    /// @param addr actor address you want to get id from (in bytes format, not string)\n    /// @return the actor id\n    function resolveAddress(CommonTypes.FilAddress memory addr) internal view returns (uint64) {\n        (bool success, bytes memory raw_response) = address(RESOLVE_ADDRESS_PRECOMPILE_ADDR).staticcall(addr.data);\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        uint256 actor_id = abi.decode(raw_response, (uint256));\n\n        return uint64(actor_id);\n    }\n\n    /// @notice get the actor id from an eth address\n    /// @param addr eth address you want to get id from (in bytes format)\n    /// @return the actor id\n    function resolveEthAddress(address addr) internal view returns (uint64) {\n        bytes memory delegatedAddr = abi.encodePacked(hex\"040a\", addr);\n\n        (bool success, bytes memory raw_response) = address(RESOLVE_ADDRESS_PRECOMPILE_ADDR).staticcall(delegatedAddr);\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        uint256 actor_id = abi.decode(raw_response, (uint256));\n\n        return uint64(actor_id);\n    }\n\n    /// @notice get the actor delegated address (f4) from an actor id\n    /// @param actor_id actor id you want to get the delegated address (f4) from\n    /// @return delegated address in bytes format (not string)\n    function lookupDelegatedAddress(uint64 actor_id) internal view returns (bytes memory) {\n        (bool success, bytes memory raw_response) = address(LOOKUP_DELEGATED_ADDRESS_PRECOMPILE_ADDR).staticcall(abi.encodePacked(uint256(actor_id)));\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        return raw_response;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/SendAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\nimport \"./types/CommonTypes.sol\";\n\n/// @title This library is helper method to send funds to some specific address. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary SendAPI {\n    /// @notice send token to a specific actor\n    /// @param target The id address (uint64) you want to send funds to\n    /// @param value tokens to be transferred to the receiver\n    function send(CommonTypes.FilActorId target, uint256 value) internal {\n        bytes memory result = Actor.callByID(target, 0, Misc.NONE_CODEC, new bytes(0), value, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @notice send token to a specific actor\n    /// @param target The address you want to send funds to\n    /// @param value tokens to be transferred to the receiver\n    function send(CommonTypes.FilAddress memory target, uint256 value) internal {\n        bytes memory result = Actor.callByAddress(target.data, 0, Misc.NONE_CODEC, new bytes(0), value, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/account.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/AccountTypes.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"../AccountAPI.sol\";\nimport \"../Utils.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the account actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract AccountApiTest {\n    function authenticate_message(CommonTypes.FilActorId target, AccountTypes.AuthenticateMessageParams memory params) public {\n        AccountAPI.authenticateMessage(target, params);\n    }\n\n    function universal_receiver_hook(CommonTypes.FilActorId target, CommonTypes.UniversalReceiverParams memory params) public {\n        Utils.universalReceiverHook(target, params);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/address.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"../utils/FilAddresses.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Address lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract AddressTest {\n    function actorid_conversion() public pure {\n        uint64 actorID = 1;\n        CommonTypes.FilAddress memory result = FilAddresses.fromActorID(actorID);\n\n        require(keccak256(result.data) == keccak256(hex\"0001\"), \"'1' actorID is not returning '0001'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/bigints.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"src/v0.8/vendor/solidity-bignumber/src/BigNumbers.sol\";\n\nimport \"../types/CommonTypes.sol\";\nimport \"../utils/BigInts.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the BigInts lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract BigIntsTest {\n    using BigInts for CommonTypes.BigInt;\n\n    function to_uint256() public view {\n        CommonTypes.BigInt memory value;\n        uint256 converted;\n        bool isOverflow;\n\n        value = CommonTypes.BigInt(hex\"ff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 255, \"'0xff' should be '255'\");\n\n        value = CommonTypes.BigInt(hex\"ffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 65535, \"'0xffff' should be '65535'\");\n\n        value = CommonTypes.BigInt(hex\"ffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 16777215, \"'0xffffff' should be '16777215'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 4294967295, \"'0xffffffff' should be '4294967295'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 1099511627775, \"'0xffffffffff' should be '1099511627775'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 281474976710655, \"'0xffffffffffff' should be '281474976710655'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 72057594037927935, \"'0xffffffffffffff' should be '72057594037927935'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 18446744073709551615, \"'0xffffffffffffffff' should be '18446744073709551615'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(\n            converted == 115792089237316195423570985008687907853269984665640564039457584007913129639935,\n            \"'(2 ** 256) - 1' should be '115792089237316195423570985008687907853269984665640564039457584007913129639935'\"\n        );\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(isOverflow, \"it should not be valid\");\n        require(converted == 0, \"overflow should have happened\");\n\n        value = CommonTypes.BigInt(hex\"00\", false);\n        (converted, isOverflow) = value.toUint256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 0, \"'0x00' should be '0'\");\n    }\n\n    function to_int256_positive() public view {\n        CommonTypes.BigInt memory value;\n        int256 converted;\n        bool isOverflow;\n\n        value = CommonTypes.BigInt(hex\"ff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 255, \"'0xff' should be '255'\");\n\n        value = CommonTypes.BigInt(hex\"ffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 65535, \"'0xffff' should be '65535'\");\n\n        value = CommonTypes.BigInt(hex\"ffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 16777215, \"'0xffffff' should be '16777215'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 4294967295, \"'0xffffffff' should be '4294967295'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 1099511627775, \"'0xffffffffff' should be '1099511627775'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 281474976710655, \"'0xffffffffffff' should be '281474976710655'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 72057594037927935, \"'0xffffffffffffff' should be '72057594037927935'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffffff\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 18446744073709551615, \"'0xffffffffffffffff' should be '18446744073709551615'\");\n\n        value = CommonTypes.BigInt(hex\"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(\n            converted == 57896044618658097711785492504343953926634992332820282019728792003956564819967,\n            \"'(2 ** 256) / 2 - 1' should be '57896044618658097711785492504343953926634992332820282019728792003956564819967'\"\n        );\n\n        value = CommonTypes.BigInt(hex\"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(isOverflow, \"it should not be valid\");\n        require(converted == 0, \"overflow should have happened\");\n\n        value = CommonTypes.BigInt(hex\"00\", false);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == 0, \"'0x00' should be '0'\");\n    }\n\n    function to_int256_negative() public view {\n        CommonTypes.BigInt memory value;\n        int256 converted;\n        bool isOverflow;\n\n        value = CommonTypes.BigInt(hex\"ff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -255, \"'0xff' should be '-255'\");\n\n        value = CommonTypes.BigInt(hex\"ffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -65535, \"'0xffff' should be '-65535'\");\n\n        value = CommonTypes.BigInt(hex\"ffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -16777215, \"'0xffffff' should be '-16777215'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -4294967295, \"'0xffffffff' should be '-4294967295'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -1099511627775, \"'0xffffffffff' should be '-1099511627775'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -281474976710655, \"'0xffffffffffff' should be '-281474976710655'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -72057594037927935, \"'0xffffffffffffff' should be '-72057594037927935'\");\n\n        value = CommonTypes.BigInt(hex\"ffffffffffffffff\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(converted == -18446744073709551615, \"'0xffffffffffffffff' should be '-18446744073709551615'\");\n\n        value = CommonTypes.BigInt(hex\"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(!isOverflow, \"it should be valid\");\n        require(\n            converted == -57896044618658097711785492504343953926634992332820282019728792003956564819967,\n            \"'(2 ** 256) / 2 - 1' should be '-57896044618658097711785492504343953926634992332820282019728792003956564819967'\"\n        );\n\n        value = CommonTypes.BigInt(hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", true);\n        (converted, isOverflow) = value.toInt256();\n        require(isOverflow, \"it should not be valid\");\n        require(converted == 0, \"overflow should have happened\");\n    }\n\n    function from_uint256() public view {\n        CommonTypes.BigInt memory converted;\n\n        converted = BigInts.fromUint256(255);\n        require(keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000000000ff\"), \"'255' should be '0xff'\");\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(65535);\n        require(keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000000000ffff\"), \"'65535' should be '0xffff'\");\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(16777215);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000000000ffffff\"),\n            \"'16777215' should be '0xffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(4294967295);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000ffffffff\"),\n            \"'4294967295' should be '0xffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(1099511627775);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000ffffffffff\"),\n            \"'1099511627775' should be '0xffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(281474976710655);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000ffffffffffff\"),\n            \"'281474976710655' should be '0xffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(72057594037927935);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000ffffffffffffff\"),\n            \"'72057594037927935' should be '0xffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(18446744073709551615);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000ffffffffffffffff\"),\n            \"'18446744073709551615' should be '0xffffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromUint256(115792089237316195423570985008687907853269984665640564039457584007913129639935);\n        require(\n            keccak256(converted.val) == keccak256(hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"),\n            \"'115792089237316195423570985008687907853269984665640564039457584007913129639935' should be '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n    }\n\n    function from_int256_positive() public view {\n        CommonTypes.BigInt memory converted;\n\n        converted = BigInts.fromInt256(255);\n        require(keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000000000ff\"), \"'255' should be '0xff'\");\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(65535);\n        require(keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000000000ffff\"), \"'65535' should be '0xffff'\");\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(16777215);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000000000ffffff\"),\n            \"'16777215' should be '0xffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(4294967295);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000ffffffff\"),\n            \"'4294967295' should be '0xffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(1099511627775);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000ffffffffff\"),\n            \"'1099511627775' should be '0xffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(281474976710655);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000ffffffffffff\"),\n            \"'281474976710655' should be '0xffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(72057594037927935);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000ffffffffffffff\"),\n            \"'72057594037927935' should be '0xffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(18446744073709551615);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000ffffffffffffffff\"),\n            \"'18446744073709551615' should be '0xffffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(57896044618658097711785492504343953926634992332820282019728792003956564819967);\n        require(\n            keccak256(converted.val) == keccak256(hex\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"),\n            \"'57896044618658097711785492504343953926634992332820282019728792003956564819967' should be '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\"\n        );\n        require(converted.neg == false, \"'neg flag should be false'\");\n    }\n\n    function from_int256_negative() public view {\n        CommonTypes.BigInt memory converted;\n\n        converted = BigInts.fromInt256(-255);\n        require(keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000000000ff\"), \"'255' should be '0xff'\");\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-65535);\n        require(keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000000000ffff\"), \"'65535' should be '0xffff'\");\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-16777215);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000000000ffffff\"),\n            \"'16777215' should be '0xffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-4294967295);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000000000ffffffff\"),\n            \"'4294967295' should be '0xffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-1099511627775);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000000000ffffffffff\"),\n            \"'1099511627775' should be '0xffffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-281474976710655);\n        require(\n            keccak256(converted.val) == keccak256(hex\"0000000000000000000000000000000000000000000000000000ffffffffffff\"),\n            \"'281474976710655' should be '0xffffffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-72057594037927935);\n        require(\n            keccak256(converted.val) == keccak256(hex\"00000000000000000000000000000000000000000000000000ffffffffffffff\"),\n            \"'72057594037927935' should be '0xffffffffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-18446744073709551615);\n        require(\n            keccak256(converted.val) == keccak256(hex\"000000000000000000000000000000000000000000000000ffffffffffffffff\"),\n            \"'18446744073709551615' should be '0xffffffffffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n\n        converted = BigInts.fromInt256(-57896044618658097711785492504343953926634992332820282019728792003956564819967);\n        require(\n            keccak256(converted.val) == keccak256(hex\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"),\n            \"'57896044618658097711785492504343953926634992332820282019728792003956564819967' should be '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\"\n        );\n        require(converted.neg == true, \"'neg flag should be false'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/cbor.decode.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/CborDecode.sol\";\n\n/// @notice This file is meant to serve as a deployable contract to test the cbor decode library\n/// @author Zondax AG\ncontract CborDecodeTest {\n    using CBORDecoder for bytes;\n\n    function decodeFixedArray() public pure {\n        // [1,2,3,4,5,6,7,8,9,10,\"test\", h'01010101', false, null, true]\n        bytes memory input = hex\"8F0102030405060708090A64746573744401010101F4F6F5\";\n        uint index = 0;\n        uint arrayLen = 0;\n        uint8 num;\n        string memory str = \"\";\n\n        (arrayLen, index) = input.readFixedArray(index);\n        require(arrayLen == 15, \"array len is not 15\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 1, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 2, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 3, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 4, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 5, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 6, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 7, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 8, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 9, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 10, \"num is not 1\");\n\n        (str, index) = input.readString(index);\n        require(keccak256(abi.encodePacked(str)) == keccak256(abi.encodePacked(\"test\")), \"str is not 'test'\");\n    }\n\n    function decodeFalse() public pure {\n        bytes memory input = hex\"f4\";\n        uint index = 0;\n        bool value;\n\n        (value, index) = input.readBool(0);\n        require(value == false, \"value is not false\");\n    }\n\n    function decodeTrue() public pure {\n        bytes memory input = hex\"f5\";\n        uint index = 0;\n        bool value;\n\n        (value, index) = input.readBool(0);\n        require(value == true, \"value is not true\");\n    }\n\n    function decodeNull() public pure {\n        bytes memory input = hex\"f6\";\n        bool value;\n\n        value = input.isNullNext(0);\n        require(value == true, \"input is not null cbor\");\n    }\n\n    function decodeInteger() public pure {\n        bytes memory input = hex\"01\";\n        uint index = 0;\n        uint8 value;\n\n        (value, index) = input.readUInt8(0);\n        require(value == 1, \"value is not 1\");\n    }\n\n    function decodeString() public pure {\n        bytes memory input = hex\"6a746573742076616c7565\";\n        uint index = 0;\n        string memory value;\n        string memory expected = \"test value\";\n\n        (value, index) = input.readString(0);\n        require(keccak256(bytes(value)) == keccak256(bytes(expected)), \"value is not 'test value'\");\n    }\n\n    function decodeStringWithWeirdChar() public pure {\n        bytes memory input = hex\"647A6FC3A9\";\n        uint index = 0;\n        string memory value;\n\n        (value, index) = input.readString(0);\n        // Does solidity support this ?\n        require(keccak256(bytes(value)) == keccak256(bytes(unicode\"zoé\")), unicode\"value is not 'zoé'\");\n    }\n\n    function decodeArrayU8() public pure {\n        bytes memory input = hex\"8501182b184218ea186f\";\n\n        uint index = 0;\n        uint arrayLen = 0;\n        uint8 num;\n\n        (arrayLen, index) = input.readFixedArray(index);\n        require(arrayLen == 5, \"array len is not 5\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 1, \"num is not 1\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 43, \"num is not 43\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 66, \"num is not 66\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 234, \"num is not 234\");\n\n        (num, index) = input.readUInt8(index);\n        require(num == 111, \"num is not 111\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/datacap.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/DataCapTypes.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"../cbor/BigIntCbor.sol\";\nimport \"../DataCapAPI.sol\";\nimport \"../Utils.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the datacap actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract DataCapApiTest {\n    function name() public returns (string memory) {\n        return DataCapAPI.name();\n    }\n\n    function symbol() public returns (string memory) {\n        return DataCapAPI.symbol();\n    }\n\n    function total_supply() public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.totalSupply();\n    }\n\n    function balance(CommonTypes.FilAddress memory addr) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.balance(addr);\n    }\n\n    function allowance(DataCapTypes.GetAllowanceParams memory params) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.allowance(params);\n    }\n\n    function transfer(DataCapTypes.TransferParams memory params) public returns (DataCapTypes.TransferReturn memory) {\n        return DataCapAPI.transfer(params);\n    }\n\n    function transfer_from(DataCapTypes.TransferFromParams memory params) public returns (DataCapTypes.TransferFromReturn memory) {\n        return DataCapAPI.transferFrom(params);\n    }\n\n    function increase_allowance(DataCapTypes.IncreaseAllowanceParams memory params) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.increaseAllowance(params);\n    }\n\n    function decrease_allowance(DataCapTypes.DecreaseAllowanceParams memory params) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.decreaseAllowance(params);\n    }\n\n    function revoke_allowance(CommonTypes.FilAddress memory operator) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.revokeAllowance(operator);\n    }\n\n    function burn(CommonTypes.BigInt memory amount) public returns (CommonTypes.BigInt memory) {\n        return DataCapAPI.burn(amount);\n    }\n\n    function burn_from(DataCapTypes.BurnFromParams memory params) public returns (DataCapTypes.BurnFromReturn memory) {\n        return DataCapAPI.burnFrom(params);\n    }\n\n    function handle_filecoin_method(uint64 method, uint64 codec, bytes calldata params) public pure {\n        Utils.handleFilecoinMethod(method, codec, params);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/deserializeparams.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/MinerTypes.sol\";\nimport \"../cbor/MinerCbor.sol\";\n\n/// @notice This file is meant to serve as a deployable contract to test\n/// @author Zondax AG\ncontract DeserializeParamsTest {\n    using MinerCBOR for *;\n\n    function deserializeGetVestingFundsReturn() public pure {\n        bytes memory params = hex\"8181820040\";\n\n        MinerTypes.GetVestingFundsReturn memory result = params.deserializeGetVestingFundsReturn();\n\n        require(result.vesting_funds.length == 1, \"result length should be 1\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated1.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated1Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected0 = hex\"d901\";\n        uint64 value0 = 217;\n\n        Buffer.buffer memory result0 = Leb128.encodeUnsignedLeb128FromUInt64(value0);\n\n        require(keccak256(result0.buf) == keccak256(expected0), \"'217' is not returning 'd901'\");\n\n        bytes memory expected1 = hex\"22\";\n        uint64 value1 = 34;\n\n        Buffer.buffer memory result1 = Leb128.encodeUnsignedLeb128FromUInt64(value1);\n\n        require(keccak256(result1.buf) == keccak256(expected1), \"'34' is not returning '22'\");\n\n        bytes memory expected2 = hex\"e901\";\n        uint64 value2 = 233;\n\n        Buffer.buffer memory result2 = Leb128.encodeUnsignedLeb128FromUInt64(value2);\n\n        require(keccak256(result2.buf) == keccak256(expected2), \"'233' is not returning 'e901'\");\n\n        bytes memory expected3 = hex\"33\";\n        uint64 value3 = 51;\n\n        Buffer.buffer memory result3 = Leb128.encodeUnsignedLeb128FromUInt64(value3);\n\n        require(keccak256(result3.buf) == keccak256(expected3), \"'51' is not returning '33'\");\n\n        bytes memory expected4 = hex\"45\";\n        uint64 value4 = 69;\n\n        Buffer.buffer memory result4 = Leb128.encodeUnsignedLeb128FromUInt64(value4);\n\n        require(keccak256(result4.buf) == keccak256(expected4), \"'69' is not returning '45'\");\n\n        bytes memory expected5 = hex\"e901\";\n        uint64 value5 = 233;\n\n        Buffer.buffer memory result5 = Leb128.encodeUnsignedLeb128FromUInt64(value5);\n\n        require(keccak256(result5.buf) == keccak256(expected5), \"'233' is not returning 'e901'\");\n\n        bytes memory expected6 = hex\"9601\";\n        uint64 value6 = 150;\n\n        Buffer.buffer memory result6 = Leb128.encodeUnsignedLeb128FromUInt64(value6);\n\n        require(keccak256(result6.buf) == keccak256(expected6), \"'150' is not returning '9601'\");\n\n        bytes memory expected7 = hex\"9501\";\n        uint64 value7 = 149;\n\n        Buffer.buffer memory result7 = Leb128.encodeUnsignedLeb128FromUInt64(value7);\n\n        require(keccak256(result7.buf) == keccak256(expected7), \"'149' is not returning '9501'\");\n\n        bytes memory expected8 = hex\"3b\";\n        uint64 value8 = 59;\n\n        Buffer.buffer memory result8 = Leb128.encodeUnsignedLeb128FromUInt64(value8);\n\n        require(keccak256(result8.buf) == keccak256(expected8), \"'59' is not returning '3b'\");\n\n        bytes memory expected9 = hex\"cf01\";\n        uint64 value9 = 207;\n\n        Buffer.buffer memory result9 = Leb128.encodeUnsignedLeb128FromUInt64(value9);\n\n        require(keccak256(result9.buf) == keccak256(expected9), \"'207' is not returning 'cf01'\");\n\n        bytes memory expected10 = hex\"bd01\";\n        uint64 value10 = 189;\n\n        Buffer.buffer memory result10 = Leb128.encodeUnsignedLeb128FromUInt64(value10);\n\n        require(keccak256(result10.buf) == keccak256(expected10), \"'189' is not returning 'bd01'\");\n\n        bytes memory expected11 = hex\"7c\";\n        uint64 value11 = 124;\n\n        Buffer.buffer memory result11 = Leb128.encodeUnsignedLeb128FromUInt64(value11);\n\n        require(keccak256(result11.buf) == keccak256(expected11), \"'124' is not returning '7c'\");\n\n        bytes memory expected12 = hex\"0d\";\n        uint64 value12 = 13;\n\n        Buffer.buffer memory result12 = Leb128.encodeUnsignedLeb128FromUInt64(value12);\n\n        require(keccak256(result12.buf) == keccak256(expected12), \"'13' is not returning '0d'\");\n\n        bytes memory expected13 = hex\"9601\";\n        uint64 value13 = 150;\n\n        Buffer.buffer memory result13 = Leb128.encodeUnsignedLeb128FromUInt64(value13);\n\n        require(keccak256(result13.buf) == keccak256(expected13), \"'150' is not returning '9601'\");\n\n        bytes memory expected14 = hex\"0e\";\n        uint64 value14 = 14;\n\n        Buffer.buffer memory result14 = Leb128.encodeUnsignedLeb128FromUInt64(value14);\n\n        require(keccak256(result14.buf) == keccak256(expected14), \"'14' is not returning '0e'\");\n\n        bytes memory expected15 = hex\"13\";\n        uint64 value15 = 19;\n\n        Buffer.buffer memory result15 = Leb128.encodeUnsignedLeb128FromUInt64(value15);\n\n        require(keccak256(result15.buf) == keccak256(expected15), \"'19' is not returning '13'\");\n\n        bytes memory expected16 = hex\"50\";\n        uint64 value16 = 80;\n\n        Buffer.buffer memory result16 = Leb128.encodeUnsignedLeb128FromUInt64(value16);\n\n        require(keccak256(result16.buf) == keccak256(expected16), \"'80' is not returning '50'\");\n\n        bytes memory expected17 = hex\"ac01\";\n        uint64 value17 = 172;\n\n        Buffer.buffer memory result17 = Leb128.encodeUnsignedLeb128FromUInt64(value17);\n\n        require(keccak256(result17.buf) == keccak256(expected17), \"'172' is not returning 'ac01'\");\n\n        bytes memory expected18 = hex\"fc01\";\n        uint64 value18 = 252;\n\n        Buffer.buffer memory result18 = Leb128.encodeUnsignedLeb128FromUInt64(value18);\n\n        require(keccak256(result18.buf) == keccak256(expected18), \"'252' is not returning 'fc01'\");\n\n        bytes memory expected19 = hex\"59\";\n        uint64 value19 = 89;\n\n        Buffer.buffer memory result19 = Leb128.encodeUnsignedLeb128FromUInt64(value19);\n\n        require(keccak256(result19.buf) == keccak256(expected19), \"'89' is not returning '59'\");\n\n        bytes memory expected20 = hex\"1c\";\n        uint64 value20 = 28;\n\n        Buffer.buffer memory result20 = Leb128.encodeUnsignedLeb128FromUInt64(value20);\n\n        require(keccak256(result20.buf) == keccak256(expected20), \"'28' is not returning '1c'\");\n\n        bytes memory expected21 = hex\"37\";\n        uint64 value21 = 55;\n\n        Buffer.buffer memory result21 = Leb128.encodeUnsignedLeb128FromUInt64(value21);\n\n        require(keccak256(result21.buf) == keccak256(expected21), \"'55' is not returning '37'\");\n\n        bytes memory expected22 = hex\"3b\";\n        uint64 value22 = 59;\n\n        Buffer.buffer memory result22 = Leb128.encodeUnsignedLeb128FromUInt64(value22);\n\n        require(keccak256(result22.buf) == keccak256(expected22), \"'59' is not returning '3b'\");\n\n        bytes memory expected23 = hex\"d001\";\n        uint64 value23 = 208;\n\n        Buffer.buffer memory result23 = Leb128.encodeUnsignedLeb128FromUInt64(value23);\n\n        require(keccak256(result23.buf) == keccak256(expected23), \"'208' is not returning 'd001'\");\n\n        bytes memory expected24 = hex\"72\";\n        uint64 value24 = 114;\n\n        Buffer.buffer memory result24 = Leb128.encodeUnsignedLeb128FromUInt64(value24);\n\n        require(keccak256(result24.buf) == keccak256(expected24), \"'114' is not returning '72'\");\n\n        bytes memory expected25 = hex\"e601\";\n        uint64 value25 = 230;\n\n        Buffer.buffer memory result25 = Leb128.encodeUnsignedLeb128FromUInt64(value25);\n\n        require(keccak256(result25.buf) == keccak256(expected25), \"'230' is not returning 'e601'\");\n\n        bytes memory expected26 = hex\"e101\";\n        uint64 value26 = 225;\n\n        Buffer.buffer memory result26 = Leb128.encodeUnsignedLeb128FromUInt64(value26);\n\n        require(keccak256(result26.buf) == keccak256(expected26), \"'225' is not returning 'e101'\");\n\n        bytes memory expected27 = hex\"e401\";\n        uint64 value27 = 228;\n\n        Buffer.buffer memory result27 = Leb128.encodeUnsignedLeb128FromUInt64(value27);\n\n        require(keccak256(result27.buf) == keccak256(expected27), \"'228' is not returning 'e401'\");\n\n        bytes memory expected28 = hex\"9e01\";\n        uint64 value28 = 158;\n\n        Buffer.buffer memory result28 = Leb128.encodeUnsignedLeb128FromUInt64(value28);\n\n        require(keccak256(result28.buf) == keccak256(expected28), \"'158' is not returning '9e01'\");\n\n        bytes memory expected29 = hex\"1d\";\n        uint64 value29 = 29;\n\n        Buffer.buffer memory result29 = Leb128.encodeUnsignedLeb128FromUInt64(value29);\n\n        require(keccak256(result29.buf) == keccak256(expected29), \"'29' is not returning '1d'\");\n\n        bytes memory expected30 = hex\"e801\";\n        uint64 value30 = 232;\n\n        Buffer.buffer memory result30 = Leb128.encodeUnsignedLeb128FromUInt64(value30);\n\n        require(keccak256(result30.buf) == keccak256(expected30), \"'232' is not returning 'e801'\");\n\n        bytes memory expected31 = hex\"a901\";\n        uint64 value31 = 169;\n\n        Buffer.buffer memory result31 = Leb128.encodeUnsignedLeb128FromUInt64(value31);\n\n        require(keccak256(result31.buf) == keccak256(expected31), \"'169' is not returning 'a901'\");\n\n        bytes memory expected32 = hex\"c301\";\n        uint64 value32 = 195;\n\n        Buffer.buffer memory result32 = Leb128.encodeUnsignedLeb128FromUInt64(value32);\n\n        require(keccak256(result32.buf) == keccak256(expected32), \"'195' is not returning 'c301'\");\n\n        bytes memory expected33 = hex\"0d\";\n        uint64 value33 = 13;\n\n        Buffer.buffer memory result33 = Leb128.encodeUnsignedLeb128FromUInt64(value33);\n\n        require(keccak256(result33.buf) == keccak256(expected33), \"'13' is not returning '0d'\");\n\n        bytes memory expected34 = hex\"b001\";\n        uint64 value34 = 176;\n\n        Buffer.buffer memory result34 = Leb128.encodeUnsignedLeb128FromUInt64(value34);\n\n        require(keccak256(result34.buf) == keccak256(expected34), \"'176' is not returning 'b001'\");\n\n        bytes memory expected35 = hex\"d001\";\n        uint64 value35 = 208;\n\n        Buffer.buffer memory result35 = Leb128.encodeUnsignedLeb128FromUInt64(value35);\n\n        require(keccak256(result35.buf) == keccak256(expected35), \"'208' is not returning 'd001'\");\n\n        bytes memory expected36 = hex\"2f\";\n        uint64 value36 = 47;\n\n        Buffer.buffer memory result36 = Leb128.encodeUnsignedLeb128FromUInt64(value36);\n\n        require(keccak256(result36.buf) == keccak256(expected36), \"'47' is not returning '2f'\");\n\n        bytes memory expected37 = hex\"69\";\n        uint64 value37 = 105;\n\n        Buffer.buffer memory result37 = Leb128.encodeUnsignedLeb128FromUInt64(value37);\n\n        require(keccak256(result37.buf) == keccak256(expected37), \"'105' is not returning '69'\");\n\n        bytes memory expected38 = hex\"aa01\";\n        uint64 value38 = 170;\n\n        Buffer.buffer memory result38 = Leb128.encodeUnsignedLeb128FromUInt64(value38);\n\n        require(keccak256(result38.buf) == keccak256(expected38), \"'170' is not returning 'aa01'\");\n\n        bytes memory expected39 = hex\"0e\";\n        uint64 value39 = 14;\n\n        Buffer.buffer memory result39 = Leb128.encodeUnsignedLeb128FromUInt64(value39);\n\n        require(keccak256(result39.buf) == keccak256(expected39), \"'14' is not returning '0e'\");\n\n        bytes memory expected40 = hex\"b401\";\n        uint64 value40 = 180;\n\n        Buffer.buffer memory result40 = Leb128.encodeUnsignedLeb128FromUInt64(value40);\n\n        require(keccak256(result40.buf) == keccak256(expected40), \"'180' is not returning 'b401'\");\n\n        bytes memory expected41 = hex\"42\";\n        uint64 value41 = 66;\n\n        Buffer.buffer memory result41 = Leb128.encodeUnsignedLeb128FromUInt64(value41);\n\n        require(keccak256(result41.buf) == keccak256(expected41), \"'66' is not returning '42'\");\n\n        bytes memory expected42 = hex\"70\";\n        uint64 value42 = 112;\n\n        Buffer.buffer memory result42 = Leb128.encodeUnsignedLeb128FromUInt64(value42);\n\n        require(keccak256(result42.buf) == keccak256(expected42), \"'112' is not returning '70'\");\n\n        bytes memory expected43 = hex\"ac01\";\n        uint64 value43 = 172;\n\n        Buffer.buffer memory result43 = Leb128.encodeUnsignedLeb128FromUInt64(value43);\n\n        require(keccak256(result43.buf) == keccak256(expected43), \"'172' is not returning 'ac01'\");\n\n        bytes memory expected44 = hex\"9101\";\n        uint64 value44 = 145;\n\n        Buffer.buffer memory result44 = Leb128.encodeUnsignedLeb128FromUInt64(value44);\n\n        require(keccak256(result44.buf) == keccak256(expected44), \"'145' is not returning '9101'\");\n\n        bytes memory expected45 = hex\"72\";\n        uint64 value45 = 114;\n\n        Buffer.buffer memory result45 = Leb128.encodeUnsignedLeb128FromUInt64(value45);\n\n        require(keccak256(result45.buf) == keccak256(expected45), \"'114' is not returning '72'\");\n\n        bytes memory expected46 = hex\"8d01\";\n        uint64 value46 = 141;\n\n        Buffer.buffer memory result46 = Leb128.encodeUnsignedLeb128FromUInt64(value46);\n\n        require(keccak256(result46.buf) == keccak256(expected46), \"'141' is not returning '8d01'\");\n\n        bytes memory expected47 = hex\"fe01\";\n        uint64 value47 = 254;\n\n        Buffer.buffer memory result47 = Leb128.encodeUnsignedLeb128FromUInt64(value47);\n\n        require(keccak256(result47.buf) == keccak256(expected47), \"'254' is not returning 'fe01'\");\n\n        bytes memory expected48 = hex\"b801\";\n        uint64 value48 = 184;\n\n        Buffer.buffer memory result48 = Leb128.encodeUnsignedLeb128FromUInt64(value48);\n\n        require(keccak256(result48.buf) == keccak256(expected48), \"'184' is not returning 'b801'\");\n\n        bytes memory expected49 = hex\"1c\";\n        uint64 value49 = 28;\n\n        Buffer.buffer memory result49 = Leb128.encodeUnsignedLeb128FromUInt64(value49);\n\n        require(keccak256(result49.buf) == keccak256(expected49), \"'28' is not returning '1c'\");\n\n        bytes memory expected50 = hex\"d901\";\n        uint64 value50 = 217;\n\n        Buffer.buffer memory result50 = Leb128.encodeUnsignedLeb128FromUInt64(value50);\n\n        require(keccak256(result50.buf) == keccak256(expected50), \"'217' is not returning 'd901'\");\n\n        bytes memory expected51 = hex\"4a\";\n        uint64 value51 = 74;\n\n        Buffer.buffer memory result51 = Leb128.encodeUnsignedLeb128FromUInt64(value51);\n\n        require(keccak256(result51.buf) == keccak256(expected51), \"'74' is not returning '4a'\");\n\n        bytes memory expected52 = hex\"6d\";\n        uint64 value52 = 109;\n\n        Buffer.buffer memory result52 = Leb128.encodeUnsignedLeb128FromUInt64(value52);\n\n        require(keccak256(result52.buf) == keccak256(expected52), \"'109' is not returning '6d'\");\n\n        bytes memory expected53 = hex\"7b\";\n        uint64 value53 = 123;\n\n        Buffer.buffer memory result53 = Leb128.encodeUnsignedLeb128FromUInt64(value53);\n\n        require(keccak256(result53.buf) == keccak256(expected53), \"'123' is not returning '7b'\");\n\n        bytes memory expected54 = hex\"0b\";\n        uint64 value54 = 11;\n\n        Buffer.buffer memory result54 = Leb128.encodeUnsignedLeb128FromUInt64(value54);\n\n        require(keccak256(result54.buf) == keccak256(expected54), \"'11' is not returning '0b'\");\n\n        bytes memory expected55 = hex\"22\";\n        uint64 value55 = 34;\n\n        Buffer.buffer memory result55 = Leb128.encodeUnsignedLeb128FromUInt64(value55);\n\n        require(keccak256(result55.buf) == keccak256(expected55), \"'34' is not returning '22'\");\n\n        bytes memory expected56 = hex\"55\";\n        uint64 value56 = 85;\n\n        Buffer.buffer memory result56 = Leb128.encodeUnsignedLeb128FromUInt64(value56);\n\n        require(keccak256(result56.buf) == keccak256(expected56), \"'85' is not returning '55'\");\n\n        bytes memory expected57 = hex\"8601\";\n        uint64 value57 = 134;\n\n        Buffer.buffer memory result57 = Leb128.encodeUnsignedLeb128FromUInt64(value57);\n\n        require(keccak256(result57.buf) == keccak256(expected57), \"'134' is not returning '8601'\");\n\n        bytes memory expected58 = hex\"c801\";\n        uint64 value58 = 200;\n\n        Buffer.buffer memory result58 = Leb128.encodeUnsignedLeb128FromUInt64(value58);\n\n        require(keccak256(result58.buf) == keccak256(expected58), \"'200' is not returning 'c801'\");\n\n        bytes memory expected59 = hex\"9c01\";\n        uint64 value59 = 156;\n\n        Buffer.buffer memory result59 = Leb128.encodeUnsignedLeb128FromUInt64(value59);\n\n        require(keccak256(result59.buf) == keccak256(expected59), \"'156' is not returning '9c01'\");\n\n        bytes memory expected60 = hex\"04\";\n        uint64 value60 = 4;\n\n        Buffer.buffer memory result60 = Leb128.encodeUnsignedLeb128FromUInt64(value60);\n\n        require(keccak256(result60.buf) == keccak256(expected60), \"'4' is not returning '04'\");\n\n        bytes memory expected61 = hex\"5b\";\n        uint64 value61 = 91;\n\n        Buffer.buffer memory result61 = Leb128.encodeUnsignedLeb128FromUInt64(value61);\n\n        require(keccak256(result61.buf) == keccak256(expected61), \"'91' is not returning '5b'\");\n\n        bytes memory expected62 = hex\"72\";\n        uint64 value62 = 114;\n\n        Buffer.buffer memory result62 = Leb128.encodeUnsignedLeb128FromUInt64(value62);\n\n        require(keccak256(result62.buf) == keccak256(expected62), \"'114' is not returning '72'\");\n\n        bytes memory expected63 = hex\"2f\";\n        uint64 value63 = 47;\n\n        Buffer.buffer memory result63 = Leb128.encodeUnsignedLeb128FromUInt64(value63);\n\n        require(keccak256(result63.buf) == keccak256(expected63), \"'47' is not returning '2f'\");\n\n        bytes memory expected64 = hex\"c801\";\n        uint64 value64 = 200;\n\n        Buffer.buffer memory result64 = Leb128.encodeUnsignedLeb128FromUInt64(value64);\n\n        require(keccak256(result64.buf) == keccak256(expected64), \"'200' is not returning 'c801'\");\n\n        bytes memory expected65 = hex\"4d\";\n        uint64 value65 = 77;\n\n        Buffer.buffer memory result65 = Leb128.encodeUnsignedLeb128FromUInt64(value65);\n\n        require(keccak256(result65.buf) == keccak256(expected65), \"'77' is not returning '4d'\");\n\n        bytes memory expected66 = hex\"62\";\n        uint64 value66 = 98;\n\n        Buffer.buffer memory result66 = Leb128.encodeUnsignedLeb128FromUInt64(value66);\n\n        require(keccak256(result66.buf) == keccak256(expected66), \"'98' is not returning '62'\");\n\n        bytes memory expected67 = hex\"07\";\n        uint64 value67 = 7;\n\n        Buffer.buffer memory result67 = Leb128.encodeUnsignedLeb128FromUInt64(value67);\n\n        require(keccak256(result67.buf) == keccak256(expected67), \"'7' is not returning '07'\");\n\n        bytes memory expected68 = hex\"1a\";\n        uint64 value68 = 26;\n\n        Buffer.buffer memory result68 = Leb128.encodeUnsignedLeb128FromUInt64(value68);\n\n        require(keccak256(result68.buf) == keccak256(expected68), \"'26' is not returning '1a'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated10.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated10Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected630 = hex\"8bdcf5a40f\";\n        uint64 value630 = 4103958027;\n\n        Buffer.buffer memory result630 = Leb128.encodeUnsignedLeb128FromUInt64(value630);\n\n        require(keccak256(result630.buf) == keccak256(expected630), \"'4103958027' is not returning '8bdcf5a40f'\");\n\n        bytes memory expected631 = hex\"c3a09c9c08\";\n        uint64 value631 = 2206666819;\n\n        Buffer.buffer memory result631 = Leb128.encodeUnsignedLeb128FromUInt64(value631);\n\n        require(keccak256(result631.buf) == keccak256(expected631), \"'2206666819' is not returning 'c3a09c9c08'\");\n\n        bytes memory expected632 = hex\"dcd1d7b206\";\n        uint64 value632 = 1716906204;\n\n        Buffer.buffer memory result632 = Leb128.encodeUnsignedLeb128FromUInt64(value632);\n\n        require(keccak256(result632.buf) == keccak256(expected632), \"'1716906204' is not returning 'dcd1d7b206'\");\n\n        bytes memory expected633 = hex\"acdfbfa509\";\n        uint64 value633 = 2494558124;\n\n        Buffer.buffer memory result633 = Leb128.encodeUnsignedLeb128FromUInt64(value633);\n\n        require(keccak256(result633.buf) == keccak256(expected633), \"'2494558124' is not returning 'acdfbfa509'\");\n\n        bytes memory expected634 = hex\"b09f8fb307\";\n        uint64 value634 = 1986252720;\n\n        Buffer.buffer memory result634 = Leb128.encodeUnsignedLeb128FromUInt64(value634);\n\n        require(keccak256(result634.buf) == keccak256(expected634), \"'1986252720' is not returning 'b09f8fb307'\");\n\n        bytes memory expected635 = hex\"82afa5ef09\";\n        uint64 value635 = 2649315202;\n\n        Buffer.buffer memory result635 = Leb128.encodeUnsignedLeb128FromUInt64(value635);\n\n        require(keccak256(result635.buf) == keccak256(expected635), \"'2649315202' is not returning '82afa5ef09'\");\n\n        bytes memory expected636 = hex\"e4bab0ea0b\";\n        uint64 value636 = 3175882084;\n\n        Buffer.buffer memory result636 = Leb128.encodeUnsignedLeb128FromUInt64(value636);\n\n        require(keccak256(result636.buf) == keccak256(expected636), \"'3175882084' is not returning 'e4bab0ea0b'\");\n\n        bytes memory expected637 = hex\"f4d28afc0d\";\n        uint64 value637 = 3749882228;\n\n        Buffer.buffer memory result637 = Leb128.encodeUnsignedLeb128FromUInt64(value637);\n\n        require(keccak256(result637.buf) == keccak256(expected637), \"'3749882228' is not returning 'f4d28afc0d'\");\n\n        bytes memory expected638 = hex\"aaa8f9d70d\";\n        uint64 value638 = 3674100778;\n\n        Buffer.buffer memory result638 = Leb128.encodeUnsignedLeb128FromUInt64(value638);\n\n        require(keccak256(result638.buf) == keccak256(expected638), \"'3674100778' is not returning 'aaa8f9d70d'\");\n\n        bytes memory expected639 = hex\"b6e99bf603\";\n        uint64 value639 = 1053226166;\n\n        Buffer.buffer memory result639 = Leb128.encodeUnsignedLeb128FromUInt64(value639);\n\n        require(keccak256(result639.buf) == keccak256(expected639), \"'1053226166' is not returning 'b6e99bf603'\");\n\n        bytes memory expected640 = hex\"d9d4b449\";\n        uint64 value640 = 153954905;\n\n        Buffer.buffer memory result640 = Leb128.encodeUnsignedLeb128FromUInt64(value640);\n\n        require(keccak256(result640.buf) == keccak256(expected640), \"'153954905' is not returning 'd9d4b449'\");\n\n        bytes memory expected641 = hex\"92d78dfc06\";\n        uint64 value641 = 1870883730;\n\n        Buffer.buffer memory result641 = Leb128.encodeUnsignedLeb128FromUInt64(value641);\n\n        require(keccak256(result641.buf) == keccak256(expected641), \"'1870883730' is not returning '92d78dfc06'\");\n\n        bytes memory expected642 = hex\"d78defaa09\";\n        uint64 value642 = 2505819863;\n\n        Buffer.buffer memory result642 = Leb128.encodeUnsignedLeb128FromUInt64(value642);\n\n        require(keccak256(result642.buf) == keccak256(expected642), \"'2505819863' is not returning 'd78defaa09'\");\n\n        bytes memory expected643 = hex\"9ff480f908\";\n        uint64 value643 = 2401253919;\n\n        Buffer.buffer memory result643 = Leb128.encodeUnsignedLeb128FromUInt64(value643);\n\n        require(keccak256(result643.buf) == keccak256(expected643), \"'2401253919' is not returning '9ff480f908'\");\n\n        bytes memory expected644 = hex\"b095b4a201\";\n        uint64 value644 = 340593328;\n\n        Buffer.buffer memory result644 = Leb128.encodeUnsignedLeb128FromUInt64(value644);\n\n        require(keccak256(result644.buf) == keccak256(expected644), \"'340593328' is not returning 'b095b4a201'\");\n\n        bytes memory expected645 = hex\"cfe7b5ce03\";\n        uint64 value645 = 969765839;\n\n        Buffer.buffer memory result645 = Leb128.encodeUnsignedLeb128FromUInt64(value645);\n\n        require(keccak256(result645.buf) == keccak256(expected645), \"'969765839' is not returning 'cfe7b5ce03'\");\n\n        bytes memory expected646 = hex\"b09fcab605\";\n        uint64 value646 = 1456639920;\n\n        Buffer.buffer memory result646 = Leb128.encodeUnsignedLeb128FromUInt64(value646);\n\n        require(keccak256(result646.buf) == keccak256(expected646), \"'1456639920' is not returning 'b09fcab605'\");\n\n        bytes memory expected647 = hex\"e086bd2b\";\n        uint64 value647 = 91177824;\n\n        Buffer.buffer memory result647 = Leb128.encodeUnsignedLeb128FromUInt64(value647);\n\n        require(keccak256(result647.buf) == keccak256(expected647), \"'91177824' is not returning 'e086bd2b'\");\n\n        bytes memory expected648 = hex\"cce3e1820d\";\n        uint64 value648 = 3495457228;\n\n        Buffer.buffer memory result648 = Leb128.encodeUnsignedLeb128FromUInt64(value648);\n\n        require(keccak256(result648.buf) == keccak256(expected648), \"'3495457228' is not returning 'cce3e1820d'\");\n\n        bytes memory expected649 = hex\"dbe8f9fb0b\";\n        uint64 value649 = 3212735579;\n\n        Buffer.buffer memory result649 = Leb128.encodeUnsignedLeb128FromUInt64(value649);\n\n        require(keccak256(result649.buf) == keccak256(expected649), \"'3212735579' is not returning 'dbe8f9fb0b'\");\n\n        bytes memory expected650 = hex\"98f7af8301\";\n        uint64 value650 = 275512216;\n\n        Buffer.buffer memory result650 = Leb128.encodeUnsignedLeb128FromUInt64(value650);\n\n        require(keccak256(result650.buf) == keccak256(expected650), \"'275512216' is not returning '98f7af8301'\");\n\n        bytes memory expected651 = hex\"be81c9c002\";\n        uint64 value651 = 672284862;\n\n        Buffer.buffer memory result651 = Leb128.encodeUnsignedLeb128FromUInt64(value651);\n\n        require(keccak256(result651.buf) == keccak256(expected651), \"'672284862' is not returning 'be81c9c002'\");\n\n        bytes memory expected652 = hex\"98bed6ca03\";\n        uint64 value652 = 961912600;\n\n        Buffer.buffer memory result652 = Leb128.encodeUnsignedLeb128FromUInt64(value652);\n\n        require(keccak256(result652.buf) == keccak256(expected652), \"'961912600' is not returning '98bed6ca03'\");\n\n        bytes memory expected653 = hex\"f8b3fbbe0b\";\n        uint64 value653 = 3084835320;\n\n        Buffer.buffer memory result653 = Leb128.encodeUnsignedLeb128FromUInt64(value653);\n\n        require(keccak256(result653.buf) == keccak256(expected653), \"'3084835320' is not returning 'f8b3fbbe0b'\");\n\n        bytes memory expected654 = hex\"cffcf468\";\n        uint64 value654 = 220020303;\n\n        Buffer.buffer memory result654 = Leb128.encodeUnsignedLeb128FromUInt64(value654);\n\n        require(keccak256(result654.buf) == keccak256(expected654), \"'220020303' is not returning 'cffcf468'\");\n\n        bytes memory expected655 = hex\"e28caa9009\";\n        uint64 value655 = 2450163298;\n\n        Buffer.buffer memory result655 = Leb128.encodeUnsignedLeb128FromUInt64(value655);\n\n        require(keccak256(result655.buf) == keccak256(expected655), \"'2450163298' is not returning 'e28caa9009'\");\n\n        bytes memory expected656 = hex\"d38ae28d0f\";\n        uint64 value656 = 4055401811;\n\n        Buffer.buffer memory result656 = Leb128.encodeUnsignedLeb128FromUInt64(value656);\n\n        require(keccak256(result656.buf) == keccak256(expected656), \"'4055401811' is not returning 'd38ae28d0f'\");\n\n        bytes memory expected657 = hex\"acd4e9aa04\";\n        uint64 value657 = 1163553324;\n\n        Buffer.buffer memory result657 = Leb128.encodeUnsignedLeb128FromUInt64(value657);\n\n        require(keccak256(result657.buf) == keccak256(expected657), \"'1163553324' is not returning 'acd4e9aa04'\");\n\n        bytes memory expected658 = hex\"f9f5b5bd04\";\n        uint64 value658 = 1202551545;\n\n        Buffer.buffer memory result658 = Leb128.encodeUnsignedLeb128FromUInt64(value658);\n\n        require(keccak256(result658.buf) == keccak256(expected658), \"'1202551545' is not returning 'f9f5b5bd04'\");\n\n        bytes memory expected659 = hex\"dc89ffc207\";\n        uint64 value659 = 2019542236;\n\n        Buffer.buffer memory result659 = Leb128.encodeUnsignedLeb128FromUInt64(value659);\n\n        require(keccak256(result659.buf) == keccak256(expected659), \"'2019542236' is not returning 'dc89ffc207'\");\n\n        bytes memory expected660 = hex\"b786dda40a\";\n        uint64 value660 = 2761376567;\n\n        Buffer.buffer memory result660 = Leb128.encodeUnsignedLeb128FromUInt64(value660);\n\n        require(keccak256(result660.buf) == keccak256(expected660), \"'2761376567' is not returning 'b786dda40a'\");\n\n        bytes memory expected661 = hex\"b2c2c2ff05\";\n        uint64 value661 = 1609605426;\n\n        Buffer.buffer memory result661 = Leb128.encodeUnsignedLeb128FromUInt64(value661);\n\n        require(keccak256(result661.buf) == keccak256(expected661), \"'1609605426' is not returning 'b2c2c2ff05'\");\n\n        bytes memory expected662 = hex\"a8d7bff601\";\n        uint64 value662 = 516942760;\n\n        Buffer.buffer memory result662 = Leb128.encodeUnsignedLeb128FromUInt64(value662);\n\n        require(keccak256(result662.buf) == keccak256(expected662), \"'516942760' is not returning 'a8d7bff601'\");\n\n        bytes memory expected663 = hex\"88baefed08\";\n        uint64 value663 = 2377899272;\n\n        Buffer.buffer memory result663 = Leb128.encodeUnsignedLeb128FromUInt64(value663);\n\n        require(keccak256(result663.buf) == keccak256(expected663), \"'2377899272' is not returning '88baefed08'\");\n\n        bytes memory expected664 = hex\"b2b0beab0d\";\n        uint64 value664 = 3580860466;\n\n        Buffer.buffer memory result664 = Leb128.encodeUnsignedLeb128FromUInt64(value664);\n\n        require(keccak256(result664.buf) == keccak256(expected664), \"'3580860466' is not returning 'b2b0beab0d'\");\n\n        bytes memory expected665 = hex\"b9bcf6f507\";\n        uint64 value665 = 2126356025;\n\n        Buffer.buffer memory result665 = Leb128.encodeUnsignedLeb128FromUInt64(value665);\n\n        require(keccak256(result665.buf) == keccak256(expected665), \"'2126356025' is not returning 'b9bcf6f507'\");\n\n        bytes memory expected666 = hex\"d9cdf5f805\";\n        uint64 value666 = 1595762393;\n\n        Buffer.buffer memory result666 = Leb128.encodeUnsignedLeb128FromUInt64(value666);\n\n        require(keccak256(result666.buf) == keccak256(expected666), \"'1595762393' is not returning 'd9cdf5f805'\");\n\n        bytes memory expected667 = hex\"ffa3e7de0a\";\n        uint64 value667 = 2883179007;\n\n        Buffer.buffer memory result667 = Leb128.encodeUnsignedLeb128FromUInt64(value667);\n\n        require(keccak256(result667.buf) == keccak256(expected667), \"'2883179007' is not returning 'ffa3e7de0a'\");\n\n        bytes memory expected668 = hex\"b9d286960d\";\n        uint64 value668 = 3535907129;\n\n        Buffer.buffer memory result668 = Leb128.encodeUnsignedLeb128FromUInt64(value668);\n\n        require(keccak256(result668.buf) == keccak256(expected668), \"'3535907129' is not returning 'b9d286960d'\");\n\n        bytes memory expected669 = hex\"cfd8c7a804\";\n        uint64 value669 = 1158802511;\n\n        Buffer.buffer memory result669 = Leb128.encodeUnsignedLeb128FromUInt64(value669);\n\n        require(keccak256(result669.buf) == keccak256(expected669), \"'1158802511' is not returning 'cfd8c7a804'\");\n\n        bytes memory expected670 = hex\"8ca2aaed01\";\n        uint64 value670 = 497717516;\n\n        Buffer.buffer memory result670 = Leb128.encodeUnsignedLeb128FromUInt64(value670);\n\n        require(keccak256(result670.buf) == keccak256(expected670), \"'497717516' is not returning '8ca2aaed01'\");\n\n        bytes memory expected671 = hex\"c3a3fce509\";\n        uint64 value671 = 2629767619;\n\n        Buffer.buffer memory result671 = Leb128.encodeUnsignedLeb128FromUInt64(value671);\n\n        require(keccak256(result671.buf) == keccak256(expected671), \"'2629767619' is not returning 'c3a3fce509'\");\n\n        bytes memory expected672 = hex\"9aea8a24\";\n        uint64 value672 = 75674906;\n\n        Buffer.buffer memory result672 = Leb128.encodeUnsignedLeb128FromUInt64(value672);\n\n        require(keccak256(result672.buf) == keccak256(expected672), \"'75674906' is not returning '9aea8a24'\");\n\n        bytes memory expected673 = hex\"e6b4d5d202\";\n        uint64 value673 = 710236774;\n\n        Buffer.buffer memory result673 = Leb128.encodeUnsignedLeb128FromUInt64(value673);\n\n        require(keccak256(result673.buf) == keccak256(expected673), \"'710236774' is not returning 'e6b4d5d202'\");\n\n        bytes memory expected674 = hex\"e599c7ed09\";\n        uint64 value674 = 2645675237;\n\n        Buffer.buffer memory result674 = Leb128.encodeUnsignedLeb128FromUInt64(value674);\n\n        require(keccak256(result674.buf) == keccak256(expected674), \"'2645675237' is not returning 'e599c7ed09'\");\n\n        bytes memory expected675 = hex\"e0fad1bf0a\";\n        uint64 value675 = 2817817952;\n\n        Buffer.buffer memory result675 = Leb128.encodeUnsignedLeb128FromUInt64(value675);\n\n        require(keccak256(result675.buf) == keccak256(expected675), \"'2817817952' is not returning 'e0fad1bf0a'\");\n\n        bytes memory expected676 = hex\"99c5b18004\";\n        uint64 value676 = 1074553497;\n\n        Buffer.buffer memory result676 = Leb128.encodeUnsignedLeb128FromUInt64(value676);\n\n        require(keccak256(result676.buf) == keccak256(expected676), \"'1074553497' is not returning '99c5b18004'\");\n\n        bytes memory expected677 = hex\"d184efe102\";\n        uint64 value677 = 742113873;\n\n        Buffer.buffer memory result677 = Leb128.encodeUnsignedLeb128FromUInt64(value677);\n\n        require(keccak256(result677.buf) == keccak256(expected677), \"'742113873' is not returning 'd184efe102'\");\n\n        bytes memory expected678 = hex\"ebf7bff208\";\n        uint64 value678 = 2387606507;\n\n        Buffer.buffer memory result678 = Leb128.encodeUnsignedLeb128FromUInt64(value678);\n\n        require(keccak256(result678.buf) == keccak256(expected678), \"'2387606507' is not returning 'ebf7bff208'\");\n\n        bytes memory expected679 = hex\"93c6c2a00e\";\n        uint64 value679 = 3826295571;\n\n        Buffer.buffer memory result679 = Leb128.encodeUnsignedLeb128FromUInt64(value679);\n\n        require(keccak256(result679.buf) == keccak256(expected679), \"'3826295571' is not returning '93c6c2a00e'\");\n\n        bytes memory expected680 = hex\"a0cba7bf05\";\n        uint64 value680 = 1474946464;\n\n        Buffer.buffer memory result680 = Leb128.encodeUnsignedLeb128FromUInt64(value680);\n\n        require(keccak256(result680.buf) == keccak256(expected680), \"'1474946464' is not returning 'a0cba7bf05'\");\n\n        bytes memory expected681 = hex\"d79baff90c\";\n        uint64 value681 = 3475754455;\n\n        Buffer.buffer memory result681 = Leb128.encodeUnsignedLeb128FromUInt64(value681);\n\n        require(keccak256(result681.buf) == keccak256(expected681), \"'3475754455' is not returning 'd79baff90c'\");\n\n        bytes memory expected682 = hex\"859acaaf0f\";\n        uint64 value682 = 4126313733;\n\n        Buffer.buffer memory result682 = Leb128.encodeUnsignedLeb128FromUInt64(value682);\n\n        require(keccak256(result682.buf) == keccak256(expected682), \"'4126313733' is not returning '859acaaf0f'\");\n\n        bytes memory expected683 = hex\"d3a1b19806\";\n        uint64 value683 = 1661751507;\n\n        Buffer.buffer memory result683 = Leb128.encodeUnsignedLeb128FromUInt64(value683);\n\n        require(keccak256(result683.buf) == keccak256(expected683), \"'1661751507' is not returning 'd3a1b19806'\");\n\n        bytes memory expected684 = hex\"8fd4e0b70b\";\n        uint64 value684 = 3069717007;\n\n        Buffer.buffer memory result684 = Leb128.encodeUnsignedLeb128FromUInt64(value684);\n\n        require(keccak256(result684.buf) == keccak256(expected684), \"'3069717007' is not returning '8fd4e0b70b'\");\n\n        bytes memory expected685 = hex\"abf6a7b70c\";\n        uint64 value685 = 3337222955;\n\n        Buffer.buffer memory result685 = Leb128.encodeUnsignedLeb128FromUInt64(value685);\n\n        require(keccak256(result685.buf) == keccak256(expected685), \"'3337222955' is not returning 'abf6a7b70c'\");\n\n        bytes memory expected686 = hex\"95a9c7ad06\";\n        uint64 value686 = 1706153109;\n\n        Buffer.buffer memory result686 = Leb128.encodeUnsignedLeb128FromUInt64(value686);\n\n        require(keccak256(result686.buf) == keccak256(expected686), \"'1706153109' is not returning '95a9c7ad06'\");\n\n        bytes memory expected687 = hex\"c1aac39c05\";\n        uint64 value687 = 1402000705;\n\n        Buffer.buffer memory result687 = Leb128.encodeUnsignedLeb128FromUInt64(value687);\n\n        require(keccak256(result687.buf) == keccak256(expected687), \"'1402000705' is not returning 'c1aac39c05'\");\n\n        bytes memory expected688 = hex\"8c89bbb108\";\n        uint64 value688 = 2251211916;\n\n        Buffer.buffer memory result688 = Leb128.encodeUnsignedLeb128FromUInt64(value688);\n\n        require(keccak256(result688.buf) == keccak256(expected688), \"'2251211916' is not returning '8c89bbb108'\");\n\n        bytes memory expected689 = hex\"c19bcdb60a\";\n        uint64 value689 = 2798865857;\n\n        Buffer.buffer memory result689 = Leb128.encodeUnsignedLeb128FromUInt64(value689);\n\n        require(keccak256(result689.buf) == keccak256(expected689), \"'2798865857' is not returning 'c19bcdb60a'\");\n\n        bytes memory expected690 = hex\"a1d0cd8e06\";\n        uint64 value690 = 1641244705;\n\n        Buffer.buffer memory result690 = Leb128.encodeUnsignedLeb128FromUInt64(value690);\n\n        require(keccak256(result690.buf) == keccak256(expected690), \"'1641244705' is not returning 'a1d0cd8e06'\");\n\n        bytes memory expected691 = hex\"dbd89cae09\";\n        uint64 value691 = 2512858203;\n\n        Buffer.buffer memory result691 = Leb128.encodeUnsignedLeb128FromUInt64(value691);\n\n        require(keccak256(result691.buf) == keccak256(expected691), \"'2512858203' is not returning 'dbd89cae09'\");\n\n        bytes memory expected692 = hex\"9db394fa01\";\n        uint64 value692 = 524622237;\n\n        Buffer.buffer memory result692 = Leb128.encodeUnsignedLeb128FromUInt64(value692);\n\n        require(keccak256(result692.buf) == keccak256(expected692), \"'524622237' is not returning '9db394fa01'\");\n\n        bytes memory expected693 = hex\"a2e4b4860e\";\n        uint64 value693 = 3771544098;\n\n        Buffer.buffer memory result693 = Leb128.encodeUnsignedLeb128FromUInt64(value693);\n\n        require(keccak256(result693.buf) == keccak256(expected693), \"'3771544098' is not returning 'a2e4b4860e'\");\n\n        bytes memory expected694 = hex\"b7ccd9a60f\";\n        uint64 value694 = 4107691575;\n\n        Buffer.buffer memory result694 = Leb128.encodeUnsignedLeb128FromUInt64(value694);\n\n        require(keccak256(result694.buf) == keccak256(expected694), \"'4107691575' is not returning 'b7ccd9a60f'\");\n\n        bytes memory expected695 = hex\"ffb0fd9f02\";\n        uint64 value695 = 603936895;\n\n        Buffer.buffer memory result695 = Leb128.encodeUnsignedLeb128FromUInt64(value695);\n\n        require(keccak256(result695.buf) == keccak256(expected695), \"'603936895' is not returning 'ffb0fd9f02'\");\n\n        bytes memory expected696 = hex\"f6a8d0ba0c\";\n        uint64 value696 = 3344176246;\n\n        Buffer.buffer memory result696 = Leb128.encodeUnsignedLeb128FromUInt64(value696);\n\n        require(keccak256(result696.buf) == keccak256(expected696), \"'3344176246' is not returning 'f6a8d0ba0c'\");\n\n        bytes memory expected697 = hex\"aaba9db404\";\n        uint64 value697 = 1183276330;\n\n        Buffer.buffer memory result697 = Leb128.encodeUnsignedLeb128FromUInt64(value697);\n\n        require(keccak256(result697.buf) == keccak256(expected697), \"'1183276330' is not returning 'aaba9db404'\");\n\n        bytes memory expected698 = hex\"bc92bfb30d\";\n        uint64 value698 = 3597650236;\n\n        Buffer.buffer memory result698 = Leb128.encodeUnsignedLeb128FromUInt64(value698);\n\n        require(keccak256(result698.buf) == keccak256(expected698), \"'3597650236' is not returning 'bc92bfb30d'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated11.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated11Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected700 = hex\"d4e092dd0f\";\n        uint64 value700 = 4221874260;\n\n        Buffer.buffer memory result700 = Leb128.encodeUnsignedLeb128FromUInt64(value700);\n\n        require(keccak256(result700.buf) == keccak256(expected700), \"'4221874260' is not returning 'd4e092dd0f'\");\n\n        bytes memory expected701 = hex\"c4a9d5db0e\";\n        uint64 value701 = 3950335172;\n\n        Buffer.buffer memory result701 = Leb128.encodeUnsignedLeb128FromUInt64(value701);\n\n        require(keccak256(result701.buf) == keccak256(expected701), \"'3950335172' is not returning 'c4a9d5db0e'\");\n\n        bytes memory expected702 = hex\"a8aefcac07\";\n        uint64 value702 = 1973360424;\n\n        Buffer.buffer memory result702 = Leb128.encodeUnsignedLeb128FromUInt64(value702);\n\n        require(keccak256(result702.buf) == keccak256(expected702), \"'1973360424' is not returning 'a8aefcac07'\");\n\n        bytes memory expected703 = hex\"b6dcab9f0e\";\n        uint64 value703 = 3823824438;\n\n        Buffer.buffer memory result703 = Leb128.encodeUnsignedLeb128FromUInt64(value703);\n\n        require(keccak256(result703.buf) == keccak256(expected703), \"'3823824438' is not returning 'b6dcab9f0e'\");\n\n        bytes memory expected704 = hex\"91efb5d107\";\n        uint64 value704 = 2049800081;\n\n        Buffer.buffer memory result704 = Leb128.encodeUnsignedLeb128FromUInt64(value704);\n\n        require(keccak256(result704.buf) == keccak256(expected704), \"'2049800081' is not returning '91efb5d107'\");\n\n        bytes memory expected705 = hex\"c4c7a7d10d\";\n        uint64 value705 = 3660178372;\n\n        Buffer.buffer memory result705 = Leb128.encodeUnsignedLeb128FromUInt64(value705);\n\n        require(keccak256(result705.buf) == keccak256(expected705), \"'3660178372' is not returning 'c4c7a7d10d'\");\n\n        bytes memory expected706 = hex\"a4d6a6f402\";\n        uint64 value706 = 780774180;\n\n        Buffer.buffer memory result706 = Leb128.encodeUnsignedLeb128FromUInt64(value706);\n\n        require(keccak256(result706.buf) == keccak256(expected706), \"'780774180' is not returning 'a4d6a6f402'\");\n\n        bytes memory expected707 = hex\"d282e8fe09\";\n        uint64 value707 = 2681864530;\n\n        Buffer.buffer memory result707 = Leb128.encodeUnsignedLeb128FromUInt64(value707);\n\n        require(keccak256(result707.buf) == keccak256(expected707), \"'2681864530' is not returning 'd282e8fe09'\");\n\n        bytes memory expected708 = hex\"b4f0e6d805\";\n        uint64 value708 = 1528412212;\n\n        Buffer.buffer memory result708 = Leb128.encodeUnsignedLeb128FromUInt64(value708);\n\n        require(keccak256(result708.buf) == keccak256(expected708), \"'1528412212' is not returning 'b4f0e6d805'\");\n\n        bytes memory expected709 = hex\"9ece92ed08\";\n        uint64 value709 = 2376378142;\n\n        Buffer.buffer memory result709 = Leb128.encodeUnsignedLeb128FromUInt64(value709);\n\n        require(keccak256(result709.buf) == keccak256(expected709), \"'2376378142' is not returning '9ece92ed08'\");\n\n        bytes memory expected710 = hex\"f3bbd3fb03\";\n        uint64 value710 = 1064623603;\n\n        Buffer.buffer memory result710 = Leb128.encodeUnsignedLeb128FromUInt64(value710);\n\n        require(keccak256(result710.buf) == keccak256(expected710), \"'1064623603' is not returning 'f3bbd3fb03'\");\n\n        bytes memory expected711 = hex\"ada1db850c\";\n        uint64 value711 = 3233206445;\n\n        Buffer.buffer memory result711 = Leb128.encodeUnsignedLeb128FromUInt64(value711);\n\n        require(keccak256(result711.buf) == keccak256(expected711), \"'3233206445' is not returning 'ada1db850c'\");\n\n        bytes memory expected712 = hex\"f1dba9d70d\";\n        uint64 value712 = 3672796657;\n\n        Buffer.buffer memory result712 = Leb128.encodeUnsignedLeb128FromUInt64(value712);\n\n        require(keccak256(result712.buf) == keccak256(expected712), \"'3672796657' is not returning 'f1dba9d70d'\");\n\n        bytes memory expected713 = hex\"d2e5b9f402\";\n        uint64 value713 = 781087442;\n\n        Buffer.buffer memory result713 = Leb128.encodeUnsignedLeb128FromUInt64(value713);\n\n        require(keccak256(result713.buf) == keccak256(expected713), \"'781087442' is not returning 'd2e5b9f402'\");\n\n        bytes memory expected714 = hex\"e3fdd7ae08\";\n        uint64 value714 = 2245394147;\n\n        Buffer.buffer memory result714 = Leb128.encodeUnsignedLeb128FromUInt64(value714);\n\n        require(keccak256(result714.buf) == keccak256(expected714), \"'2245394147' is not returning 'e3fdd7ae08'\");\n\n        bytes memory expected715 = hex\"9995bba50e\";\n        uint64 value715 = 3836660377;\n\n        Buffer.buffer memory result715 = Leb128.encodeUnsignedLeb128FromUInt64(value715);\n\n        require(keccak256(result715.buf) == keccak256(expected715), \"'3836660377' is not returning '9995bba50e'\");\n\n        bytes memory expected716 = hex\"88d2bae208\";\n        uint64 value716 = 2353965320;\n\n        Buffer.buffer memory result716 = Leb128.encodeUnsignedLeb128FromUInt64(value716);\n\n        require(keccak256(result716.buf) == keccak256(expected716), \"'2353965320' is not returning '88d2bae208'\");\n\n        bytes memory expected717 = hex\"d0e393f50f\";\n        uint64 value717 = 4272222672;\n\n        Buffer.buffer memory result717 = Leb128.encodeUnsignedLeb128FromUInt64(value717);\n\n        require(keccak256(result717.buf) == keccak256(expected717), \"'4272222672' is not returning 'd0e393f50f'\");\n\n        bytes memory expected718 = hex\"83fbc9a80f\";\n        uint64 value718 = 4111629699;\n\n        Buffer.buffer memory result718 = Leb128.encodeUnsignedLeb128FromUInt64(value718);\n\n        require(keccak256(result718.buf) == keccak256(expected718), \"'4111629699' is not returning '83fbc9a80f'\");\n\n        bytes memory expected719 = hex\"80adb4b303\";\n        uint64 value719 = 913118848;\n\n        Buffer.buffer memory result719 = Leb128.encodeUnsignedLeb128FromUInt64(value719);\n\n        require(keccak256(result719.buf) == keccak256(expected719), \"'913118848' is not returning '80adb4b303'\");\n\n        bytes memory expected720 = hex\"dbdbbb58\";\n        uint64 value720 = 185527771;\n\n        Buffer.buffer memory result720 = Leb128.encodeUnsignedLeb128FromUInt64(value720);\n\n        require(keccak256(result720.buf) == keccak256(expected720), \"'185527771' is not returning 'dbdbbb58'\");\n\n        bytes memory expected721 = hex\"dfb5e38f0f\";\n        uint64 value721 = 4059618015;\n\n        Buffer.buffer memory result721 = Leb128.encodeUnsignedLeb128FromUInt64(value721);\n\n        require(keccak256(result721.buf) == keccak256(expected721), \"'4059618015' is not returning 'dfb5e38f0f'\");\n\n        bytes memory expected722 = hex\"a6b7f7f802\";\n        uint64 value722 = 790485926;\n\n        Buffer.buffer memory result722 = Leb128.encodeUnsignedLeb128FromUInt64(value722);\n\n        require(keccak256(result722.buf) == keccak256(expected722), \"'790485926' is not returning 'a6b7f7f802'\");\n\n        bytes memory expected723 = hex\"f8c2a3bc0e\";\n        uint64 value723 = 3884507512;\n\n        Buffer.buffer memory result723 = Leb128.encodeUnsignedLeb128FromUInt64(value723);\n\n        require(keccak256(result723.buf) == keccak256(expected723), \"'3884507512' is not returning 'f8c2a3bc0e'\");\n\n        bytes memory expected724 = hex\"e0d6f8f00e\";\n        uint64 value724 = 3994954592;\n\n        Buffer.buffer memory result724 = Leb128.encodeUnsignedLeb128FromUInt64(value724);\n\n        require(keccak256(result724.buf) == keccak256(expected724), \"'3994954592' is not returning 'e0d6f8f00e'\");\n\n        bytes memory expected725 = hex\"e9c6f89d01\";\n        uint64 value725 = 331228009;\n\n        Buffer.buffer memory result725 = Leb128.encodeUnsignedLeb128FromUInt64(value725);\n\n        require(keccak256(result725.buf) == keccak256(expected725), \"'331228009' is not returning 'e9c6f89d01'\");\n\n        bytes memory expected726 = hex\"9d82f8dc06\";\n        uint64 value726 = 1805517085;\n\n        Buffer.buffer memory result726 = Leb128.encodeUnsignedLeb128FromUInt64(value726);\n\n        require(keccak256(result726.buf) == keccak256(expected726), \"'1805517085' is not returning '9d82f8dc06'\");\n\n        bytes memory expected727 = hex\"c5d0dc06\";\n        uint64 value727 = 14100549;\n\n        Buffer.buffer memory result727 = Leb128.encodeUnsignedLeb128FromUInt64(value727);\n\n        require(keccak256(result727.buf) == keccak256(expected727), \"'14100549' is not returning 'c5d0dc06'\");\n\n        bytes memory expected728 = hex\"f285b7b70f\";\n        uint64 value728 = 4142777074;\n\n        Buffer.buffer memory result728 = Leb128.encodeUnsignedLeb128FromUInt64(value728);\n\n        require(keccak256(result728.buf) == keccak256(expected728), \"'4142777074' is not returning 'f285b7b70f'\");\n\n        bytes memory expected729 = hex\"bad7bd8e0e\";\n        uint64 value729 = 3788467130;\n\n        Buffer.buffer memory result729 = Leb128.encodeUnsignedLeb128FromUInt64(value729);\n\n        require(keccak256(result729.buf) == keccak256(expected729), \"'3788467130' is not returning 'bad7bd8e0e'\");\n\n        bytes memory expected730 = hex\"9bf4a1e90a\";\n        uint64 value730 = 2905111067;\n\n        Buffer.buffer memory result730 = Leb128.encodeUnsignedLeb128FromUInt64(value730);\n\n        require(keccak256(result730.buf) == keccak256(expected730), \"'2905111067' is not returning '9bf4a1e90a'\");\n\n        bytes memory expected731 = hex\"deeca6da05\";\n        uint64 value731 = 1531557470;\n\n        Buffer.buffer memory result731 = Leb128.encodeUnsignedLeb128FromUInt64(value731);\n\n        require(keccak256(result731.buf) == keccak256(expected731), \"'1531557470' is not returning 'deeca6da05'\");\n\n        bytes memory expected732 = hex\"ffc0e38003\";\n        uint64 value732 = 806936703;\n\n        Buffer.buffer memory result732 = Leb128.encodeUnsignedLeb128FromUInt64(value732);\n\n        require(keccak256(result732.buf) == keccak256(expected732), \"'806936703' is not returning 'ffc0e38003'\");\n\n        bytes memory expected733 = hex\"ad9f828003\";\n        uint64 value733 = 805343149;\n\n        Buffer.buffer memory result733 = Leb128.encodeUnsignedLeb128FromUInt64(value733);\n\n        require(keccak256(result733.buf) == keccak256(expected733), \"'805343149' is not returning 'ad9f828003'\");\n\n        bytes memory expected734 = hex\"e7e6fcb703\";\n        uint64 value734 = 922694503;\n\n        Buffer.buffer memory result734 = Leb128.encodeUnsignedLeb128FromUInt64(value734);\n\n        require(keccak256(result734.buf) == keccak256(expected734), \"'922694503' is not returning 'e7e6fcb703'\");\n\n        bytes memory expected735 = hex\"bcde9af70d\";\n        uint64 value735 = 3739660092;\n\n        Buffer.buffer memory result735 = Leb128.encodeUnsignedLeb128FromUInt64(value735);\n\n        require(keccak256(result735.buf) == keccak256(expected735), \"'3739660092' is not returning 'bcde9af70d'\");\n\n        bytes memory expected736 = hex\"cfd79d8b0b\";\n        uint64 value736 = 2976345039;\n\n        Buffer.buffer memory result736 = Leb128.encodeUnsignedLeb128FromUInt64(value736);\n\n        require(keccak256(result736.buf) == keccak256(expected736), \"'2976345039' is not returning 'cfd79d8b0b'\");\n\n        bytes memory expected737 = hex\"bcb582a404\";\n        uint64 value737 = 1149278908;\n\n        Buffer.buffer memory result737 = Leb128.encodeUnsignedLeb128FromUInt64(value737);\n\n        require(keccak256(result737.buf) == keccak256(expected737), \"'1149278908' is not returning 'bcb582a404'\");\n\n        bytes memory expected738 = hex\"a5838df808\";\n        uint64 value738 = 2399355301;\n\n        Buffer.buffer memory result738 = Leb128.encodeUnsignedLeb128FromUInt64(value738);\n\n        require(keccak256(result738.buf) == keccak256(expected738), \"'2399355301' is not returning 'a5838df808'\");\n\n        bytes memory expected739 = hex\"97c9e48d09\";\n        uint64 value739 = 2444829847;\n\n        Buffer.buffer memory result739 = Leb128.encodeUnsignedLeb128FromUInt64(value739);\n\n        require(keccak256(result739.buf) == keccak256(expected739), \"'2444829847' is not returning '97c9e48d09'\");\n\n        bytes memory expected740 = hex\"8ba6f58f0b\";\n        uint64 value740 = 2986169099;\n\n        Buffer.buffer memory result740 = Leb128.encodeUnsignedLeb128FromUInt64(value740);\n\n        require(keccak256(result740.buf) == keccak256(expected740), \"'2986169099' is not returning '8ba6f58f0b'\");\n\n        bytes memory expected741 = hex\"dec2defe0a\";\n        uint64 value741 = 2950144350;\n\n        Buffer.buffer memory result741 = Leb128.encodeUnsignedLeb128FromUInt64(value741);\n\n        require(keccak256(result741.buf) == keccak256(expected741), \"'2950144350' is not returning 'dec2defe0a'\");\n\n        bytes memory expected742 = hex\"badfb8cb0e\";\n        uint64 value742 = 3916312506;\n\n        Buffer.buffer memory result742 = Leb128.encodeUnsignedLeb128FromUInt64(value742);\n\n        require(keccak256(result742.buf) == keccak256(expected742), \"'3916312506' is not returning 'badfb8cb0e'\");\n\n        bytes memory expected743 = hex\"8cd4a69303\";\n        uint64 value743 = 845785612;\n\n        Buffer.buffer memory result743 = Leb128.encodeUnsignedLeb128FromUInt64(value743);\n\n        require(keccak256(result743.buf) == keccak256(expected743), \"'845785612' is not returning '8cd4a69303'\");\n\n        bytes memory expected744 = hex\"d7ccee8d01\";\n        uint64 value744 = 297510487;\n\n        Buffer.buffer memory result744 = Leb128.encodeUnsignedLeb128FromUInt64(value744);\n\n        require(keccak256(result744.buf) == keccak256(expected744), \"'297510487' is not returning 'd7ccee8d01'\");\n\n        bytes memory expected745 = hex\"8af0cda70e\";\n        uint64 value745 = 3841161226;\n\n        Buffer.buffer memory result745 = Leb128.encodeUnsignedLeb128FromUInt64(value745);\n\n        require(keccak256(result745.buf) == keccak256(expected745), \"'3841161226' is not returning '8af0cda70e'\");\n\n        bytes memory expected746 = hex\"c9baf920\";\n        uint64 value746 = 69098825;\n\n        Buffer.buffer memory result746 = Leb128.encodeUnsignedLeb128FromUInt64(value746);\n\n        require(keccak256(result746.buf) == keccak256(expected746), \"'69098825' is not returning 'c9baf920'\");\n\n        bytes memory expected747 = hex\"cabdaba30b\";\n        uint64 value747 = 3026902730;\n\n        Buffer.buffer memory result747 = Leb128.encodeUnsignedLeb128FromUInt64(value747);\n\n        require(keccak256(result747.buf) == keccak256(expected747), \"'3026902730' is not returning 'cabdaba30b'\");\n\n        bytes memory expected748 = hex\"c3f6f4b405\";\n        uint64 value748 = 1453144899;\n\n        Buffer.buffer memory result748 = Leb128.encodeUnsignedLeb128FromUInt64(value748);\n\n        require(keccak256(result748.buf) == keccak256(expected748), \"'1453144899' is not returning 'c3f6f4b405'\");\n\n        bytes memory expected749 = hex\"80c8eba909\";\n        uint64 value749 = 2503664640;\n\n        Buffer.buffer memory result749 = Leb128.encodeUnsignedLeb128FromUInt64(value749);\n\n        require(keccak256(result749.buf) == keccak256(expected749), \"'2503664640' is not returning '80c8eba909'\");\n\n        bytes memory expected750 = hex\"adfe98d304\";\n        uint64 value750 = 1248214829;\n\n        Buffer.buffer memory result750 = Leb128.encodeUnsignedLeb128FromUInt64(value750);\n\n        require(keccak256(result750.buf) == keccak256(expected750), \"'1248214829' is not returning 'adfe98d304'\");\n\n        bytes memory expected751 = hex\"e9b2c9af05\";\n        uint64 value751 = 1441945961;\n\n        Buffer.buffer memory result751 = Leb128.encodeUnsignedLeb128FromUInt64(value751);\n\n        require(keccak256(result751.buf) == keccak256(expected751), \"'1441945961' is not returning 'e9b2c9af05'\");\n\n        bytes memory expected752 = hex\"e2feeefd02\";\n        uint64 value752 = 800833378;\n\n        Buffer.buffer memory result752 = Leb128.encodeUnsignedLeb128FromUInt64(value752);\n\n        require(keccak256(result752.buf) == keccak256(expected752), \"'800833378' is not returning 'e2feeefd02'\");\n\n        bytes memory expected753 = hex\"e7f7e7f403\";\n        uint64 value753 = 1050278887;\n\n        Buffer.buffer memory result753 = Leb128.encodeUnsignedLeb128FromUInt64(value753);\n\n        require(keccak256(result753.buf) == keccak256(expected753), \"'1050278887' is not returning 'e7f7e7f403'\");\n\n        bytes memory expected754 = hex\"d798a2830f\";\n        uint64 value754 = 4033383511;\n\n        Buffer.buffer memory result754 = Leb128.encodeUnsignedLeb128FromUInt64(value754);\n\n        require(keccak256(result754.buf) == keccak256(expected754), \"'4033383511' is not returning 'd798a2830f'\");\n\n        bytes memory expected755 = hex\"a8abeef50f\";\n        uint64 value755 = 4273706408;\n\n        Buffer.buffer memory result755 = Leb128.encodeUnsignedLeb128FromUInt64(value755);\n\n        require(keccak256(result755.buf) == keccak256(expected755), \"'4273706408' is not returning 'a8abeef50f'\");\n\n        bytes memory expected756 = hex\"92c2d2c708\";\n        uint64 value756 = 2297733394;\n\n        Buffer.buffer memory result756 = Leb128.encodeUnsignedLeb128FromUInt64(value756);\n\n        require(keccak256(result756.buf) == keccak256(expected756), \"'2297733394' is not returning '92c2d2c708'\");\n\n        bytes memory expected757 = hex\"90b9ded80a\";\n        uint64 value757 = 2870451344;\n\n        Buffer.buffer memory result757 = Leb128.encodeUnsignedLeb128FromUInt64(value757);\n\n        require(keccak256(result757.buf) == keccak256(expected757), \"'2870451344' is not returning '90b9ded80a'\");\n\n        bytes memory expected758 = hex\"a4adfe850f\";\n        uint64 value758 = 4039087780;\n\n        Buffer.buffer memory result758 = Leb128.encodeUnsignedLeb128FromUInt64(value758);\n\n        require(keccak256(result758.buf) == keccak256(expected758), \"'4039087780' is not returning 'a4adfe850f'\");\n\n        bytes memory expected759 = hex\"a0d5c9ca02\";\n        uint64 value759 = 693267104;\n\n        Buffer.buffer memory result759 = Leb128.encodeUnsignedLeb128FromUInt64(value759);\n\n        require(keccak256(result759.buf) == keccak256(expected759), \"'693267104' is not returning 'a0d5c9ca02'\");\n\n        bytes memory expected760 = hex\"b1d4b08102\";\n        uint64 value760 = 539765297;\n\n        Buffer.buffer memory result760 = Leb128.encodeUnsignedLeb128FromUInt64(value760);\n\n        require(keccak256(result760.buf) == keccak256(expected760), \"'539765297' is not returning 'b1d4b08102'\");\n\n        bytes memory expected761 = hex\"b9ac838a0f\";\n        uint64 value761 = 4047558201;\n\n        Buffer.buffer memory result761 = Leb128.encodeUnsignedLeb128FromUInt64(value761);\n\n        require(keccak256(result761.buf) == keccak256(expected761), \"'4047558201' is not returning 'b9ac838a0f'\");\n\n        bytes memory expected762 = hex\"9dbef2f60a\";\n        uint64 value762 = 2933694237;\n\n        Buffer.buffer memory result762 = Leb128.encodeUnsignedLeb128FromUInt64(value762);\n\n        require(keccak256(result762.buf) == keccak256(expected762), \"'2933694237' is not returning '9dbef2f60a'\");\n\n        bytes memory expected763 = hex\"f9b3d6cc0e\";\n        uint64 value763 = 3918895609;\n\n        Buffer.buffer memory result763 = Leb128.encodeUnsignedLeb128FromUInt64(value763);\n\n        require(keccak256(result763.buf) == keccak256(expected763), \"'3918895609' is not returning 'f9b3d6cc0e'\");\n\n        bytes memory expected764 = hex\"ec96f0ea0f\";\n        uint64 value764 = 4250667884;\n\n        Buffer.buffer memory result764 = Leb128.encodeUnsignedLeb128FromUInt64(value764);\n\n        require(keccak256(result764.buf) == keccak256(expected764), \"'4250667884' is not returning 'ec96f0ea0f'\");\n\n        bytes memory expected765 = hex\"f8f58eb209\";\n        uint64 value765 = 2521021176;\n\n        Buffer.buffer memory result765 = Leb128.encodeUnsignedLeb128FromUInt64(value765);\n\n        require(keccak256(result765.buf) == keccak256(expected765), \"'2521021176' is not returning 'f8f58eb209'\");\n\n        bytes memory expected766 = hex\"abc390fc0d\";\n        uint64 value766 = 3749978539;\n\n        Buffer.buffer memory result766 = Leb128.encodeUnsignedLeb128FromUInt64(value766);\n\n        require(keccak256(result766.buf) == keccak256(expected766), \"'3749978539' is not returning 'abc390fc0d'\");\n\n        bytes memory expected767 = hex\"a691e0ee0f\";\n        uint64 value767 = 4258793638;\n\n        Buffer.buffer memory result767 = Leb128.encodeUnsignedLeb128FromUInt64(value767);\n\n        require(keccak256(result767.buf) == keccak256(expected767), \"'4258793638' is not returning 'a691e0ee0f'\");\n\n        bytes memory expected768 = hex\"d8c4ecdcd886dff9e401\";\n        uint64 value768 = 16497666429405569624;\n\n        Buffer.buffer memory result768 = Leb128.encodeUnsignedLeb128FromUInt64(value768);\n\n        require(keccak256(result768.buf) == keccak256(expected768), \"'16497666429405569624' is not returning 'd8c4ecdcd886dff9e401'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated12.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated12Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected770 = hex\"d7ee9cbbe9cebffc5e\";\n        uint64 value770 = 6843499419089188695;\n\n        Buffer.buffer memory result770 = Leb128.encodeUnsignedLeb128FromUInt64(value770);\n\n        require(keccak256(result770.buf) == keccak256(expected770), \"'6843499419089188695' is not returning 'd7ee9cbbe9cebffc5e'\");\n\n        bytes memory expected771 = hex\"9db0dbea938b8fe96c\";\n        uint64 value771 = 7841396255184312349;\n\n        Buffer.buffer memory result771 = Leb128.encodeUnsignedLeb128FromUInt64(value771);\n\n        require(keccak256(result771.buf) == keccak256(expected771), \"'7841396255184312349' is not returning '9db0dbea938b8fe96c'\");\n\n        bytes memory expected772 = hex\"e28af093acd1a6ba0f\";\n        uint64 value772 = 1113684928626427234;\n\n        Buffer.buffer memory result772 = Leb128.encodeUnsignedLeb128FromUInt64(value772);\n\n        require(keccak256(result772.buf) == keccak256(expected772), \"'1113684928626427234' is not returning 'e28af093acd1a6ba0f'\");\n\n        bytes memory expected773 = hex\"f3bfaa95d592f5af39\";\n        uint64 value773 = 4134256720751534067;\n\n        Buffer.buffer memory result773 = Leb128.encodeUnsignedLeb128FromUInt64(value773);\n\n        require(keccak256(result773.buf) == keccak256(expected773), \"'4134256720751534067' is not returning 'f3bfaa95d592f5af39'\");\n\n        bytes memory expected774 = hex\"b6c1eac8dde7ebb7ef01\";\n        uint64 value774 = 17253201377649926326;\n\n        Buffer.buffer memory result774 = Leb128.encodeUnsignedLeb128FromUInt64(value774);\n\n        require(keccak256(result774.buf) == keccak256(expected774), \"'17253201377649926326' is not returning 'b6c1eac8dde7ebb7ef01'\");\n\n        bytes memory expected775 = hex\"ecf6b4b6f2f493d8d601\";\n        uint64 value775 = 15469952299346770796;\n\n        Buffer.buffer memory result775 = Leb128.encodeUnsignedLeb128FromUInt64(value775);\n\n        require(keccak256(result775.buf) == keccak256(expected775), \"'15469952299346770796' is not returning 'ecf6b4b6f2f493d8d601'\");\n\n        bytes memory expected776 = hex\"f585a5d5c0deedfd50\";\n        uint64 value776 = 5835458901455749877;\n\n        Buffer.buffer memory result776 = Leb128.encodeUnsignedLeb128FromUInt64(value776);\n\n        require(keccak256(result776.buf) == keccak256(expected776), \"'5835458901455749877' is not returning 'f585a5d5c0deedfd50'\");\n\n        bytes memory expected777 = hex\"9a88cb859caaa3d2f701\";\n        uint64 value777 = 17844543005813556250;\n\n        Buffer.buffer memory result777 = Leb128.encodeUnsignedLeb128FromUInt64(value777);\n\n        require(keccak256(result777.buf) == keccak256(expected777), \"'17844543005813556250' is not returning '9a88cb859caaa3d2f701'\");\n\n        bytes memory expected778 = hex\"d984bdeecce1aefb44\";\n        uint64 value778 = 4969364902516834905;\n\n        Buffer.buffer memory result778 = Leb128.encodeUnsignedLeb128FromUInt64(value778);\n\n        require(keccak256(result778.buf) == keccak256(expected778), \"'4969364902516834905' is not returning 'd984bdeecce1aefb44'\");\n\n        bytes memory expected779 = hex\"9ad993c4d5c986f05c\";\n        uint64 value779 = 6692377965772467354;\n\n        Buffer.buffer memory result779 = Leb128.encodeUnsignedLeb128FromUInt64(value779);\n\n        require(keccak256(result779.buf) == keccak256(expected779), \"'6692377965772467354' is not returning '9ad993c4d5c986f05c'\");\n\n        bytes memory expected780 = hex\"ffc688f8aee395bd14\";\n        uint64 value780 = 1475587601107919743;\n\n        Buffer.buffer memory result780 = Leb128.encodeUnsignedLeb128FromUInt64(value780);\n\n        require(keccak256(result780.buf) == keccak256(expected780), \"'1475587601107919743' is not returning 'ffc688f8aee395bd14'\");\n\n        bytes memory expected781 = hex\"daa2cea1deb9f5aa35\";\n        uint64 value781 = 3843212937304183130;\n\n        Buffer.buffer memory result781 = Leb128.encodeUnsignedLeb128FromUInt64(value781);\n\n        require(keccak256(result781.buf) == keccak256(expected781), \"'3843212937304183130' is not returning 'daa2cea1deb9f5aa35'\");\n\n        bytes memory expected782 = hex\"8ec4afc1d7b3bbd78701\";\n        uint64 value782 = 9777013101649715726;\n\n        Buffer.buffer memory result782 = Leb128.encodeUnsignedLeb128FromUInt64(value782);\n\n        require(keccak256(result782.buf) == keccak256(expected782), \"'9777013101649715726' is not returning '8ec4afc1d7b3bbd78701'\");\n\n        bytes memory expected783 = hex\"9eb1c7e6c8ae93e515\";\n        uint64 value783 = 1570152583066146974;\n\n        Buffer.buffer memory result783 = Leb128.encodeUnsignedLeb128FromUInt64(value783);\n\n        require(keccak256(result783.buf) == keccak256(expected783), \"'1570152583066146974' is not returning '9eb1c7e6c8ae93e515'\");\n\n        bytes memory expected784 = hex\"e896dadbb7aacdeef001\";\n        uint64 value784 = 17356087171625683816;\n\n        Buffer.buffer memory result784 = Leb128.encodeUnsignedLeb128FromUInt64(value784);\n\n        require(keccak256(result784.buf) == keccak256(expected784), \"'17356087171625683816' is not returning 'e896dadbb7aacdeef001'\");\n\n        bytes memory expected785 = hex\"a9a9b0d3ddfbb59546\";\n        uint64 value785 = 5056090879529063593;\n\n        Buffer.buffer memory result785 = Leb128.encodeUnsignedLeb128FromUInt64(value785);\n\n        require(keccak256(result785.buf) == keccak256(expected785), \"'5056090879529063593' is not returning 'a9a9b0d3ddfbb59546'\");\n\n        bytes memory expected786 = hex\"8696e5f3f4efcffc2e\";\n        uint64 value786 = 3384806410955606790;\n\n        Buffer.buffer memory result786 = Leb128.encodeUnsignedLeb128FromUInt64(value786);\n\n        require(keccak256(result786.buf) == keccak256(expected786), \"'3384806410955606790' is not returning '8696e5f3f4efcffc2e'\");\n\n        bytes memory expected787 = hex\"93a1f49eb8ebe1a467\";\n        uint64 value787 = 7442628686330531987;\n\n        Buffer.buffer memory result787 = Leb128.encodeUnsignedLeb128FromUInt64(value787);\n\n        require(keccak256(result787.buf) == keccak256(expected787), \"'7442628686330531987' is not returning '93a1f49eb8ebe1a467'\");\n\n        bytes memory expected788 = hex\"e1ccc0d2c8b6e8ea12\";\n        uint64 value788 = 1357168659508766305;\n\n        Buffer.buffer memory result788 = Leb128.encodeUnsignedLeb128FromUInt64(value788);\n\n        require(keccak256(result788.buf) == keccak256(expected788), \"'1357168659508766305' is not returning 'e1ccc0d2c8b6e8ea12'\");\n\n        bytes memory expected789 = hex\"ddd6d8cddbb9939662\";\n        uint64 value789 = 7074114660671564637;\n\n        Buffer.buffer memory result789 = Leb128.encodeUnsignedLeb128FromUInt64(value789);\n\n        require(keccak256(result789.buf) == keccak256(expected789), \"'7074114660671564637' is not returning 'ddd6d8cddbb9939662'\");\n\n        bytes memory expected790 = hex\"fcbff5bd9ee18381e801\";\n        uint64 value790 = 16717941301969772540;\n\n        Buffer.buffer memory result790 = Leb128.encodeUnsignedLeb128FromUInt64(value790);\n\n        require(keccak256(result790.buf) == keccak256(expected790), \"'16717941301969772540' is not returning 'fcbff5bd9ee18381e801'\");\n\n        bytes memory expected791 = hex\"ada6a2d4ef90a49121\";\n        uint64 value791 = 2387629661863056173;\n\n        Buffer.buffer memory result791 = Leb128.encodeUnsignedLeb128FromUInt64(value791);\n\n        require(keccak256(result791.buf) == keccak256(expected791), \"'2387629661863056173' is not returning 'ada6a2d4ef90a49121'\");\n\n        bytes memory expected792 = hex\"f7edf9d88192b18e6d\";\n        uint64 value792 = 7862375172691359479;\n\n        Buffer.buffer memory result792 = Leb128.encodeUnsignedLeb128FromUInt64(value792);\n\n        require(keccak256(result792.buf) == keccak256(expected792), \"'7862375172691359479' is not returning 'f7edf9d88192b18e6d'\");\n\n        bytes memory expected793 = hex\"f0d1ae83ba93e7a9f501\";\n        uint64 value793 = 17677645154584602864;\n\n        Buffer.buffer memory result793 = Leb128.encodeUnsignedLeb128FromUInt64(value793);\n\n        require(keccak256(result793.buf) == keccak256(expected793), \"'17677645154584602864' is not returning 'f0d1ae83ba93e7a9f501'\");\n\n        bytes memory expected794 = hex\"87809cdb8cc6c99138\";\n        uint64 value794 = 4045118881321648135;\n\n        Buffer.buffer memory result794 = Leb128.encodeUnsignedLeb128FromUInt64(value794);\n\n        require(keccak256(result794.buf) == keccak256(expected794), \"'4045118881321648135' is not returning '87809cdb8cc6c99138'\");\n\n        bytes memory expected795 = hex\"baf0b4be8ee1c89d7e\";\n        uint64 value795 = 9095902393560545338;\n\n        Buffer.buffer memory result795 = Leb128.encodeUnsignedLeb128FromUInt64(value795);\n\n        require(keccak256(result795.buf) == keccak256(expected795), \"'9095902393560545338' is not returning 'baf0b4be8ee1c89d7e'\");\n\n        bytes memory expected796 = hex\"f0e2ef80d390b2e90e\";\n        uint64 value796 = 1068136536003572080;\n\n        Buffer.buffer memory result796 = Leb128.encodeUnsignedLeb128FromUInt64(value796);\n\n        require(keccak256(result796.buf) == keccak256(expected796), \"'1068136536003572080' is not returning 'f0e2ef80d390b2e90e'\");\n\n        bytes memory expected797 = hex\"a3deb1e881fbcfe965\";\n        uint64 value797 = 7337278415349509923;\n\n        Buffer.buffer memory result797 = Leb128.encodeUnsignedLeb128FromUInt64(value797);\n\n        require(keccak256(result797.buf) == keccak256(expected797), \"'7337278415349509923' is not returning 'a3deb1e881fbcfe965'\");\n\n        bytes memory expected798 = hex\"9bdeb0c29bc7eb9318\";\n        uint64 value798 = 1740551343930355483;\n\n        Buffer.buffer memory result798 = Leb128.encodeUnsignedLeb128FromUInt64(value798);\n\n        require(keccak256(result798.buf) == keccak256(expected798), \"'1740551343930355483' is not returning '9bdeb0c29bc7eb9318'\");\n\n        bytes memory expected799 = hex\"c3bcc8b594b0b88436\";\n        uint64 value799 = 3893609823214902851;\n\n        Buffer.buffer memory result799 = Leb128.encodeUnsignedLeb128FromUInt64(value799);\n\n        require(keccak256(result799.buf) == keccak256(expected799), \"'3893609823214902851' is not returning 'c3bcc8b594b0b88436'\");\n\n        bytes memory expected800 = hex\"8ae3d7c8c6a8839ae801\";\n        uint64 value800 = 16732013103060218250;\n\n        Buffer.buffer memory result800 = Leb128.encodeUnsignedLeb128FromUInt64(value800);\n\n        require(keccak256(result800.buf) == keccak256(expected800), \"'16732013103060218250' is not returning '8ae3d7c8c6a8839ae801'\");\n\n        bytes memory expected801 = hex\"f6b185e0f3dbfaf58d01\";\n        uint64 value801 = 10226525623380170998;\n\n        Buffer.buffer memory result801 = Leb128.encodeUnsignedLeb128FromUInt64(value801);\n\n        require(keccak256(result801.buf) == keccak256(expected801), \"'10226525623380170998' is not returning 'f6b185e0f3dbfaf58d01'\");\n\n        bytes memory expected802 = hex\"9c98d4bcd0c9b7a61a\";\n        uint64 value802 = 1895133965637192732;\n\n        Buffer.buffer memory result802 = Leb128.encodeUnsignedLeb128FromUInt64(value802);\n\n        require(keccak256(result802.buf) == keccak256(expected802), \"'1895133965637192732' is not returning '9c98d4bcd0c9b7a61a'\");\n\n        bytes memory expected803 = hex\"f0f8e3eba5aec4a9dd01\";\n        uint64 value803 = 15948109888341212272;\n\n        Buffer.buffer memory result803 = Leb128.encodeUnsignedLeb128FromUInt64(value803);\n\n        require(keccak256(result803.buf) == keccak256(expected803), \"'15948109888341212272' is not returning 'f0f8e3eba5aec4a9dd01'\");\n\n        bytes memory expected804 = hex\"c3d79ef5d7eabea670\";\n        uint64 value804 = 8092118975093648323;\n\n        Buffer.buffer memory result804 = Leb128.encodeUnsignedLeb128FromUInt64(value804);\n\n        require(keccak256(result804.buf) == keccak256(expected804), \"'8092118975093648323' is not returning 'c3d79ef5d7eabea670'\");\n\n        bytes memory expected805 = hex\"aa87b2f9f5f2f5f59101\";\n        uint64 value805 = 10514734800163341226;\n\n        Buffer.buffer memory result805 = Leb128.encodeUnsignedLeb128FromUInt64(value805);\n\n        require(keccak256(result805.buf) == keccak256(expected805), \"'10514734800163341226' is not returning 'aa87b2f9f5f2f5f59101'\");\n\n        bytes memory expected806 = hex\"a89bd694d999bbd8c001\";\n        uint64 value806 = 13884858018854964648;\n\n        Buffer.buffer memory result806 = Leb128.encodeUnsignedLeb128FromUInt64(value806);\n\n        require(keccak256(result806.buf) == keccak256(expected806), \"'13884858018854964648' is not returning 'a89bd694d999bbd8c001'\");\n\n        bytes memory expected807 = hex\"9bfcb7d6ddaed8b44c\";\n        uint64 value807 = 5506039178247142939;\n\n        Buffer.buffer memory result807 = Leb128.encodeUnsignedLeb128FromUInt64(value807);\n\n        require(keccak256(result807.buf) == keccak256(expected807), \"'5506039178247142939' is not returning '9bfcb7d6ddaed8b44c'\");\n\n        bytes memory expected808 = hex\"fdc2a4be9aa3d4a735\";\n        uint64 value808 = 3841378177801331069;\n\n        Buffer.buffer memory result808 = Leb128.encodeUnsignedLeb128FromUInt64(value808);\n\n        require(keccak256(result808.buf) == keccak256(expected808), \"'3841378177801331069' is not returning 'fdc2a4be9aa3d4a735'\");\n\n        bytes memory expected809 = hex\"d5a7f8d8e1dd96bdf601\";\n        uint64 value809 = 17760608059192644565;\n\n        Buffer.buffer memory result809 = Leb128.encodeUnsignedLeb128FromUInt64(value809);\n\n        require(keccak256(result809.buf) == keccak256(expected809), \"'17760608059192644565' is not returning 'd5a7f8d8e1dd96bdf601'\");\n\n        bytes memory expected810 = hex\"cd868de1c9a4abb461\";\n        uint64 value810 = 7019050392006902605;\n\n        Buffer.buffer memory result810 = Leb128.encodeUnsignedLeb128FromUInt64(value810);\n\n        require(keccak256(result810.buf) == keccak256(expected810), \"'7019050392006902605' is not returning 'cd868de1c9a4abb461'\");\n\n        bytes memory expected811 = hex\"c8c191d8bed4b1c873\";\n        uint64 value811 = 8327374118332948680;\n\n        Buffer.buffer memory result811 = Leb128.encodeUnsignedLeb128FromUInt64(value811);\n\n        require(keccak256(result811.buf) == keccak256(expected811), \"'8327374118332948680' is not returning 'c8c191d8bed4b1c873'\");\n\n        bytes memory expected812 = hex\"c5c4e1c4e8dbb2ca23\";\n        uint64 value812 = 2563897145003893317;\n\n        Buffer.buffer memory result812 = Leb128.encodeUnsignedLeb128FromUInt64(value812);\n\n        require(keccak256(result812.buf) == keccak256(expected812), \"'2563897145003893317' is not returning 'c5c4e1c4e8dbb2ca23'\");\n\n        bytes memory expected813 = hex\"d9c9c6fcaad8eebaaf01\";\n        uint64 value813 = 12643216874244515033;\n\n        Buffer.buffer memory result813 = Leb128.encodeUnsignedLeb128FromUInt64(value813);\n\n        require(keccak256(result813.buf) == keccak256(expected813), \"'12643216874244515033' is not returning 'd9c9c6fcaad8eebaaf01'\");\n\n        bytes memory expected814 = hex\"8e8bd58e9aee9c88b601\";\n        uint64 value814 = 13119112646413862286;\n\n        Buffer.buffer memory result814 = Leb128.encodeUnsignedLeb128FromUInt64(value814);\n\n        require(keccak256(result814.buf) == keccak256(expected814), \"'13119112646413862286' is not returning '8e8bd58e9aee9c88b601'\");\n\n        bytes memory expected815 = hex\"dd8afef0c7e3d4a7fb01\";\n        uint64 value815 = 18108784008520238429;\n\n        Buffer.buffer memory result815 = Leb128.encodeUnsignedLeb128FromUInt64(value815);\n\n        require(keccak256(result815.buf) == keccak256(expected815), \"'18108784008520238429' is not returning 'dd8afef0c7e3d4a7fb01'\");\n\n        bytes memory expected816 = hex\"f5f7f3a2b1cdccff19\";\n        uint64 value816 = 1873271405493943285;\n\n        Buffer.buffer memory result816 = Leb128.encodeUnsignedLeb128FromUInt64(value816);\n\n        require(keccak256(result816.buf) == keccak256(expected816), \"'1873271405493943285' is not returning 'f5f7f3a2b1cdccff19'\");\n\n        bytes memory expected817 = hex\"c8cdd7979fe781957b\";\n        uint64 value817 = 8874913961157715656;\n\n        Buffer.buffer memory result817 = Leb128.encodeUnsignedLeb128FromUInt64(value817);\n\n        require(keccak256(result817.buf) == keccak256(expected817), \"'8874913961157715656' is not returning 'c8cdd7979fe781957b'\");\n\n        bytes memory expected818 = hex\"bf8adddae4ce9a95a801\";\n        uint64 value818 = 12117614803696436543;\n\n        Buffer.buffer memory result818 = Leb128.encodeUnsignedLeb128FromUInt64(value818);\n\n        require(keccak256(result818.buf) == keccak256(expected818), \"'12117614803696436543' is not returning 'bf8adddae4ce9a95a801'\");\n\n        bytes memory expected819 = hex\"b1b6aab58493c985bd01\";\n        uint64 value819 = 13622021734351412017;\n\n        Buffer.buffer memory result819 = Leb128.encodeUnsignedLeb128FromUInt64(value819);\n\n        require(keccak256(result819.buf) == keccak256(expected819), \"'13622021734351412017' is not returning 'b1b6aab58493c985bd01'\");\n\n        bytes memory expected820 = hex\"c6a3dcb4bca7b1e89b01\";\n        uint64 value820 = 11227690731560178118;\n\n        Buffer.buffer memory result820 = Leb128.encodeUnsignedLeb128FromUInt64(value820);\n\n        require(keccak256(result820.buf) == keccak256(expected820), \"'11227690731560178118' is not returning 'c6a3dcb4bca7b1e89b01'\");\n\n        bytes memory expected821 = hex\"9dfff597daa88c9bd101\";\n        uint64 value821 = 15075290977826340765;\n\n        Buffer.buffer memory result821 = Leb128.encodeUnsignedLeb128FromUInt64(value821);\n\n        require(keccak256(result821.buf) == keccak256(expected821), \"'15075290977826340765' is not returning '9dfff597daa88c9bd101'\");\n\n        bytes memory expected822 = hex\"d2b4cb90e4e4d7be34\";\n        uint64 value822 = 3782283879983012434;\n\n        Buffer.buffer memory result822 = Leb128.encodeUnsignedLeb128FromUInt64(value822);\n\n        require(keccak256(result822.buf) == keccak256(expected822), \"'3782283879983012434' is not returning 'd2b4cb90e4e4d7be34'\");\n\n        bytes memory expected823 = hex\"e8a8dfeab2dca6de1f\";\n        uint64 value823 = 2286873011306353768;\n\n        Buffer.buffer memory result823 = Leb128.encodeUnsignedLeb128FromUInt64(value823);\n\n        require(keccak256(result823.buf) == keccak256(expected823), \"'2286873011306353768' is not returning 'e8a8dfeab2dca6de1f'\");\n\n        bytes memory expected824 = hex\"f5ad9fc8b8dff5efc801\";\n        uint64 value824 = 14474524103216191221;\n\n        Buffer.buffer memory result824 = Leb128.encodeUnsignedLeb128FromUInt64(value824);\n\n        require(keccak256(result824.buf) == keccak256(expected824), \"'14474524103216191221' is not returning 'f5ad9fc8b8dff5efc801'\");\n\n        bytes memory expected825 = hex\"d6a49ec6bdaa94f99101\";\n        uint64 value825 = 10516557500424622678;\n\n        Buffer.buffer memory result825 = Leb128.encodeUnsignedLeb128FromUInt64(value825);\n\n        require(keccak256(result825.buf) == keccak256(expected825), \"'10516557500424622678' is not returning 'd6a49ec6bdaa94f99101'\");\n\n        bytes memory expected826 = hex\"c6c2cf94d6b5f18457\";\n        uint64 value826 = 6271761304563999046;\n\n        Buffer.buffer memory result826 = Leb128.encodeUnsignedLeb128FromUInt64(value826);\n\n        require(keccak256(result826.buf) == keccak256(expected826), \"'6271761304563999046' is not returning 'c6c2cf94d6b5f18457'\");\n\n        bytes memory expected827 = hex\"9afb9f909ff9c89861\";\n        uint64 value827 = 7003418245793840538;\n\n        Buffer.buffer memory result827 = Leb128.encodeUnsignedLeb128FromUInt64(value827);\n\n        require(keccak256(result827.buf) == keccak256(expected827), \"'7003418245793840538' is not returning '9afb9f909ff9c89861'\");\n\n        bytes memory expected828 = hex\"82a2cbdce699ace141\";\n        uint64 value828 = 4738544158561718530;\n\n        Buffer.buffer memory result828 = Leb128.encodeUnsignedLeb128FromUInt64(value828);\n\n        require(keccak256(result828.buf) == keccak256(expected828), \"'4738544158561718530' is not returning '82a2cbdce699ace141'\");\n\n        bytes memory expected829 = hex\"d792addbae8e9ad12b\";\n        uint64 value829 = 3144190332643264855;\n\n        Buffer.buffer memory result829 = Leb128.encodeUnsignedLeb128FromUInt64(value829);\n\n        require(keccak256(result829.buf) == keccak256(expected829), \"'3144190332643264855' is not returning 'd792addbae8e9ad12b'\");\n\n        bytes memory expected830 = hex\"86b6def9c5e633\";\n        uint64 value830 = 227823842728710;\n\n        Buffer.buffer memory result830 = Leb128.encodeUnsignedLeb128FromUInt64(value830);\n\n        require(keccak256(result830.buf) == keccak256(expected830), \"'227823842728710' is not returning '86b6def9c5e633'\");\n\n        bytes memory expected831 = hex\"c3f8baa5c2a8deb39001\";\n        uint64 value831 = 10405418797642988611;\n\n        Buffer.buffer memory result831 = Leb128.encodeUnsignedLeb128FromUInt64(value831);\n\n        require(keccak256(result831.buf) == keccak256(expected831), \"'10405418797642988611' is not returning 'c3f8baa5c2a8deb39001'\");\n\n        bytes memory expected832 = hex\"b6bacde3aaf0c79775\";\n        uint64 value832 = 8444002472442420534;\n\n        Buffer.buffer memory result832 = Leb128.encodeUnsignedLeb128FromUInt64(value832);\n\n        require(keccak256(result832.buf) == keccak256(expected832), \"'8444002472442420534' is not returning 'b6bacde3aaf0c79775'\");\n\n        bytes memory expected833 = hex\"d8a8c9b2998093e935\";\n        uint64 value833 = 3878245798820074584;\n\n        Buffer.buffer memory result833 = Leb128.encodeUnsignedLeb128FromUInt64(value833);\n\n        require(keccak256(result833.buf) == keccak256(expected833), \"'3878245798820074584' is not returning 'd8a8c9b2998093e935'\");\n\n        bytes memory expected834 = hex\"a593d5f29a8ee7986f\";\n        uint64 value834 = 8012357224138885541;\n\n        Buffer.buffer memory result834 = Leb128.encodeUnsignedLeb128FromUInt64(value834);\n\n        require(keccak256(result834.buf) == keccak256(expected834), \"'8012357224138885541' is not returning 'a593d5f29a8ee7986f'\");\n\n        bytes memory expected835 = hex\"8289e4fc9f91cb81a601\";\n        uint64 value835 = 11962454006436529282;\n\n        Buffer.buffer memory result835 = Leb128.encodeUnsignedLeb128FromUInt64(value835);\n\n        require(keccak256(result835.buf) == keccak256(expected835), \"'11962454006436529282' is not returning '8289e4fc9f91cb81a601'\");\n\n        bytes memory expected836 = hex\"b8aaecc391c596e3af01\";\n        uint64 value836 = 12665910134576977208;\n\n        Buffer.buffer memory result836 = Leb128.encodeUnsignedLeb128FromUInt64(value836);\n\n        require(keccak256(result836.buf) == keccak256(expected836), \"'12665910134576977208' is not returning 'b8aaecc391c596e3af01'\");\n\n        bytes memory expected837 = hex\"a7ec9a89bb8ada8fd101\";\n        uint64 value837 = 15068877586868647463;\n\n        Buffer.buffer memory result837 = Leb128.encodeUnsignedLeb128FromUInt64(value837);\n\n        require(keccak256(result837.buf) == keccak256(expected837), \"'15068877586868647463' is not returning 'a7ec9a89bb8ada8fd101'\");\n\n        bytes memory expected838 = hex\"81c5c3f9cd9acdb63a\";\n        uint64 value838 = 4210079315543515777;\n\n        Buffer.buffer memory result838 = Leb128.encodeUnsignedLeb128FromUInt64(value838);\n\n        require(keccak256(result838.buf) == keccak256(expected838), \"'4210079315543515777' is not returning '81c5c3f9cd9acdb63a'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated13.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated13Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected840 = hex\"81c7f6fc90b1a8c29101\";\n        uint64 value840 = 10485683442469938049;\n\n        Buffer.buffer memory result840 = Leb128.encodeUnsignedLeb128FromUInt64(value840);\n\n        require(keccak256(result840.buf) == keccak256(expected840), \"'10485683442469938049' is not returning '81c7f6fc90b1a8c29101'\");\n\n        bytes memory expected841 = hex\"90fc9ce59f8db5be9b01\";\n        uint64 value841 = 11204063524666424848;\n\n        Buffer.buffer memory result841 = Leb128.encodeUnsignedLeb128FromUInt64(value841);\n\n        require(keccak256(result841.buf) == keccak256(expected841), \"'11204063524666424848' is not returning '90fc9ce59f8db5be9b01'\");\n\n        bytes memory expected842 = hex\"f486a2afe1f7fd924b\";\n        uint64 value842 = 5415006522766295924;\n\n        Buffer.buffer memory result842 = Leb128.encodeUnsignedLeb128FromUInt64(value842);\n\n        require(keccak256(result842.buf) == keccak256(expected842), \"'5415006522766295924' is not returning 'f486a2afe1f7fd924b'\");\n\n        bytes memory expected843 = hex\"fd98bfbce5ffe5a140\";\n        uint64 value843 = 4630711960513531005;\n\n        Buffer.buffer memory result843 = Leb128.encodeUnsignedLeb128FromUInt64(value843);\n\n        require(keccak256(result843.buf) == keccak256(expected843), \"'4630711960513531005' is not returning 'fd98bfbce5ffe5a140'\");\n\n        bytes memory expected844 = hex\"deaccbbbcc91d7a137\";\n        uint64 value844 = 3982128255237019230;\n\n        Buffer.buffer memory result844 = Leb128.encodeUnsignedLeb128FromUInt64(value844);\n\n        require(keccak256(result844.buf) == keccak256(expected844), \"'3982128255237019230' is not returning 'deaccbbbcc91d7a137'\");\n\n        bytes memory expected845 = hex\"bd80b6cd9198edea5b\";\n        uint64 value845 = 6617393968943300669;\n\n        Buffer.buffer memory result845 = Leb128.encodeUnsignedLeb128FromUInt64(value845);\n\n        require(keccak256(result845.buf) == keccak256(expected845), \"'6617393968943300669' is not returning 'bd80b6cd9198edea5b'\");\n\n        bytes memory expected846 = hex\"e4d3f497d688c9f613\";\n        uint64 value846 = 1435843736633158116;\n\n        Buffer.buffer memory result846 = Leb128.encodeUnsignedLeb128FromUInt64(value846);\n\n        require(keccak256(result846.buf) == keccak256(expected846), \"'1435843736633158116' is not returning 'e4d3f497d688c9f613'\");\n\n        bytes memory expected847 = hex\"ccb9dfd9b8c2e9f1c401\";\n        uint64 value847 = 14187365854017477836;\n\n        Buffer.buffer memory result847 = Leb128.encodeUnsignedLeb128FromUInt64(value847);\n\n        require(keccak256(result847.buf) == keccak256(expected847), \"'14187365854017477836' is not returning 'ccb9dfd9b8c2e9f1c401'\");\n\n        bytes memory expected848 = hex\"e9c296e2cee2f59c79\";\n        uint64 value848 = 8735249437125091689;\n\n        Buffer.buffer memory result848 = Leb128.encodeUnsignedLeb128FromUInt64(value848);\n\n        require(keccak256(result848.buf) == keccak256(expected848), \"'8735249437125091689' is not returning 'e9c296e2cee2f59c79'\");\n\n        bytes memory expected849 = hex\"ebbbddcabd82c7be58\";\n        uint64 value849 = 6376283519002828267;\n\n        Buffer.buffer memory result849 = Leb128.encodeUnsignedLeb128FromUInt64(value849);\n\n        require(keccak256(result849.buf) == keccak256(expected849), \"'6376283519002828267' is not returning 'ebbbddcabd82c7be58'\");\n\n        bytes memory expected850 = hex\"9fdbacdcacc891e132\";\n        uint64 value850 = 3657563100074945951;\n\n        Buffer.buffer memory result850 = Leb128.encodeUnsignedLeb128FromUInt64(value850);\n\n        require(keccak256(result850.buf) == keccak256(expected850), \"'3657563100074945951' is not returning '9fdbacdcacc891e132'\");\n\n        bytes memory expected851 = hex\"a9d4edc2a3a9e7ca3d\";\n        uint64 value851 = 4437625949942147625;\n\n        Buffer.buffer memory result851 = Leb128.encodeUnsignedLeb128FromUInt64(value851);\n\n        require(keccak256(result851.buf) == keccak256(expected851), \"'4437625949942147625' is not returning 'a9d4edc2a3a9e7ca3d'\");\n\n        bytes memory expected852 = hex\"a8d6d8e1979c9a961a\";\n        uint64 value852 = 1885997661622250280;\n\n        Buffer.buffer memory result852 = Leb128.encodeUnsignedLeb128FromUInt64(value852);\n\n        require(keccak256(result852.buf) == keccak256(expected852), \"'1885997661622250280' is not returning 'a8d6d8e1979c9a961a'\");\n\n        bytes memory expected853 = hex\"9cb09fd294a2b19ae801\";\n        uint64 value853 = 16732215193639573532;\n\n        Buffer.buffer memory result853 = Leb128.encodeUnsignedLeb128FromUInt64(value853);\n\n        require(keccak256(result853.buf) == keccak256(expected853), \"'16732215193639573532' is not returning '9cb09fd294a2b19ae801'\");\n\n        bytes memory expected854 = hex\"bdf3f6b79a83ead24e\";\n        uint64 value854 = 5667120534244932029;\n\n        Buffer.buffer memory result854 = Leb128.encodeUnsignedLeb128FromUInt64(value854);\n\n        require(keccak256(result854.buf) == keccak256(expected854), \"'5667120534244932029' is not returning 'bdf3f6b79a83ead24e'\");\n\n        bytes memory expected855 = hex\"d4f5fb82de88d58ea401\";\n        uint64 value855 = 11825700855638588116;\n\n        Buffer.buffer memory result855 = Leb128.encodeUnsignedLeb128FromUInt64(value855);\n\n        require(keccak256(result855.buf) == keccak256(expected855), \"'11825700855638588116' is not returning 'd4f5fb82de88d58ea401'\");\n\n        bytes memory expected856 = hex\"95fcc4dbe7d1cbea3e\";\n        uint64 value856 = 4527576189882154517;\n\n        Buffer.buffer memory result856 = Leb128.encodeUnsignedLeb128FromUInt64(value856);\n\n        require(keccak256(result856.buf) == keccak256(expected856), \"'4527576189882154517' is not returning '95fcc4dbe7d1cbea3e'\");\n\n        bytes memory expected857 = hex\"c79381dfe8c3f9e211\";\n        uint64 value857 = 1280682687926913479;\n\n        Buffer.buffer memory result857 = Leb128.encodeUnsignedLeb128FromUInt64(value857);\n\n        require(keccak256(result857.buf) == keccak256(expected857), \"'1280682687926913479' is not returning 'c79381dfe8c3f9e211'\");\n\n        bytes memory expected858 = hex\"b4b88ba3d3cde4958701\";\n        uint64 value858 = 9740039616846814260;\n\n        Buffer.buffer memory result858 = Leb128.encodeUnsignedLeb128FromUInt64(value858);\n\n        require(keccak256(result858.buf) == keccak256(expected858), \"'9740039616846814260' is not returning 'b4b88ba3d3cde4958701'\");\n\n        bytes memory expected859 = hex\"80c5f0aad9eec7f436\";\n        uint64 value859 = 3956728337499169408;\n\n        Buffer.buffer memory result859 = Leb128.encodeUnsignedLeb128FromUInt64(value859);\n\n        require(keccak256(result859.buf) == keccak256(expected859), \"'3956728337499169408' is not returning '80c5f0aad9eec7f436'\");\n\n        bytes memory expected860 = hex\"e9e3fbc98fb4ecd8f001\";\n        uint64 value860 = 17343838944915026409;\n\n        Buffer.buffer memory result860 = Leb128.encodeUnsignedLeb128FromUInt64(value860);\n\n        require(keccak256(result860.buf) == keccak256(expected860), \"'17343838944915026409' is not returning 'e9e3fbc98fb4ecd8f001'\");\n\n        bytes memory expected861 = hex\"9ab8b1f899ad8ecae701\";\n        uint64 value861 = 16687025645117266970;\n\n        Buffer.buffer memory result861 = Leb128.encodeUnsignedLeb128FromUInt64(value861);\n\n        require(keccak256(result861.buf) == keccak256(expected861), \"'16687025645117266970' is not returning '9ab8b1f899ad8ecae701'\");\n\n        bytes memory expected862 = hex\"8ade8bf6b3a799bdd901\";\n        uint64 value862 = 15670949158519500554;\n\n        Buffer.buffer memory result862 = Leb128.encodeUnsignedLeb128FromUInt64(value862);\n\n        require(keccak256(result862.buf) == keccak256(expected862), \"'15670949158519500554' is not returning '8ade8bf6b3a799bdd901'\");\n\n        bytes memory expected863 = hex\"a397bd9e8080cec1e401\";\n        uint64 value863 = 16466066235311737763;\n\n        Buffer.buffer memory result863 = Leb128.encodeUnsignedLeb128FromUInt64(value863);\n\n        require(keccak256(result863.buf) == keccak256(expected863), \"'16466066235311737763' is not returning 'a397bd9e8080cec1e401'\");\n\n        bytes memory expected864 = hex\"f4bec8d0e0a78eb8d601\";\n        uint64 value864 = 15451913260127887220;\n\n        Buffer.buffer memory result864 = Leb128.encodeUnsignedLeb128FromUInt64(value864);\n\n        require(keccak256(result864.buf) == keccak256(expected864), \"'15451913260127887220' is not returning 'f4bec8d0e0a78eb8d601'\");\n\n        bytes memory expected865 = hex\"8581e5a187a4d6e18001\";\n        uint64 value865 = 9278357653237088389;\n\n        Buffer.buffer memory result865 = Leb128.encodeUnsignedLeb128FromUInt64(value865);\n\n        require(keccak256(result865.buf) == keccak256(expected865), \"'9278357653237088389' is not returning '8581e5a187a4d6e18001'\");\n\n        bytes memory expected866 = hex\"94adc58eeac092f70e\";\n        uint64 value866 = 1075878753333237396;\n\n        Buffer.buffer memory result866 = Leb128.encodeUnsignedLeb128FromUInt64(value866);\n\n        require(keccak256(result866.buf) == keccak256(expected866), \"'1075878753333237396' is not returning '94adc58eeac092f70e'\");\n\n        bytes memory expected867 = hex\"baafea93f5e0b3b931\";\n        uint64 value867 = 3563137885558970298;\n\n        Buffer.buffer memory result867 = Leb128.encodeUnsignedLeb128FromUInt64(value867);\n\n        require(keccak256(result867.buf) == keccak256(expected867), \"'3563137885558970298' is not returning 'baafea93f5e0b3b931'\");\n\n        bytes memory expected868 = hex\"a0a4af8cbfa7a2817b\";\n        uint64 value868 = 8863797907167105568;\n\n        Buffer.buffer memory result868 = Leb128.encodeUnsignedLeb128FromUInt64(value868);\n\n        require(keccak256(result868.buf) == keccak256(expected868), \"'8863797907167105568' is not returning 'a0a4af8cbfa7a2817b'\");\n\n        bytes memory expected869 = hex\"93ef8483e3a88a990a\";\n        uint64 value869 = 734695070650939283;\n\n        Buffer.buffer memory result869 = Leb128.encodeUnsignedLeb128FromUInt64(value869);\n\n        require(keccak256(result869.buf) == keccak256(expected869), \"'734695070650939283' is not returning '93ef8483e3a88a990a'\");\n\n        bytes memory expected870 = hex\"d7c589a8eff6bd866f\";\n        uint64 value870 = 8002043003097211607;\n\n        Buffer.buffer memory result870 = Leb128.encodeUnsignedLeb128FromUInt64(value870);\n\n        require(keccak256(result870.buf) == keccak256(expected870), \"'8002043003097211607' is not returning 'd7c589a8eff6bd866f'\");\n\n        bytes memory expected871 = hex\"81d5c1ca88b79b8848\";\n        uint64 value871 = 5192771009703340673;\n\n        Buffer.buffer memory result871 = Leb128.encodeUnsignedLeb128FromUInt64(value871);\n\n        require(keccak256(result871.buf) == keccak256(expected871), \"'5192771009703340673' is not returning '81d5c1ca88b79b8848'\");\n\n        bytes memory expected872 = hex\"ce97c1af80b7eaf2b601\";\n        uint64 value872 = 13179126492408335310;\n\n        Buffer.buffer memory result872 = Leb128.encodeUnsignedLeb128FromUInt64(value872);\n\n        require(keccak256(result872.buf) == keccak256(expected872), \"'13179126492408335310' is not returning 'ce97c1af80b7eaf2b601'\");\n\n        bytes memory expected873 = hex\"f7b0fef2a08e99f2f601\";\n        uint64 value873 = 17790454869050497143;\n\n        Buffer.buffer memory result873 = Leb128.encodeUnsignedLeb128FromUInt64(value873);\n\n        require(keccak256(result873.buf) == keccak256(expected873), \"'17790454869050497143' is not returning 'f7b0fef2a08e99f2f601'\");\n\n        bytes memory expected874 = hex\"aac8bfc09ae4bfda69\";\n        uint64 value874 = 7616993389808968746;\n\n        Buffer.buffer memory result874 = Leb128.encodeUnsignedLeb128FromUInt64(value874);\n\n        require(keccak256(result874.buf) == keccak256(expected874), \"'7616993389808968746' is not returning 'aac8bfc09ae4bfda69'\");\n\n        bytes memory expected875 = hex\"8cf78dacadf1d7bbe201\";\n        uint64 value875 = 16318616824692571020;\n\n        Buffer.buffer memory result875 = Leb128.encodeUnsignedLeb128FromUInt64(value875);\n\n        require(keccak256(result875.buf) == keccak256(expected875), \"'16318616824692571020' is not returning '8cf78dacadf1d7bbe201'\");\n\n        bytes memory expected876 = hex\"92a1ae81c4efb7d379\";\n        uint64 value876 = 8765939449468784786;\n\n        Buffer.buffer memory result876 = Leb128.encodeUnsignedLeb128FromUInt64(value876);\n\n        require(keccak256(result876.buf) == keccak256(expected876), \"'8765939449468784786' is not returning '92a1ae81c4efb7d379'\");\n\n        bytes memory expected877 = hex\"a9c4fbc697bdd88501\";\n        uint64 value877 = 75261474164892201;\n\n        Buffer.buffer memory result877 = Leb128.encodeUnsignedLeb128FromUInt64(value877);\n\n        require(keccak256(result877.buf) == keccak256(expected877), \"'75261474164892201' is not returning 'a9c4fbc697bdd88501'\");\n\n        bytes memory expected878 = hex\"ee91ae86a2f4c0be2b\";\n        uint64 value878 = 3133664910589528302;\n\n        Buffer.buffer memory result878 = Leb128.encodeUnsignedLeb128FromUInt64(value878);\n\n        require(keccak256(result878.buf) == keccak256(expected878), \"'3133664910589528302' is not returning 'ee91ae86a2f4c0be2b'\");\n\n        bytes memory expected879 = hex\"bcdc9ab483cad4c1d101\";\n        uint64 value879 = 15097000880341691964;\n\n        Buffer.buffer memory result879 = Leb128.encodeUnsignedLeb128FromUInt64(value879);\n\n        require(keccak256(result879.buf) == keccak256(expected879), \"'15097000880341691964' is not returning 'bcdc9ab483cad4c1d101'\");\n\n        bytes memory expected880 = hex\"e1e4a3a2dfc9f0f929\";\n        uint64 value880 = 3022973414962426465;\n\n        Buffer.buffer memory result880 = Leb128.encodeUnsignedLeb128FromUInt64(value880);\n\n        require(keccak256(result880.buf) == keccak256(expected880), \"'3022973414962426465' is not returning 'e1e4a3a2dfc9f0f929'\");\n\n        bytes memory expected881 = hex\"aacfbcb19785a1ec4d\";\n        uint64 value881 = 5609378649501280170;\n\n        Buffer.buffer memory result881 = Leb128.encodeUnsignedLeb128FromUInt64(value881);\n\n        require(keccak256(result881.buf) == keccak256(expected881), \"'5609378649501280170' is not returning 'aacfbcb19785a1ec4d'\");\n\n        bytes memory expected882 = hex\"a2f4e6e9d1f6f3df0d\";\n        uint64 value882 = 990738819831151138;\n\n        Buffer.buffer memory result882 = Leb128.encodeUnsignedLeb128FromUInt64(value882);\n\n        require(keccak256(result882.buf) == keccak256(expected882), \"'990738819831151138' is not returning 'a2f4e6e9d1f6f3df0d'\");\n\n        bytes memory expected883 = hex\"dbb6c7e2abadbbafab01\";\n        uint64 value883 = 12348568270978276187;\n\n        Buffer.buffer memory result883 = Leb128.encodeUnsignedLeb128FromUInt64(value883);\n\n        require(keccak256(result883.buf) == keccak256(expected883), \"'12348568270978276187' is not returning 'dbb6c7e2abadbbafab01'\");\n\n        bytes memory expected884 = hex\"f09adf97a682f0c7ea01\";\n        uint64 value884 = 16901939111747112304;\n\n        Buffer.buffer memory result884 = Leb128.encodeUnsignedLeb128FromUInt64(value884);\n\n        require(keccak256(result884.buf) == keccak256(expected884), \"'16901939111747112304' is not returning 'f09adf97a682f0c7ea01'\");\n\n        bytes memory expected885 = hex\"9993be8ef3efed828801\";\n        uint64 value885 = 9801441920966166937;\n\n        Buffer.buffer memory result885 = Leb128.encodeUnsignedLeb128FromUInt64(value885);\n\n        require(keccak256(result885.buf) == keccak256(expected885), \"'9801441920966166937' is not returning '9993be8ef3efed828801'\");\n\n        bytes memory expected886 = hex\"f2dcf6e4efe1abce8b01\";\n        uint64 value886 = 10060108146541440626;\n\n        Buffer.buffer memory result886 = Leb128.encodeUnsignedLeb128FromUInt64(value886);\n\n        require(keccak256(result886.buf) == keccak256(expected886), \"'10060108146541440626' is not returning 'f2dcf6e4efe1abce8b01'\");\n\n        bytes memory expected887 = hex\"bf9b94bb97c3c0859d01\";\n        uint64 value887 = 11316140797099052479;\n\n        Buffer.buffer memory result887 = Leb128.encodeUnsignedLeb128FromUInt64(value887);\n\n        require(keccak256(result887.buf) == keccak256(expected887), \"'11316140797099052479' is not returning 'bf9b94bb97c3c0859d01'\");\n\n        bytes memory expected888 = hex\"fcddb790b8e0849411\";\n        uint64 value888 = 1236259003500982012;\n\n        Buffer.buffer memory result888 = Leb128.encodeUnsignedLeb128FromUInt64(value888);\n\n        require(keccak256(result888.buf) == keccak256(expected888), \"'1236259003500982012' is not returning 'fcddb790b8e0849411'\");\n\n        bytes memory expected889 = hex\"b6eed992c0d6e7bce901\";\n        uint64 value889 = 16823652378989721398;\n\n        Buffer.buffer memory result889 = Leb128.encodeUnsignedLeb128FromUInt64(value889);\n\n        require(keccak256(result889.buf) == keccak256(expected889), \"'16823652378989721398' is not returning 'b6eed992c0d6e7bce901'\");\n\n        bytes memory expected890 = hex\"c3dfcaef9cdce9c1d701\";\n        uint64 value890 = 15529439428856688579;\n\n        Buffer.buffer memory result890 = Leb128.encodeUnsignedLeb128FromUInt64(value890);\n\n        require(keccak256(result890.buf) == keccak256(expected890), \"'15529439428856688579' is not returning 'c3dfcaef9cdce9c1d701'\");\n\n        bytes memory expected891 = hex\"f9a3d4a3a7c1b1928e01\";\n        uint64 value891 = 10242529200753152505;\n\n        Buffer.buffer memory result891 = Leb128.encodeUnsignedLeb128FromUInt64(value891);\n\n        require(keccak256(result891.buf) == keccak256(expected891), \"'10242529200753152505' is not returning 'f9a3d4a3a7c1b1928e01'\");\n\n        bytes memory expected892 = hex\"dafbffbd8990cbe548\";\n        uint64 value892 = 5245335121816452570;\n\n        Buffer.buffer memory result892 = Leb128.encodeUnsignedLeb128FromUInt64(value892);\n\n        require(keccak256(result892.buf) == keccak256(expected892), \"'5245335121816452570' is not returning 'dafbffbd8990cbe548'\");\n\n        bytes memory expected893 = hex\"8baca2dfb8bacf9026\";\n        uint64 value893 = 2747545226467382795;\n\n        Buffer.buffer memory result893 = Leb128.encodeUnsignedLeb128FromUInt64(value893);\n\n        require(keccak256(result893.buf) == keccak256(expected893), \"'2747545226467382795' is not returning '8baca2dfb8bacf9026'\");\n\n        bytes memory expected894 = hex\"f3ddeff3ac8485f0bc01\";\n        uint64 value894 = 13609900213639311091;\n\n        Buffer.buffer memory result894 = Leb128.encodeUnsignedLeb128FromUInt64(value894);\n\n        require(keccak256(result894.buf) == keccak256(expected894), \"'13609900213639311091' is not returning 'f3ddeff3ac8485f0bc01'\");\n\n        bytes memory expected895 = hex\"99979af8a2b2ca811a\";\n        uint64 value895 = 1874387577747180441;\n\n        Buffer.buffer memory result895 = Leb128.encodeUnsignedLeb128FromUInt64(value895);\n\n        require(keccak256(result895.buf) == keccak256(expected895), \"'1874387577747180441' is not returning '99979af8a2b2ca811a'\");\n\n        bytes memory expected896 = hex\"a38ca3d6f7ebaec88e01\";\n        uint64 value896 = 10272916768788366883;\n\n        Buffer.buffer memory result896 = Leb128.encodeUnsignedLeb128FromUInt64(value896);\n\n        require(keccak256(result896.buf) == keccak256(expected896), \"'10272916768788366883' is not returning 'a38ca3d6f7ebaec88e01'\");\n\n        bytes memory expected897 = hex\"ec83ddc7bbcfadbb0f\";\n        uint64 value897 = 1114278600321221100;\n\n        Buffer.buffer memory result897 = Leb128.encodeUnsignedLeb128FromUInt64(value897);\n\n        require(keccak256(result897.buf) == keccak256(expected897), \"'1114278600321221100' is not returning 'ec83ddc7bbcfadbb0f'\");\n\n        bytes memory expected898 = hex\"b8838fbdefb0fcac8901\";\n        uint64 value898 = 9897207218105991608;\n\n        Buffer.buffer memory result898 = Leb128.encodeUnsignedLeb128FromUInt64(value898);\n\n        require(keccak256(result898.buf) == keccak256(expected898), \"'9897207218105991608' is not returning 'b8838fbdefb0fcac8901'\");\n\n        bytes memory expected899 = hex\"ffcbd6e2d4ed8be37a\";\n        uint64 value899 = 8846810664494540287;\n\n        Buffer.buffer memory result899 = Leb128.encodeUnsignedLeb128FromUInt64(value899);\n\n        require(keccak256(result899.buf) == keccak256(expected899), \"'8846810664494540287' is not returning 'ffcbd6e2d4ed8be37a'\");\n\n        bytes memory expected900 = hex\"df8b88f3afd0a4ca9201\";\n        uint64 value900 = 10562228117401896415;\n\n        Buffer.buffer memory result900 = Leb128.encodeUnsignedLeb128FromUInt64(value900);\n\n        require(keccak256(result900.buf) == keccak256(expected900), \"'10562228117401896415' is not returning 'df8b88f3afd0a4ca9201'\");\n\n        bytes memory expected901 = hex\"cbbbf2a0b3edf7ba77\";\n        uint64 value901 = 8608031914317356491;\n\n        Buffer.buffer memory result901 = Leb128.encodeUnsignedLeb128FromUInt64(value901);\n\n        require(keccak256(result901.buf) == keccak256(expected901), \"'8608031914317356491' is not returning 'cbbbf2a0b3edf7ba77'\");\n\n        bytes memory expected902 = hex\"a0f6acaf8ad988f219\";\n        uint64 value902 = 1865654390810688288;\n\n        Buffer.buffer memory result902 = Leb128.encodeUnsignedLeb128FromUInt64(value902);\n\n        require(keccak256(result902.buf) == keccak256(expected902), \"'1865654390810688288' is not returning 'a0f6acaf8ad988f219'\");\n\n        bytes memory expected903 = hex\"80fde3c6b7cbbaeca701\";\n        uint64 value903 = 12094674477893877376;\n\n        Buffer.buffer memory result903 = Leb128.encodeUnsignedLeb128FromUInt64(value903);\n\n        require(keccak256(result903.buf) == keccak256(expected903), \"'12094674477893877376' is not returning '80fde3c6b7cbbaeca701'\");\n\n        bytes memory expected904 = hex\"c6bfe6ee99d8e3e376\";\n        uint64 value904 = 8558966579069034438;\n\n        Buffer.buffer memory result904 = Leb128.encodeUnsignedLeb128FromUInt64(value904);\n\n        require(keccak256(result904.buf) == keccak256(expected904), \"'8558966579069034438' is not returning 'c6bfe6ee99d8e3e376'\");\n\n        bytes memory expected905 = hex\"8d8bf484c5cfb79b48\";\n        uint64 value905 = 5203591044982965645;\n\n        Buffer.buffer memory result905 = Leb128.encodeUnsignedLeb128FromUInt64(value905);\n\n        require(keccak256(result905.buf) == keccak256(expected905), \"'5203591044982965645' is not returning '8d8bf484c5cfb79b48'\");\n\n        bytes memory expected906 = hex\"9e82cd8495cea6f29b01\";\n        uint64 value906 = 11233273182042669342;\n\n        Buffer.buffer memory result906 = Leb128.encodeUnsignedLeb128FromUInt64(value906);\n\n        require(keccak256(result906.buf) == keccak256(expected906), \"'11233273182042669342' is not returning '9e82cd8495cea6f29b01'\");\n\n        bytes memory expected907 = hex\"91eebae9d0f592a4de01\";\n        uint64 value907 = 16017135281365759761;\n\n        Buffer.buffer memory result907 = Leb128.encodeUnsignedLeb128FromUInt64(value907);\n\n        require(keccak256(result907.buf) == keccak256(expected907), \"'16017135281365759761' is not returning '91eebae9d0f592a4de01'\");\n\n        bytes memory expected908 = hex\"d1efcaf3f9f5b8b160\";\n        uint64 value908 = 6945363918775826385;\n\n        Buffer.buffer memory result908 = Leb128.encodeUnsignedLeb128FromUInt64(value908);\n\n        require(keccak256(result908.buf) == keccak256(expected908), \"'6945363918775826385' is not returning 'd1efcaf3f9f5b8b160'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated14.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated14Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected910 = hex\"dccb83cfb097edbc4c\";\n        uint64 value910 = 5510634334482130396;\n\n        Buffer.buffer memory result910 = Leb128.encodeUnsignedLeb128FromUInt64(value910);\n\n        require(keccak256(result910.buf) == keccak256(expected910), \"'5510634334482130396' is not returning 'dccb83cfb097edbc4c'\");\n\n        bytes memory expected911 = hex\"c0f291e4ea8fc0b6f201\";\n        uint64 value911 = 17468619073700264256;\n\n        Buffer.buffer memory result911 = Leb128.encodeUnsignedLeb128FromUInt64(value911);\n\n        require(keccak256(result911.buf) == keccak256(expected911), \"'17468619073700264256' is not returning 'c0f291e4ea8fc0b6f201'\");\n\n        bytes memory expected912 = hex\"99b3bbb5a4f8899efd01\";\n        uint64 value912 = 18247503505561409945;\n\n        Buffer.buffer memory result912 = Leb128.encodeUnsignedLeb128FromUInt64(value912);\n\n        require(keccak256(result912.buf) == keccak256(expected912), \"'18247503505561409945' is not returning '99b3bbb5a4f8899efd01'\");\n\n        bytes memory expected913 = hex\"f4b8b5b4a1f3d0cc1b\";\n        uint64 value913 = 1988695039543172212;\n\n        Buffer.buffer memory result913 = Leb128.encodeUnsignedLeb128FromUInt64(value913);\n\n        require(keccak256(result913.buf) == keccak256(expected913), \"'1988695039543172212' is not returning 'f4b8b5b4a1f3d0cc1b'\");\n\n        bytes memory expected914 = hex\"909ceacb8edbe7aabe01\";\n        uint64 value914 = 13715042894693961232;\n\n        Buffer.buffer memory result914 = Leb128.encodeUnsignedLeb128FromUInt64(value914);\n\n        require(keccak256(result914.buf) == keccak256(expected914), \"'13715042894693961232' is not returning '909ceacb8edbe7aabe01'\");\n\n        bytes memory expected915 = hex\"a29ca3c2cef9b5821c\";\n        uint64 value915 = 2018975808039210530;\n\n        Buffer.buffer memory result915 = Leb128.encodeUnsignedLeb128FromUInt64(value915);\n\n        require(keccak256(result915.buf) == keccak256(expected915), \"'2018975808039210530' is not returning 'a29ca3c2cef9b5821c'\");\n\n        bytes memory expected916 = hex\"91b7bffb81c1c3e3d401\";\n        uint64 value916 = 15332238884456094609;\n\n        Buffer.buffer memory result916 = Leb128.encodeUnsignedLeb128FromUInt64(value916);\n\n        require(keccak256(result916.buf) == keccak256(expected916), \"'15332238884456094609' is not returning '91b7bffb81c1c3e3d401'\");\n\n        bytes memory expected917 = hex\"f69a8de5f2dda69a6a\";\n        uint64 value917 = 7652912018846076278;\n\n        Buffer.buffer memory result917 = Leb128.encodeUnsignedLeb128FromUInt64(value917);\n\n        require(keccak256(result917.buf) == keccak256(expected917), \"'7652912018846076278' is not returning 'f69a8de5f2dda69a6a'\");\n\n        bytes memory expected918 = hex\"b2e2ea85b4a5eae9da01\";\n        uint64 value918 = 15768132723588903218;\n\n        Buffer.buffer memory result918 = Leb128.encodeUnsignedLeb128FromUInt64(value918);\n\n        require(keccak256(result918.buf) == keccak256(expected918), \"'15768132723588903218' is not returning 'b2e2ea85b4a5eae9da01'\");\n\n        bytes memory expected919 = hex\"d18799de8a8fa090f101\";\n        uint64 value919 = 17375028618161701841;\n\n        Buffer.buffer memory result919 = Leb128.encodeUnsignedLeb128FromUInt64(value919);\n\n        require(keccak256(result919.buf) == keccak256(expected919), \"'17375028618161701841' is not returning 'd18799de8a8fa090f101'\");\n\n        bytes memory expected920 = hex\"f3affec0fdb7a8a88c01\";\n        uint64 value920 = 10110759008783538163;\n\n        Buffer.buffer memory result920 = Leb128.encodeUnsignedLeb128FromUInt64(value920);\n\n        require(keccak256(result920.buf) == keccak256(expected920), \"'10110759008783538163' is not returning 'f3affec0fdb7a8a88c01'\");\n\n        bytes memory expected921 = hex\"82808b9f9caca3b22f\";\n        uint64 value921 = 3415009868491440130;\n\n        Buffer.buffer memory result921 = Leb128.encodeUnsignedLeb128FromUInt64(value921);\n\n        require(keccak256(result921.buf) == keccak256(expected921), \"'3415009868491440130' is not returning '82808b9f9caca3b22f'\");\n\n        bytes memory expected922 = hex\"acb8aeb4c2a8a2fad701\";\n        uint64 value922 = 15561213538269371436;\n\n        Buffer.buffer memory result922 = Leb128.encodeUnsignedLeb128FromUInt64(value922);\n\n        require(keccak256(result922.buf) == keccak256(expected922), \"'15561213538269371436' is not returning 'acb8aeb4c2a8a2fad701'\");\n\n        bytes memory expected923 = hex\"a59ff9a68fc5c5c5d401\";\n        uint64 value923 = 15315359322966216613;\n\n        Buffer.buffer memory result923 = Leb128.encodeUnsignedLeb128FromUInt64(value923);\n\n        require(keccak256(result923.buf) == keccak256(expected923), \"'15315359322966216613' is not returning 'a59ff9a68fc5c5c5d401'\");\n\n        bytes memory expected924 = hex\"8fc895b2be949e8f22\";\n        uint64 value924 = 2458535091929179151;\n\n        Buffer.buffer memory result924 = Leb128.encodeUnsignedLeb128FromUInt64(value924);\n\n        require(keccak256(result924.buf) == keccak256(expected924), \"'2458535091929179151' is not returning '8fc895b2be949e8f22'\");\n\n        bytes memory expected925 = hex\"eb9da081b197c6f2f001\";\n        uint64 value925 = 17358307530478456555;\n\n        Buffer.buffer memory result925 = Leb128.encodeUnsignedLeb128FromUInt64(value925);\n\n        require(keccak256(result925.buf) == keccak256(expected925), \"'17358307530478456555' is not returning 'eb9da081b197c6f2f001'\");\n\n        bytes memory expected926 = hex\"fef9bcd2ecedfd9766\";\n        uint64 value926 = 7363375970986704126;\n\n        Buffer.buffer memory result926 = Leb128.encodeUnsignedLeb128FromUInt64(value926);\n\n        require(keccak256(result926.buf) == keccak256(expected926), \"'7363375970986704126' is not returning 'fef9bcd2ecedfd9766'\");\n\n        bytes memory expected927 = hex\"88cecbbbd4ccf3c4cc01\";\n        uint64 value927 = 14738538189932390152;\n\n        Buffer.buffer memory result927 = Leb128.encodeUnsignedLeb128FromUInt64(value927);\n\n        require(keccak256(result927.buf) == keccak256(expected927), \"'14738538189932390152' is not returning '88cecbbbd4ccf3c4cc01'\");\n\n        bytes memory expected928 = hex\"aca4adb986c5b0b3c801\";\n        uint64 value928 = 14440442733995446828;\n\n        Buffer.buffer memory result928 = Leb128.encodeUnsignedLeb128FromUInt64(value928);\n\n        require(keccak256(result928.buf) == keccak256(expected928), \"'14440442733995446828' is not returning 'aca4adb986c5b0b3c801'\");\n\n        bytes memory expected929 = hex\"c4e5f292dfeb8eab13\";\n        uint64 value929 = 1393366409401905860;\n\n        Buffer.buffer memory result929 = Leb128.encodeUnsignedLeb128FromUInt64(value929);\n\n        require(keccak256(result929.buf) == keccak256(expected929), \"'1393366409401905860' is not returning 'c4e5f292dfeb8eab13'\");\n\n        bytes memory expected930 = hex\"d780ffb2c798a5af1a\";\n        uint64 value930 = 1900119664317415511;\n\n        Buffer.buffer memory result930 = Leb128.encodeUnsignedLeb128FromUInt64(value930);\n\n        require(keccak256(result930.buf) == keccak256(expected930), \"'1900119664317415511' is not returning 'd780ffb2c798a5af1a'\");\n\n        bytes memory expected931 = hex\"d6fbc49eb4faece7c301\";\n        uint64 value931 = 14109693877532310998;\n\n        Buffer.buffer memory result931 = Leb128.encodeUnsignedLeb128FromUInt64(value931);\n\n        require(keccak256(result931.buf) == keccak256(expected931), \"'14109693877532310998' is not returning 'd6fbc49eb4faece7c301'\");\n\n        bytes memory expected932 = hex\"82bcdde99b91e4fccc01\";\n        uint64 value932 = 14769995374197693954;\n\n        Buffer.buffer memory result932 = Leb128.encodeUnsignedLeb128FromUInt64(value932);\n\n        require(keccak256(result932.buf) == keccak256(expected932), \"'14769995374197693954' is not returning '82bcdde99b91e4fccc01'\");\n\n        bytes memory expected933 = hex\"b0a7e3f7d2e9d6b145\";\n        uint64 value933 = 4999940398370050992;\n\n        Buffer.buffer memory result933 = Leb128.encodeUnsignedLeb128FromUInt64(value933);\n\n        require(keccak256(result933.buf) == keccak256(expected933), \"'4999940398370050992' is not returning 'b0a7e3f7d2e9d6b145'\");\n\n        bytes memory expected934 = hex\"e49cb8fe88859b8646\";\n        uint64 value934 = 5047528203842621028;\n\n        Buffer.buffer memory result934 = Leb128.encodeUnsignedLeb128FromUInt64(value934);\n\n        require(keccak256(result934.buf) == keccak256(expected934), \"'5047528203842621028' is not returning 'e49cb8fe88859b8646'\");\n\n        bytes memory expected935 = hex\"a185a8fcaa98d1f067\";\n        uint64 value935 = 7485339658625876641;\n\n        Buffer.buffer memory result935 = Leb128.encodeUnsignedLeb128FromUInt64(value935);\n\n        require(keccak256(result935.buf) == keccak256(expected935), \"'7485339658625876641' is not returning 'a185a8fcaa98d1f067'\");\n\n        bytes memory expected936 = hex\"85a6f18fa5a0d1e09e01\";\n        uint64 value936 = 11439500404765512453;\n\n        Buffer.buffer memory result936 = Leb128.encodeUnsignedLeb128FromUInt64(value936);\n\n        require(keccak256(result936.buf) == keccak256(expected936), \"'11439500404765512453' is not returning '85a6f18fa5a0d1e09e01'\");\n\n        bytes memory expected937 = hex\"aeac8288c1e7f98070\";\n        uint64 value937 = 8070986252393944622;\n\n        Buffer.buffer memory result937 = Leb128.encodeUnsignedLeb128FromUInt64(value937);\n\n        require(keccak256(result937.buf) == keccak256(expected937), \"'8070986252393944622' is not returning 'aeac8288c1e7f98070'\");\n\n        bytes memory expected938 = hex\"a2afa0f6899ee3c90e\";\n        uint64 value938 = 1050338103191410594;\n\n        Buffer.buffer memory result938 = Leb128.encodeUnsignedLeb128FromUInt64(value938);\n\n        require(keccak256(result938.buf) == keccak256(expected938), \"'1050338103191410594' is not returning 'a2afa0f6899ee3c90e'\");\n\n        bytes memory expected939 = hex\"9acfce97d6b3b6f2ad01\";\n        uint64 value939 = 12530379333244790682;\n\n        Buffer.buffer memory result939 = Leb128.encodeUnsignedLeb128FromUInt64(value939);\n\n        require(keccak256(result939.buf) == keccak256(expected939), \"'12530379333244790682' is not returning '9acfce97d6b3b6f2ad01'\");\n\n        bytes memory expected940 = hex\"eda0ca89cabcc9e813\";\n        uint64 value940 = 1427964220740374637;\n\n        Buffer.buffer memory result940 = Leb128.encodeUnsignedLeb128FromUInt64(value940);\n\n        require(keccak256(result940.buf) == keccak256(expected940), \"'1427964220740374637' is not returning 'eda0ca89cabcc9e813'\");\n\n        bytes memory expected941 = hex\"82b1c7b6d1ebefb454\";\n        uint64 value941 = 6082603178276280450;\n\n        Buffer.buffer memory result941 = Leb128.encodeUnsignedLeb128FromUInt64(value941);\n\n        require(keccak256(result941.buf) == keccak256(expected941), \"'6082603178276280450' is not returning '82b1c7b6d1ebefb454'\");\n\n        bytes memory expected942 = hex\"85ebdf98f1bdff9e48\";\n        uint64 value942 = 5205595947569509765;\n\n        Buffer.buffer memory result942 = Leb128.encodeUnsignedLeb128FromUInt64(value942);\n\n        require(keccak256(result942.buf) == keccak256(expected942), \"'5205595947569509765' is not returning '85ebdf98f1bdff9e48'\");\n\n        bytes memory expected943 = hex\"90ebddf3dcf0cc9679\";\n        uint64 value943 = 8731691902328862096;\n\n        Buffer.buffer memory result943 = Leb128.encodeUnsignedLeb128FromUInt64(value943);\n\n        require(keccak256(result943.buf) == keccak256(expected943), \"'8731691902328862096' is not returning '90ebddf3dcf0cc9679'\");\n\n        bytes memory expected944 = hex\"8de58cfb85fc9a8834\";\n        uint64 value944 = 3751617101016806029;\n\n        Buffer.buffer memory result944 = Leb128.encodeUnsignedLeb128FromUInt64(value944);\n\n        require(keccak256(result944.buf) == keccak256(expected944), \"'3751617101016806029' is not returning '8de58cfb85fc9a8834'\");\n\n        bytes memory expected945 = hex\"b0e6c8dfc989c6b8c601\";\n        uint64 value945 = 14299237009190957872;\n\n        Buffer.buffer memory result945 = Leb128.encodeUnsignedLeb128FromUInt64(value945);\n\n        require(keccak256(result945.buf) == keccak256(expected945), \"'14299237009190957872' is not returning 'b0e6c8dfc989c6b8c601'\");\n\n        bytes memory expected946 = hex\"b589c9e8d598c2b9c001\";\n        uint64 value946 = 13867437321366946997;\n\n        Buffer.buffer memory result946 = Leb128.encodeUnsignedLeb128FromUInt64(value946);\n\n        require(keccak256(result946.buf) == keccak256(expected946), \"'13867437321366946997' is not returning 'b589c9e8d598c2b9c001'\");\n\n        bytes memory expected947 = hex\"8dd9de9cf7fcc2cea001\";\n        uint64 value947 = 11573419706116713613;\n\n        Buffer.buffer memory result947 = Leb128.encodeUnsignedLeb128FromUInt64(value947);\n\n        require(keccak256(result947.buf) == keccak256(expected947), \"'11573419706116713613' is not returning '8dd9de9cf7fcc2cea001'\");\n\n        bytes memory expected948 = hex\"9acbaed4d3e781b41e\";\n        uint64 value948 = 2191009178272376218;\n\n        Buffer.buffer memory result948 = Leb128.encodeUnsignedLeb128FromUInt64(value948);\n\n        require(keccak256(result948.buf) == keccak256(expected948), \"'2191009178272376218' is not returning '9acbaed4d3e781b41e'\");\n\n        bytes memory expected949 = hex\"ca94c7d6ff9c86db9401\";\n        uint64 value949 = 10715779747999238730;\n\n        Buffer.buffer memory result949 = Leb128.encodeUnsignedLeb128FromUInt64(value949);\n\n        require(keccak256(result949.buf) == keccak256(expected949), \"'10715779747999238730' is not returning 'ca94c7d6ff9c86db9401'\");\n\n        bytes memory expected950 = hex\"a193f2bfc3b5a2a69101\";\n        uint64 value950 = 10469894606496237985;\n\n        Buffer.buffer memory result950 = Leb128.encodeUnsignedLeb128FromUInt64(value950);\n\n        require(keccak256(result950.buf) == keccak256(expected950), \"'10469894606496237985' is not returning 'a193f2bfc3b5a2a69101'\");\n\n        bytes memory expected951 = hex\"ccdfeeaeaaa196c1c401\";\n        uint64 value951 = 14159978080673443788;\n\n        Buffer.buffer memory result951 = Leb128.encodeUnsignedLeb128FromUInt64(value951);\n\n        require(keccak256(result951.buf) == keccak256(expected951), \"'14159978080673443788' is not returning 'ccdfeeaeaaa196c1c401'\");\n\n        bytes memory expected952 = hex\"de89b8deca9dd4c8bc01\";\n        uint64 value952 = 13587730528178406622;\n\n        Buffer.buffer memory result952 = Leb128.encodeUnsignedLeb128FromUInt64(value952);\n\n        require(keccak256(result952.buf) == keccak256(expected952), \"'13587730528178406622' is not returning 'de89b8deca9dd4c8bc01'\");\n\n        bytes memory expected953 = hex\"dcb3d98298efe49c9c01\";\n        uint64 value953 = 11257190893642734044;\n\n        Buffer.buffer memory result953 = Leb128.encodeUnsignedLeb128FromUInt64(value953);\n\n        require(keccak256(result953.buf) == keccak256(expected953), \"'11257190893642734044' is not returning 'dcb3d98298efe49c9c01'\");\n\n        bytes memory expected954 = hex\"9df9d3be828df5d228\";\n        uint64 value954 = 2928980676484332701;\n\n        Buffer.buffer memory result954 = Leb128.encodeUnsignedLeb128FromUInt64(value954);\n\n        require(keccak256(result954.buf) == keccak256(expected954), \"'2928980676484332701' is not returning '9df9d3be828df5d228'\");\n\n        bytes memory expected955 = hex\"9b8a87df86daf5e8e401\";\n        uint64 value955 = 16488195901431596315;\n\n        Buffer.buffer memory result955 = Leb128.encodeUnsignedLeb128FromUInt64(value955);\n\n        require(keccak256(result955.buf) == keccak256(expected955), \"'16488195901431596315' is not returning '9b8a87df86daf5e8e401'\");\n\n        bytes memory expected956 = hex\"d2eeedb795d5d1af3b\";\n        uint64 value956 = 4278215864147998546;\n\n        Buffer.buffer memory result956 = Leb128.encodeUnsignedLeb128FromUInt64(value956);\n\n        require(keccak256(result956.buf) == keccak256(expected956), \"'4278215864147998546' is not returning 'd2eeedb795d5d1af3b'\");\n\n        bytes memory expected957 = hex\"ecf6df81c0b3c0ff3b\";\n        uint64 value957 = 4323175936829160300;\n\n        Buffer.buffer memory result957 = Leb128.encodeUnsignedLeb128FromUInt64(value957);\n\n        require(keccak256(result957.buf) == keccak256(expected957), \"'4323175936829160300' is not returning 'ecf6df81c0b3c0ff3b'\");\n\n        bytes memory expected958 = hex\"87f1f2af8cd7f9bbb501\";\n        uint64 value958 = 13076173724363569287;\n\n        Buffer.buffer memory result958 = Leb128.encodeUnsignedLeb128FromUInt64(value958);\n\n        require(keccak256(result958.buf) == keccak256(expected958), \"'13076173724363569287' is not returning '87f1f2af8cd7f9bbb501'\");\n\n        bytes memory expected959 = hex\"fedf8ab0c5d9cefc78\";\n        uint64 value959 = 8717063203043061758;\n\n        Buffer.buffer memory result959 = Leb128.encodeUnsignedLeb128FromUInt64(value959);\n\n        require(keccak256(result959.buf) == keccak256(expected959), \"'8717063203043061758' is not returning 'fedf8ab0c5d9cefc78'\");\n\n        bytes memory expected960 = hex\"db84cdb88a9891a847\";\n        uint64 value960 = 5138682769057202779;\n\n        Buffer.buffer memory result960 = Leb128.encodeUnsignedLeb128FromUInt64(value960);\n\n        require(keccak256(result960.buf) == keccak256(expected960), \"'5138682769057202779' is not returning 'db84cdb88a9891a847'\");\n\n        bytes memory expected961 = hex\"fc84a0b391d0b898b901\";\n        uint64 value961 = 13344414739953353340;\n\n        Buffer.buffer memory result961 = Leb128.encodeUnsignedLeb128FromUInt64(value961);\n\n        require(keccak256(result961.buf) == keccak256(expected961), \"'13344414739953353340' is not returning 'fc84a0b391d0b898b901'\");\n\n        bytes memory expected962 = hex\"bcfea2aec2d18bdc9901\";\n        uint64 value962 = 11076654462981947196;\n\n        Buffer.buffer memory result962 = Leb128.encodeUnsignedLeb128FromUInt64(value962);\n\n        require(keccak256(result962.buf) == keccak256(expected962), \"'11076654462981947196' is not returning 'bcfea2aec2d18bdc9901'\");\n\n        bytes memory expected963 = hex\"dfa4e98cfdcb8fb475\";\n        uint64 value963 = 8460080481274843743;\n\n        Buffer.buffer memory result963 = Leb128.encodeUnsignedLeb128FromUInt64(value963);\n\n        require(keccak256(result963.buf) == keccak256(expected963), \"'8460080481274843743' is not returning 'dfa4e98cfdcb8fb475'\");\n\n        bytes memory expected964 = hex\"b7bbf7e49abbc5f6bd01\";\n        uint64 value964 = 13685618867296918967;\n\n        Buffer.buffer memory result964 = Leb128.encodeUnsignedLeb128FromUInt64(value964);\n\n        require(keccak256(result964.buf) == keccak256(expected964), \"'13685618867296918967' is not returning 'b7bbf7e49abbc5f6bd01'\");\n\n        bytes memory expected965 = hex\"d3bc9da8cce696e16f\";\n        uint64 value965 = 8053099365893889619;\n\n        Buffer.buffer memory result965 = Leb128.encodeUnsignedLeb128FromUInt64(value965);\n\n        require(keccak256(result965.buf) == keccak256(expected965), \"'8053099365893889619' is not returning 'd3bc9da8cce696e16f'\");\n\n        bytes memory expected966 = hex\"c7f990daf8c5db959201\";\n        uint64 value966 = 10532633304015060167;\n\n        Buffer.buffer memory result966 = Leb128.encodeUnsignedLeb128FromUInt64(value966);\n\n        require(keccak256(result966.buf) == keccak256(expected966), \"'10532633304015060167' is not returning 'c7f990daf8c5db959201'\");\n\n        bytes memory expected967 = hex\"c4a0afb4b887f79a9a01\";\n        uint64 value967 = 11112029803825057860;\n\n        Buffer.buffer memory result967 = Leb128.encodeUnsignedLeb128FromUInt64(value967);\n\n        require(keccak256(result967.buf) == keccak256(expected967), \"'11112029803825057860' is not returning 'c4a0afb4b887f79a9a01'\");\n\n        bytes memory expected968 = hex\"faa6f4bccdc7dffd6f\";\n        uint64 value968 = 8069181957144908666;\n\n        Buffer.buffer memory result968 = Leb128.encodeUnsignedLeb128FromUInt64(value968);\n\n        require(keccak256(result968.buf) == keccak256(expected968), \"'8069181957144908666' is not returning 'faa6f4bccdc7dffd6f'\");\n\n        bytes memory expected969 = hex\"f193a2b9da9defee71\";\n        uint64 value969 = 8204921825036634609;\n\n        Buffer.buffer memory result969 = Leb128.encodeUnsignedLeb128FromUInt64(value969);\n\n        require(keccak256(result969.buf) == keccak256(expected969), \"'8204921825036634609' is not returning 'f193a2b9da9defee71'\");\n\n        bytes memory expected970 = hex\"d4f9f1aef9a4c8ad33\";\n        uint64 value970 = 3700587972716690644;\n\n        Buffer.buffer memory result970 = Leb128.encodeUnsignedLeb128FromUInt64(value970);\n\n        require(keccak256(result970.buf) == keccak256(expected970), \"'3700587972716690644' is not returning 'd4f9f1aef9a4c8ad33'\");\n\n        bytes memory expected971 = hex\"f3bd85f5bf81e4d68301\";\n        uint64 value971 = 9488398371130531571;\n\n        Buffer.buffer memory result971 = Leb128.encodeUnsignedLeb128FromUInt64(value971);\n\n        require(keccak256(result971.buf) == keccak256(expected971), \"'9488398371130531571' is not returning 'f3bd85f5bf81e4d68301'\");\n\n        bytes memory expected972 = hex\"beb5adbdf2ebf2c113\";\n        uint64 value972 = 1406191118217599678;\n\n        Buffer.buffer memory result972 = Leb128.encodeUnsignedLeb128FromUInt64(value972);\n\n        require(keccak256(result972.buf) == keccak256(expected972), \"'1406191118217599678' is not returning 'beb5adbdf2ebf2c113'\");\n\n        bytes memory expected973 = hex\"84e9f8bfe688e994c901\";\n        uint64 value973 = 14495297497968030852;\n\n        Buffer.buffer memory result973 = Leb128.encodeUnsignedLeb128FromUInt64(value973);\n\n        require(keccak256(result973.buf) == keccak256(expected973), \"'14495297497968030852' is not returning '84e9f8bfe688e994c901'\");\n\n        bytes memory expected974 = hex\"adf191ee948e84b069\";\n        uint64 value974 = 7593087050568726701;\n\n        Buffer.buffer memory result974 = Leb128.encodeUnsignedLeb128FromUInt64(value974);\n\n        require(keccak256(result974.buf) == keccak256(expected974), \"'7593087050568726701' is not returning 'adf191ee948e84b069'\");\n\n        bytes memory expected975 = hex\"a396c28dcebc8fecbd01\";\n        uint64 value975 = 13679751921386162979;\n\n        Buffer.buffer memory result975 = Leb128.encodeUnsignedLeb128FromUInt64(value975);\n\n        require(keccak256(result975.buf) == keccak256(expected975), \"'13679751921386162979' is not returning 'a396c28dcebc8fecbd01'\");\n\n        bytes memory expected976 = hex\"bbf3edaca2edcab572\";\n        uint64 value976 = 8244731277729298875;\n\n        Buffer.buffer memory result976 = Leb128.encodeUnsignedLeb128FromUInt64(value976);\n\n        require(keccak256(result976.buf) == keccak256(expected976), \"'8244731277729298875' is not returning 'bbf3edaca2edcab572'\");\n\n        bytes memory expected977 = hex\"d4eafca3d998ead63d\";\n        uint64 value977 = 4444393973837935956;\n\n        Buffer.buffer memory result977 = Leb128.encodeUnsignedLeb128FromUInt64(value977);\n\n        require(keccak256(result977.buf) == keccak256(expected977), \"'4444393973837935956' is not returning 'd4eafca3d998ead63d'\");\n\n        bytes memory expected978 = hex\"c887bfdab59be38e38\";\n        uint64 value978 = 4043542914206254024;\n\n        Buffer.buffer memory result978 = Leb128.encodeUnsignedLeb128FromUInt64(value978);\n\n        require(keccak256(result978.buf) == keccak256(expected978), \"'4043542914206254024' is not returning 'c887bfdab59be38e38'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated2.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated2Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected70 = hex\"64\";\n        uint64 value70 = 100;\n\n        Buffer.buffer memory result70 = Leb128.encodeUnsignedLeb128FromUInt64(value70);\n\n        require(keccak256(result70.buf) == keccak256(expected70), \"'100' is not returning '64'\");\n\n        bytes memory expected71 = hex\"8401\";\n        uint64 value71 = 132;\n\n        Buffer.buffer memory result71 = Leb128.encodeUnsignedLeb128FromUInt64(value71);\n\n        require(keccak256(result71.buf) == keccak256(expected71), \"'132' is not returning '8401'\");\n\n        bytes memory expected72 = hex\"76\";\n        uint64 value72 = 118;\n\n        Buffer.buffer memory result72 = Leb128.encodeUnsignedLeb128FromUInt64(value72);\n\n        require(keccak256(result72.buf) == keccak256(expected72), \"'118' is not returning '76'\");\n\n        bytes memory expected73 = hex\"cd01\";\n        uint64 value73 = 205;\n\n        Buffer.buffer memory result73 = Leb128.encodeUnsignedLeb128FromUInt64(value73);\n\n        require(keccak256(result73.buf) == keccak256(expected73), \"'205' is not returning 'cd01'\");\n\n        bytes memory expected74 = hex\"fb01\";\n        uint64 value74 = 251;\n\n        Buffer.buffer memory result74 = Leb128.encodeUnsignedLeb128FromUInt64(value74);\n\n        require(keccak256(result74.buf) == keccak256(expected74), \"'251' is not returning 'fb01'\");\n\n        bytes memory expected75 = hex\"1a\";\n        uint64 value75 = 26;\n\n        Buffer.buffer memory result75 = Leb128.encodeUnsignedLeb128FromUInt64(value75);\n\n        require(keccak256(result75.buf) == keccak256(expected75), \"'26' is not returning '1a'\");\n\n        bytes memory expected76 = hex\"cb01\";\n        uint64 value76 = 203;\n\n        Buffer.buffer memory result76 = Leb128.encodeUnsignedLeb128FromUInt64(value76);\n\n        require(keccak256(result76.buf) == keccak256(expected76), \"'203' is not returning 'cb01'\");\n\n        bytes memory expected77 = hex\"fc01\";\n        uint64 value77 = 252;\n\n        Buffer.buffer memory result77 = Leb128.encodeUnsignedLeb128FromUInt64(value77);\n\n        require(keccak256(result77.buf) == keccak256(expected77), \"'252' is not returning 'fc01'\");\n\n        bytes memory expected78 = hex\"1d\";\n        uint64 value78 = 29;\n\n        Buffer.buffer memory result78 = Leb128.encodeUnsignedLeb128FromUInt64(value78);\n\n        require(keccak256(result78.buf) == keccak256(expected78), \"'29' is not returning '1d'\");\n\n        bytes memory expected79 = hex\"b601\";\n        uint64 value79 = 182;\n\n        Buffer.buffer memory result79 = Leb128.encodeUnsignedLeb128FromUInt64(value79);\n\n        require(keccak256(result79.buf) == keccak256(expected79), \"'182' is not returning 'b601'\");\n\n        bytes memory expected80 = hex\"dd01\";\n        uint64 value80 = 221;\n\n        Buffer.buffer memory result80 = Leb128.encodeUnsignedLeb128FromUInt64(value80);\n\n        require(keccak256(result80.buf) == keccak256(expected80), \"'221' is not returning 'dd01'\");\n\n        bytes memory expected81 = hex\"b501\";\n        uint64 value81 = 181;\n\n        Buffer.buffer memory result81 = Leb128.encodeUnsignedLeb128FromUInt64(value81);\n\n        require(keccak256(result81.buf) == keccak256(expected81), \"'181' is not returning 'b501'\");\n\n        bytes memory expected82 = hex\"e301\";\n        uint64 value82 = 227;\n\n        Buffer.buffer memory result82 = Leb128.encodeUnsignedLeb128FromUInt64(value82);\n\n        require(keccak256(result82.buf) == keccak256(expected82), \"'227' is not returning 'e301'\");\n\n        bytes memory expected83 = hex\"2b\";\n        uint64 value83 = 43;\n\n        Buffer.buffer memory result83 = Leb128.encodeUnsignedLeb128FromUInt64(value83);\n\n        require(keccak256(result83.buf) == keccak256(expected83), \"'43' is not returning '2b'\");\n\n        bytes memory expected84 = hex\"44\";\n        uint64 value84 = 68;\n\n        Buffer.buffer memory result84 = Leb128.encodeUnsignedLeb128FromUInt64(value84);\n\n        require(keccak256(result84.buf) == keccak256(expected84), \"'68' is not returning '44'\");\n\n        bytes memory expected85 = hex\"44\";\n        uint64 value85 = 68;\n\n        Buffer.buffer memory result85 = Leb128.encodeUnsignedLeb128FromUInt64(value85);\n\n        require(keccak256(result85.buf) == keccak256(expected85), \"'68' is not returning '44'\");\n\n        bytes memory expected86 = hex\"9301\";\n        uint64 value86 = 147;\n\n        Buffer.buffer memory result86 = Leb128.encodeUnsignedLeb128FromUInt64(value86);\n\n        require(keccak256(result86.buf) == keccak256(expected86), \"'147' is not returning '9301'\");\n\n        bytes memory expected87 = hex\"d101\";\n        uint64 value87 = 209;\n\n        Buffer.buffer memory result87 = Leb128.encodeUnsignedLeb128FromUInt64(value87);\n\n        require(keccak256(result87.buf) == keccak256(expected87), \"'209' is not returning 'd101'\");\n\n        bytes memory expected88 = hex\"25\";\n        uint64 value88 = 37;\n\n        Buffer.buffer memory result88 = Leb128.encodeUnsignedLeb128FromUInt64(value88);\n\n        require(keccak256(result88.buf) == keccak256(expected88), \"'37' is not returning '25'\");\n\n        bytes memory expected89 = hex\"7d\";\n        uint64 value89 = 125;\n\n        Buffer.buffer memory result89 = Leb128.encodeUnsignedLeb128FromUInt64(value89);\n\n        require(keccak256(result89.buf) == keccak256(expected89), \"'125' is not returning '7d'\");\n\n        bytes memory expected90 = hex\"b701\";\n        uint64 value90 = 183;\n\n        Buffer.buffer memory result90 = Leb128.encodeUnsignedLeb128FromUInt64(value90);\n\n        require(keccak256(result90.buf) == keccak256(expected90), \"'183' is not returning 'b701'\");\n\n        bytes memory expected91 = hex\"d701\";\n        uint64 value91 = 215;\n\n        Buffer.buffer memory result91 = Leb128.encodeUnsignedLeb128FromUInt64(value91);\n\n        require(keccak256(result91.buf) == keccak256(expected91), \"'215' is not returning 'd701'\");\n\n        bytes memory expected92 = hex\"52\";\n        uint64 value92 = 82;\n\n        Buffer.buffer memory result92 = Leb128.encodeUnsignedLeb128FromUInt64(value92);\n\n        require(keccak256(result92.buf) == keccak256(expected92), \"'82' is not returning '52'\");\n\n        bytes memory expected93 = hex\"c501\";\n        uint64 value93 = 197;\n\n        Buffer.buffer memory result93 = Leb128.encodeUnsignedLeb128FromUInt64(value93);\n\n        require(keccak256(result93.buf) == keccak256(expected93), \"'197' is not returning 'c501'\");\n\n        bytes memory expected94 = hex\"ee01\";\n        uint64 value94 = 238;\n\n        Buffer.buffer memory result94 = Leb128.encodeUnsignedLeb128FromUInt64(value94);\n\n        require(keccak256(result94.buf) == keccak256(expected94), \"'238' is not returning 'ee01'\");\n\n        bytes memory expected95 = hex\"53\";\n        uint64 value95 = 83;\n\n        Buffer.buffer memory result95 = Leb128.encodeUnsignedLeb128FromUInt64(value95);\n\n        require(keccak256(result95.buf) == keccak256(expected95), \"'83' is not returning '53'\");\n\n        bytes memory expected96 = hex\"1b\";\n        uint64 value96 = 27;\n\n        Buffer.buffer memory result96 = Leb128.encodeUnsignedLeb128FromUInt64(value96);\n\n        require(keccak256(result96.buf) == keccak256(expected96), \"'27' is not returning '1b'\");\n\n        bytes memory expected97 = hex\"bf01\";\n        uint64 value97 = 191;\n\n        Buffer.buffer memory result97 = Leb128.encodeUnsignedLeb128FromUInt64(value97);\n\n        require(keccak256(result97.buf) == keccak256(expected97), \"'191' is not returning 'bf01'\");\n\n        bytes memory expected98 = hex\"7d\";\n        uint64 value98 = 125;\n\n        Buffer.buffer memory result98 = Leb128.encodeUnsignedLeb128FromUInt64(value98);\n\n        require(keccak256(result98.buf) == keccak256(expected98), \"'125' is not returning '7d'\");\n\n        bytes memory expected99 = hex\"1a\";\n        uint64 value99 = 26;\n\n        Buffer.buffer memory result99 = Leb128.encodeUnsignedLeb128FromUInt64(value99);\n\n        require(keccak256(result99.buf) == keccak256(expected99), \"'26' is not returning '1a'\");\n\n        bytes memory expected100 = hex\"8401\";\n        uint64 value100 = 132;\n\n        Buffer.buffer memory result100 = Leb128.encodeUnsignedLeb128FromUInt64(value100);\n\n        require(keccak256(result100.buf) == keccak256(expected100), \"'132' is not returning '8401'\");\n\n        bytes memory expected101 = hex\"8a01\";\n        uint64 value101 = 138;\n\n        Buffer.buffer memory result101 = Leb128.encodeUnsignedLeb128FromUInt64(value101);\n\n        require(keccak256(result101.buf) == keccak256(expected101), \"'138' is not returning '8a01'\");\n\n        bytes memory expected102 = hex\"09\";\n        uint64 value102 = 9;\n\n        Buffer.buffer memory result102 = Leb128.encodeUnsignedLeb128FromUInt64(value102);\n\n        require(keccak256(result102.buf) == keccak256(expected102), \"'9' is not returning '09'\");\n\n        bytes memory expected103 = hex\"20\";\n        uint64 value103 = 32;\n\n        Buffer.buffer memory result103 = Leb128.encodeUnsignedLeb128FromUInt64(value103);\n\n        require(keccak256(result103.buf) == keccak256(expected103), \"'32' is not returning '20'\");\n\n        bytes memory expected104 = hex\"74\";\n        uint64 value104 = 116;\n\n        Buffer.buffer memory result104 = Leb128.encodeUnsignedLeb128FromUInt64(value104);\n\n        require(keccak256(result104.buf) == keccak256(expected104), \"'116' is not returning '74'\");\n\n        bytes memory expected105 = hex\"00\";\n        uint64 value105 = 0;\n\n        Buffer.buffer memory result105 = Leb128.encodeUnsignedLeb128FromUInt64(value105);\n\n        require(keccak256(result105.buf) == keccak256(expected105), \"'0' is not returning '00'\");\n\n        bytes memory expected106 = hex\"13\";\n        uint64 value106 = 19;\n\n        Buffer.buffer memory result106 = Leb128.encodeUnsignedLeb128FromUInt64(value106);\n\n        require(keccak256(result106.buf) == keccak256(expected106), \"'19' is not returning '13'\");\n\n        bytes memory expected107 = hex\"b301\";\n        uint64 value107 = 179;\n\n        Buffer.buffer memory result107 = Leb128.encodeUnsignedLeb128FromUInt64(value107);\n\n        require(keccak256(result107.buf) == keccak256(expected107), \"'179' is not returning 'b301'\");\n\n        bytes memory expected108 = hex\"78\";\n        uint64 value108 = 120;\n\n        Buffer.buffer memory result108 = Leb128.encodeUnsignedLeb128FromUInt64(value108);\n\n        require(keccak256(result108.buf) == keccak256(expected108), \"'120' is not returning '78'\");\n\n        bytes memory expected109 = hex\"09\";\n        uint64 value109 = 9;\n\n        Buffer.buffer memory result109 = Leb128.encodeUnsignedLeb128FromUInt64(value109);\n\n        require(keccak256(result109.buf) == keccak256(expected109), \"'9' is not returning '09'\");\n\n        bytes memory expected110 = hex\"15\";\n        uint64 value110 = 21;\n\n        Buffer.buffer memory result110 = Leb128.encodeUnsignedLeb128FromUInt64(value110);\n\n        require(keccak256(result110.buf) == keccak256(expected110), \"'21' is not returning '15'\");\n\n        bytes memory expected111 = hex\"df01\";\n        uint64 value111 = 223;\n\n        Buffer.buffer memory result111 = Leb128.encodeUnsignedLeb128FromUInt64(value111);\n\n        require(keccak256(result111.buf) == keccak256(expected111), \"'223' is not returning 'df01'\");\n\n        bytes memory expected112 = hex\"53\";\n        uint64 value112 = 83;\n\n        Buffer.buffer memory result112 = Leb128.encodeUnsignedLeb128FromUInt64(value112);\n\n        require(keccak256(result112.buf) == keccak256(expected112), \"'83' is not returning '53'\");\n\n        bytes memory expected113 = hex\"da01\";\n        uint64 value113 = 218;\n\n        Buffer.buffer memory result113 = Leb128.encodeUnsignedLeb128FromUInt64(value113);\n\n        require(keccak256(result113.buf) == keccak256(expected113), \"'218' is not returning 'da01'\");\n\n        bytes memory expected114 = hex\"af01\";\n        uint64 value114 = 175;\n\n        Buffer.buffer memory result114 = Leb128.encodeUnsignedLeb128FromUInt64(value114);\n\n        require(keccak256(result114.buf) == keccak256(expected114), \"'175' is not returning 'af01'\");\n\n        bytes memory expected115 = hex\"8301\";\n        uint64 value115 = 131;\n\n        Buffer.buffer memory result115 = Leb128.encodeUnsignedLeb128FromUInt64(value115);\n\n        require(keccak256(result115.buf) == keccak256(expected115), \"'131' is not returning '8301'\");\n\n        bytes memory expected116 = hex\"a201\";\n        uint64 value116 = 162;\n\n        Buffer.buffer memory result116 = Leb128.encodeUnsignedLeb128FromUInt64(value116);\n\n        require(keccak256(result116.buf) == keccak256(expected116), \"'162' is not returning 'a201'\");\n\n        bytes memory expected117 = hex\"8a01\";\n        uint64 value117 = 138;\n\n        Buffer.buffer memory result117 = Leb128.encodeUnsignedLeb128FromUInt64(value117);\n\n        require(keccak256(result117.buf) == keccak256(expected117), \"'138' is not returning '8a01'\");\n\n        bytes memory expected118 = hex\"c401\";\n        uint64 value118 = 196;\n\n        Buffer.buffer memory result118 = Leb128.encodeUnsignedLeb128FromUInt64(value118);\n\n        require(keccak256(result118.buf) == keccak256(expected118), \"'196' is not returning 'c401'\");\n\n        bytes memory expected119 = hex\"6c\";\n        uint64 value119 = 108;\n\n        Buffer.buffer memory result119 = Leb128.encodeUnsignedLeb128FromUInt64(value119);\n\n        require(keccak256(result119.buf) == keccak256(expected119), \"'108' is not returning '6c'\");\n\n        bytes memory expected120 = hex\"29\";\n        uint64 value120 = 41;\n\n        Buffer.buffer memory result120 = Leb128.encodeUnsignedLeb128FromUInt64(value120);\n\n        require(keccak256(result120.buf) == keccak256(expected120), \"'41' is not returning '29'\");\n\n        bytes memory expected121 = hex\"06\";\n        uint64 value121 = 6;\n\n        Buffer.buffer memory result121 = Leb128.encodeUnsignedLeb128FromUInt64(value121);\n\n        require(keccak256(result121.buf) == keccak256(expected121), \"'6' is not returning '06'\");\n\n        bytes memory expected122 = hex\"61\";\n        uint64 value122 = 97;\n\n        Buffer.buffer memory result122 = Leb128.encodeUnsignedLeb128FromUInt64(value122);\n\n        require(keccak256(result122.buf) == keccak256(expected122), \"'97' is not returning '61'\");\n\n        bytes memory expected123 = hex\"ab01\";\n        uint64 value123 = 171;\n\n        Buffer.buffer memory result123 = Leb128.encodeUnsignedLeb128FromUInt64(value123);\n\n        require(keccak256(result123.buf) == keccak256(expected123), \"'171' is not returning 'ab01'\");\n\n        bytes memory expected124 = hex\"2a\";\n        uint64 value124 = 42;\n\n        Buffer.buffer memory result124 = Leb128.encodeUnsignedLeb128FromUInt64(value124);\n\n        require(keccak256(result124.buf) == keccak256(expected124), \"'42' is not returning '2a'\");\n\n        bytes memory expected125 = hex\"63\";\n        uint64 value125 = 99;\n\n        Buffer.buffer memory result125 = Leb128.encodeUnsignedLeb128FromUInt64(value125);\n\n        require(keccak256(result125.buf) == keccak256(expected125), \"'99' is not returning '63'\");\n\n        bytes memory expected126 = hex\"8d01\";\n        uint64 value126 = 141;\n\n        Buffer.buffer memory result126 = Leb128.encodeUnsignedLeb128FromUInt64(value126);\n\n        require(keccak256(result126.buf) == keccak256(expected126), \"'141' is not returning '8d01'\");\n\n        bytes memory expected127 = hex\"fd01\";\n        uint64 value127 = 253;\n\n        Buffer.buffer memory result127 = Leb128.encodeUnsignedLeb128FromUInt64(value127);\n\n        require(keccak256(result127.buf) == keccak256(expected127), \"'253' is not returning 'fd01'\");\n\n        bytes memory expected128 = hex\"7a\";\n        uint64 value128 = 122;\n\n        Buffer.buffer memory result128 = Leb128.encodeUnsignedLeb128FromUInt64(value128);\n\n        require(keccak256(result128.buf) == keccak256(expected128), \"'122' is not returning '7a'\");\n\n        bytes memory expected129 = hex\"8b01\";\n        uint64 value129 = 139;\n\n        Buffer.buffer memory result129 = Leb128.encodeUnsignedLeb128FromUInt64(value129);\n\n        require(keccak256(result129.buf) == keccak256(expected129), \"'139' is not returning '8b01'\");\n\n        bytes memory expected130 = hex\"8f01\";\n        uint64 value130 = 143;\n\n        Buffer.buffer memory result130 = Leb128.encodeUnsignedLeb128FromUInt64(value130);\n\n        require(keccak256(result130.buf) == keccak256(expected130), \"'143' is not returning '8f01'\");\n\n        bytes memory expected131 = hex\"0c\";\n        uint64 value131 = 12;\n\n        Buffer.buffer memory result131 = Leb128.encodeUnsignedLeb128FromUInt64(value131);\n\n        require(keccak256(result131.buf) == keccak256(expected131), \"'12' is not returning '0c'\");\n\n        bytes memory expected132 = hex\"9601\";\n        uint64 value132 = 150;\n\n        Buffer.buffer memory result132 = Leb128.encodeUnsignedLeb128FromUInt64(value132);\n\n        require(keccak256(result132.buf) == keccak256(expected132), \"'150' is not returning '9601'\");\n\n        bytes memory expected133 = hex\"a301\";\n        uint64 value133 = 163;\n\n        Buffer.buffer memory result133 = Leb128.encodeUnsignedLeb128FromUInt64(value133);\n\n        require(keccak256(result133.buf) == keccak256(expected133), \"'163' is not returning 'a301'\");\n\n        bytes memory expected134 = hex\"c301\";\n        uint64 value134 = 195;\n\n        Buffer.buffer memory result134 = Leb128.encodeUnsignedLeb128FromUInt64(value134);\n\n        require(keccak256(result134.buf) == keccak256(expected134), \"'195' is not returning 'c301'\");\n\n        bytes memory expected135 = hex\"8401\";\n        uint64 value135 = 132;\n\n        Buffer.buffer memory result135 = Leb128.encodeUnsignedLeb128FromUInt64(value135);\n\n        require(keccak256(result135.buf) == keccak256(expected135), \"'132' is not returning '8401'\");\n\n        bytes memory expected136 = hex\"19\";\n        uint64 value136 = 25;\n\n        Buffer.buffer memory result136 = Leb128.encodeUnsignedLeb128FromUInt64(value136);\n\n        require(keccak256(result136.buf) == keccak256(expected136), \"'25' is not returning '19'\");\n\n        bytes memory expected137 = hex\"04\";\n        uint64 value137 = 4;\n\n        Buffer.buffer memory result137 = Leb128.encodeUnsignedLeb128FromUInt64(value137);\n\n        require(keccak256(result137.buf) == keccak256(expected137), \"'4' is not returning '04'\");\n\n        bytes memory expected138 = hex\"77\";\n        uint64 value138 = 119;\n\n        Buffer.buffer memory result138 = Leb128.encodeUnsignedLeb128FromUInt64(value138);\n\n        require(keccak256(result138.buf) == keccak256(expected138), \"'119' is not returning '77'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated3.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated3Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected140 = hex\"43\";\n        uint64 value140 = 67;\n\n        Buffer.buffer memory result140 = Leb128.encodeUnsignedLeb128FromUInt64(value140);\n\n        require(keccak256(result140.buf) == keccak256(expected140), \"'67' is not returning '43'\");\n\n        bytes memory expected141 = hex\"5b\";\n        uint64 value141 = 91;\n\n        Buffer.buffer memory result141 = Leb128.encodeUnsignedLeb128FromUInt64(value141);\n\n        require(keccak256(result141.buf) == keccak256(expected141), \"'91' is not returning '5b'\");\n\n        bytes memory expected142 = hex\"28\";\n        uint64 value142 = 40;\n\n        Buffer.buffer memory result142 = Leb128.encodeUnsignedLeb128FromUInt64(value142);\n\n        require(keccak256(result142.buf) == keccak256(expected142), \"'40' is not returning '28'\");\n\n        bytes memory expected143 = hex\"20\";\n        uint64 value143 = 32;\n\n        Buffer.buffer memory result143 = Leb128.encodeUnsignedLeb128FromUInt64(value143);\n\n        require(keccak256(result143.buf) == keccak256(expected143), \"'32' is not returning '20'\");\n\n        bytes memory expected144 = hex\"4d\";\n        uint64 value144 = 77;\n\n        Buffer.buffer memory result144 = Leb128.encodeUnsignedLeb128FromUInt64(value144);\n\n        require(keccak256(result144.buf) == keccak256(expected144), \"'77' is not returning '4d'\");\n\n        bytes memory expected145 = hex\"5a\";\n        uint64 value145 = 90;\n\n        Buffer.buffer memory result145 = Leb128.encodeUnsignedLeb128FromUInt64(value145);\n\n        require(keccak256(result145.buf) == keccak256(expected145), \"'90' is not returning '5a'\");\n\n        bytes memory expected146 = hex\"2d\";\n        uint64 value146 = 45;\n\n        Buffer.buffer memory result146 = Leb128.encodeUnsignedLeb128FromUInt64(value146);\n\n        require(keccak256(result146.buf) == keccak256(expected146), \"'45' is not returning '2d'\");\n\n        bytes memory expected147 = hex\"33\";\n        uint64 value147 = 51;\n\n        Buffer.buffer memory result147 = Leb128.encodeUnsignedLeb128FromUInt64(value147);\n\n        require(keccak256(result147.buf) == keccak256(expected147), \"'51' is not returning '33'\");\n\n        bytes memory expected148 = hex\"2e\";\n        uint64 value148 = 46;\n\n        Buffer.buffer memory result148 = Leb128.encodeUnsignedLeb128FromUInt64(value148);\n\n        require(keccak256(result148.buf) == keccak256(expected148), \"'46' is not returning '2e'\");\n\n        bytes memory expected149 = hex\"0a\";\n        uint64 value149 = 10;\n\n        Buffer.buffer memory result149 = Leb128.encodeUnsignedLeb128FromUInt64(value149);\n\n        require(keccak256(result149.buf) == keccak256(expected149), \"'10' is not returning '0a'\");\n\n        bytes memory expected150 = hex\"9901\";\n        uint64 value150 = 153;\n\n        Buffer.buffer memory result150 = Leb128.encodeUnsignedLeb128FromUInt64(value150);\n\n        require(keccak256(result150.buf) == keccak256(expected150), \"'153' is not returning '9901'\");\n\n        bytes memory expected151 = hex\"ea01\";\n        uint64 value151 = 234;\n\n        Buffer.buffer memory result151 = Leb128.encodeUnsignedLeb128FromUInt64(value151);\n\n        require(keccak256(result151.buf) == keccak256(expected151), \"'234' is not returning 'ea01'\");\n\n        bytes memory expected152 = hex\"47\";\n        uint64 value152 = 71;\n\n        Buffer.buffer memory result152 = Leb128.encodeUnsignedLeb128FromUInt64(value152);\n\n        require(keccak256(result152.buf) == keccak256(expected152), \"'71' is not returning '47'\");\n\n        bytes memory expected153 = hex\"aa01\";\n        uint64 value153 = 170;\n\n        Buffer.buffer memory result153 = Leb128.encodeUnsignedLeb128FromUInt64(value153);\n\n        require(keccak256(result153.buf) == keccak256(expected153), \"'170' is not returning 'aa01'\");\n\n        bytes memory expected154 = hex\"71\";\n        uint64 value154 = 113;\n\n        Buffer.buffer memory result154 = Leb128.encodeUnsignedLeb128FromUInt64(value154);\n\n        require(keccak256(result154.buf) == keccak256(expected154), \"'113' is not returning '71'\");\n\n        bytes memory expected155 = hex\"9801\";\n        uint64 value155 = 152;\n\n        Buffer.buffer memory result155 = Leb128.encodeUnsignedLeb128FromUInt64(value155);\n\n        require(keccak256(result155.buf) == keccak256(expected155), \"'152' is not returning '9801'\");\n\n        bytes memory expected156 = hex\"d101\";\n        uint64 value156 = 209;\n\n        Buffer.buffer memory result156 = Leb128.encodeUnsignedLeb128FromUInt64(value156);\n\n        require(keccak256(result156.buf) == keccak256(expected156), \"'209' is not returning 'd101'\");\n\n        bytes memory expected157 = hex\"8301\";\n        uint64 value157 = 131;\n\n        Buffer.buffer memory result157 = Leb128.encodeUnsignedLeb128FromUInt64(value157);\n\n        require(keccak256(result157.buf) == keccak256(expected157), \"'131' is not returning '8301'\");\n\n        bytes memory expected158 = hex\"1b\";\n        uint64 value158 = 27;\n\n        Buffer.buffer memory result158 = Leb128.encodeUnsignedLeb128FromUInt64(value158);\n\n        require(keccak256(result158.buf) == keccak256(expected158), \"'27' is not returning '1b'\");\n\n        bytes memory expected159 = hex\"75\";\n        uint64 value159 = 117;\n\n        Buffer.buffer memory result159 = Leb128.encodeUnsignedLeb128FromUInt64(value159);\n\n        require(keccak256(result159.buf) == keccak256(expected159), \"'117' is not returning '75'\");\n\n        bytes memory expected160 = hex\"9701\";\n        uint64 value160 = 151;\n\n        Buffer.buffer memory result160 = Leb128.encodeUnsignedLeb128FromUInt64(value160);\n\n        require(keccak256(result160.buf) == keccak256(expected160), \"'151' is not returning '9701'\");\n\n        bytes memory expected161 = hex\"f001\";\n        uint64 value161 = 240;\n\n        Buffer.buffer memory result161 = Leb128.encodeUnsignedLeb128FromUInt64(value161);\n\n        require(keccak256(result161.buf) == keccak256(expected161), \"'240' is not returning 'f001'\");\n\n        bytes memory expected162 = hex\"8e01\";\n        uint64 value162 = 142;\n\n        Buffer.buffer memory result162 = Leb128.encodeUnsignedLeb128FromUInt64(value162);\n\n        require(keccak256(result162.buf) == keccak256(expected162), \"'142' is not returning '8e01'\");\n\n        bytes memory expected163 = hex\"f801\";\n        uint64 value163 = 248;\n\n        Buffer.buffer memory result163 = Leb128.encodeUnsignedLeb128FromUInt64(value163);\n\n        require(keccak256(result163.buf) == keccak256(expected163), \"'248' is not returning 'f801'\");\n\n        bytes memory expected164 = hex\"d601\";\n        uint64 value164 = 214;\n\n        Buffer.buffer memory result164 = Leb128.encodeUnsignedLeb128FromUInt64(value164);\n\n        require(keccak256(result164.buf) == keccak256(expected164), \"'214' is not returning 'd601'\");\n\n        bytes memory expected165 = hex\"b101\";\n        uint64 value165 = 177;\n\n        Buffer.buffer memory result165 = Leb128.encodeUnsignedLeb128FromUInt64(value165);\n\n        require(keccak256(result165.buf) == keccak256(expected165), \"'177' is not returning 'b101'\");\n\n        bytes memory expected166 = hex\"bb01\";\n        uint64 value166 = 187;\n\n        Buffer.buffer memory result166 = Leb128.encodeUnsignedLeb128FromUInt64(value166);\n\n        require(keccak256(result166.buf) == keccak256(expected166), \"'187' is not returning 'bb01'\");\n\n        bytes memory expected167 = hex\"3b\";\n        uint64 value167 = 59;\n\n        Buffer.buffer memory result167 = Leb128.encodeUnsignedLeb128FromUInt64(value167);\n\n        require(keccak256(result167.buf) == keccak256(expected167), \"'59' is not returning '3b'\");\n\n        bytes memory expected168 = hex\"f901\";\n        uint64 value168 = 249;\n\n        Buffer.buffer memory result168 = Leb128.encodeUnsignedLeb128FromUInt64(value168);\n\n        require(keccak256(result168.buf) == keccak256(expected168), \"'249' is not returning 'f901'\");\n\n        bytes memory expected169 = hex\"f301\";\n        uint64 value169 = 243;\n\n        Buffer.buffer memory result169 = Leb128.encodeUnsignedLeb128FromUInt64(value169);\n\n        require(keccak256(result169.buf) == keccak256(expected169), \"'243' is not returning 'f301'\");\n\n        bytes memory expected170 = hex\"fa01\";\n        uint64 value170 = 250;\n\n        Buffer.buffer memory result170 = Leb128.encodeUnsignedLeb128FromUInt64(value170);\n\n        require(keccak256(result170.buf) == keccak256(expected170), \"'250' is not returning 'fa01'\");\n\n        bytes memory expected171 = hex\"00\";\n        uint64 value171 = 0;\n\n        Buffer.buffer memory result171 = Leb128.encodeUnsignedLeb128FromUInt64(value171);\n\n        require(keccak256(result171.buf) == keccak256(expected171), \"'0' is not returning '00'\");\n\n        bytes memory expected172 = hex\"b201\";\n        uint64 value172 = 178;\n\n        Buffer.buffer memory result172 = Leb128.encodeUnsignedLeb128FromUInt64(value172);\n\n        require(keccak256(result172.buf) == keccak256(expected172), \"'178' is not returning 'b201'\");\n\n        bytes memory expected173 = hex\"bd01\";\n        uint64 value173 = 189;\n\n        Buffer.buffer memory result173 = Leb128.encodeUnsignedLeb128FromUInt64(value173);\n\n        require(keccak256(result173.buf) == keccak256(expected173), \"'189' is not returning 'bd01'\");\n\n        bytes memory expected174 = hex\"af01\";\n        uint64 value174 = 175;\n\n        Buffer.buffer memory result174 = Leb128.encodeUnsignedLeb128FromUInt64(value174);\n\n        require(keccak256(result174.buf) == keccak256(expected174), \"'175' is not returning 'af01'\");\n\n        bytes memory expected175 = hex\"a101\";\n        uint64 value175 = 161;\n\n        Buffer.buffer memory result175 = Leb128.encodeUnsignedLeb128FromUInt64(value175);\n\n        require(keccak256(result175.buf) == keccak256(expected175), \"'161' is not returning 'a101'\");\n\n        bytes memory expected176 = hex\"ff01\";\n        uint64 value176 = 255;\n\n        Buffer.buffer memory result176 = Leb128.encodeUnsignedLeb128FromUInt64(value176);\n\n        require(keccak256(result176.buf) == keccak256(expected176), \"'255' is not returning 'ff01'\");\n\n        bytes memory expected177 = hex\"6d\";\n        uint64 value177 = 109;\n\n        Buffer.buffer memory result177 = Leb128.encodeUnsignedLeb128FromUInt64(value177);\n\n        require(keccak256(result177.buf) == keccak256(expected177), \"'109' is not returning '6d'\");\n\n        bytes memory expected178 = hex\"0a\";\n        uint64 value178 = 10;\n\n        Buffer.buffer memory result178 = Leb128.encodeUnsignedLeb128FromUInt64(value178);\n\n        require(keccak256(result178.buf) == keccak256(expected178), \"'10' is not returning '0a'\");\n\n        bytes memory expected179 = hex\"08\";\n        uint64 value179 = 8;\n\n        Buffer.buffer memory result179 = Leb128.encodeUnsignedLeb128FromUInt64(value179);\n\n        require(keccak256(result179.buf) == keccak256(expected179), \"'8' is not returning '08'\");\n\n        bytes memory expected180 = hex\"4a\";\n        uint64 value180 = 74;\n\n        Buffer.buffer memory result180 = Leb128.encodeUnsignedLeb128FromUInt64(value180);\n\n        require(keccak256(result180.buf) == keccak256(expected180), \"'74' is not returning '4a'\");\n\n        bytes memory expected181 = hex\"b701\";\n        uint64 value181 = 183;\n\n        Buffer.buffer memory result181 = Leb128.encodeUnsignedLeb128FromUInt64(value181);\n\n        require(keccak256(result181.buf) == keccak256(expected181), \"'183' is not returning 'b701'\");\n\n        bytes memory expected182 = hex\"e801\";\n        uint64 value182 = 232;\n\n        Buffer.buffer memory result182 = Leb128.encodeUnsignedLeb128FromUInt64(value182);\n\n        require(keccak256(result182.buf) == keccak256(expected182), \"'232' is not returning 'e801'\");\n\n        bytes memory expected183 = hex\"bd01\";\n        uint64 value183 = 189;\n\n        Buffer.buffer memory result183 = Leb128.encodeUnsignedLeb128FromUInt64(value183);\n\n        require(keccak256(result183.buf) == keccak256(expected183), \"'189' is not returning 'bd01'\");\n\n        bytes memory expected184 = hex\"c801\";\n        uint64 value184 = 200;\n\n        Buffer.buffer memory result184 = Leb128.encodeUnsignedLeb128FromUInt64(value184);\n\n        require(keccak256(result184.buf) == keccak256(expected184), \"'200' is not returning 'c801'\");\n\n        bytes memory expected185 = hex\"36\";\n        uint64 value185 = 54;\n\n        Buffer.buffer memory result185 = Leb128.encodeUnsignedLeb128FromUInt64(value185);\n\n        require(keccak256(result185.buf) == keccak256(expected185), \"'54' is not returning '36'\");\n\n        bytes memory expected186 = hex\"33\";\n        uint64 value186 = 51;\n\n        Buffer.buffer memory result186 = Leb128.encodeUnsignedLeb128FromUInt64(value186);\n\n        require(keccak256(result186.buf) == keccak256(expected186), \"'51' is not returning '33'\");\n\n        bytes memory expected187 = hex\"8801\";\n        uint64 value187 = 136;\n\n        Buffer.buffer memory result187 = Leb128.encodeUnsignedLeb128FromUInt64(value187);\n\n        require(keccak256(result187.buf) == keccak256(expected187), \"'136' is not returning '8801'\");\n\n        bytes memory expected188 = hex\"9801\";\n        uint64 value188 = 152;\n\n        Buffer.buffer memory result188 = Leb128.encodeUnsignedLeb128FromUInt64(value188);\n\n        require(keccak256(result188.buf) == keccak256(expected188), \"'152' is not returning '9801'\");\n\n        bytes memory expected189 = hex\"f301\";\n        uint64 value189 = 243;\n\n        Buffer.buffer memory result189 = Leb128.encodeUnsignedLeb128FromUInt64(value189);\n\n        require(keccak256(result189.buf) == keccak256(expected189), \"'243' is not returning 'f301'\");\n\n        bytes memory expected190 = hex\"26\";\n        uint64 value190 = 38;\n\n        Buffer.buffer memory result190 = Leb128.encodeUnsignedLeb128FromUInt64(value190);\n\n        require(keccak256(result190.buf) == keccak256(expected190), \"'38' is not returning '26'\");\n\n        bytes memory expected191 = hex\"de01\";\n        uint64 value191 = 222;\n\n        Buffer.buffer memory result191 = Leb128.encodeUnsignedLeb128FromUInt64(value191);\n\n        require(keccak256(result191.buf) == keccak256(expected191), \"'222' is not returning 'de01'\");\n\n        bytes memory expected192 = hex\"c301\";\n        uint64 value192 = 195;\n\n        Buffer.buffer memory result192 = Leb128.encodeUnsignedLeb128FromUInt64(value192);\n\n        require(keccak256(result192.buf) == keccak256(expected192), \"'195' is not returning 'c301'\");\n\n        bytes memory expected193 = hex\"0b\";\n        uint64 value193 = 11;\n\n        Buffer.buffer memory result193 = Leb128.encodeUnsignedLeb128FromUInt64(value193);\n\n        require(keccak256(result193.buf) == keccak256(expected193), \"'11' is not returning '0b'\");\n\n        bytes memory expected194 = hex\"c701\";\n        uint64 value194 = 199;\n\n        Buffer.buffer memory result194 = Leb128.encodeUnsignedLeb128FromUInt64(value194);\n\n        require(keccak256(result194.buf) == keccak256(expected194), \"'199' is not returning 'c701'\");\n\n        bytes memory expected195 = hex\"dc01\";\n        uint64 value195 = 220;\n\n        Buffer.buffer memory result195 = Leb128.encodeUnsignedLeb128FromUInt64(value195);\n\n        require(keccak256(result195.buf) == keccak256(expected195), \"'220' is not returning 'dc01'\");\n\n        bytes memory expected196 = hex\"5b\";\n        uint64 value196 = 91;\n\n        Buffer.buffer memory result196 = Leb128.encodeUnsignedLeb128FromUInt64(value196);\n\n        require(keccak256(result196.buf) == keccak256(expected196), \"'91' is not returning '5b'\");\n\n        bytes memory expected197 = hex\"60\";\n        uint64 value197 = 96;\n\n        Buffer.buffer memory result197 = Leb128.encodeUnsignedLeb128FromUInt64(value197);\n\n        require(keccak256(result197.buf) == keccak256(expected197), \"'96' is not returning '60'\");\n\n        bytes memory expected198 = hex\"9e01\";\n        uint64 value198 = 158;\n\n        Buffer.buffer memory result198 = Leb128.encodeUnsignedLeb128FromUInt64(value198);\n\n        require(keccak256(result198.buf) == keccak256(expected198), \"'158' is not returning '9e01'\");\n\n        bytes memory expected199 = hex\"f601\";\n        uint64 value199 = 246;\n\n        Buffer.buffer memory result199 = Leb128.encodeUnsignedLeb128FromUInt64(value199);\n\n        require(keccak256(result199.buf) == keccak256(expected199), \"'246' is not returning 'f601'\");\n\n        bytes memory expected200 = hex\"0e\";\n        uint64 value200 = 14;\n\n        Buffer.buffer memory result200 = Leb128.encodeUnsignedLeb128FromUInt64(value200);\n\n        require(keccak256(result200.buf) == keccak256(expected200), \"'14' is not returning '0e'\");\n\n        bytes memory expected201 = hex\"b201\";\n        uint64 value201 = 178;\n\n        Buffer.buffer memory result201 = Leb128.encodeUnsignedLeb128FromUInt64(value201);\n\n        require(keccak256(result201.buf) == keccak256(expected201), \"'178' is not returning 'b201'\");\n\n        bytes memory expected202 = hex\"78\";\n        uint64 value202 = 120;\n\n        Buffer.buffer memory result202 = Leb128.encodeUnsignedLeb128FromUInt64(value202);\n\n        require(keccak256(result202.buf) == keccak256(expected202), \"'120' is not returning '78'\");\n\n        bytes memory expected203 = hex\"f201\";\n        uint64 value203 = 242;\n\n        Buffer.buffer memory result203 = Leb128.encodeUnsignedLeb128FromUInt64(value203);\n\n        require(keccak256(result203.buf) == keccak256(expected203), \"'242' is not returning 'f201'\");\n\n        bytes memory expected204 = hex\"30\";\n        uint64 value204 = 48;\n\n        Buffer.buffer memory result204 = Leb128.encodeUnsignedLeb128FromUInt64(value204);\n\n        require(keccak256(result204.buf) == keccak256(expected204), \"'48' is not returning '30'\");\n\n        bytes memory expected205 = hex\"bd01\";\n        uint64 value205 = 189;\n\n        Buffer.buffer memory result205 = Leb128.encodeUnsignedLeb128FromUInt64(value205);\n\n        require(keccak256(result205.buf) == keccak256(expected205), \"'189' is not returning 'bd01'\");\n\n        bytes memory expected206 = hex\"79\";\n        uint64 value206 = 121;\n\n        Buffer.buffer memory result206 = Leb128.encodeUnsignedLeb128FromUInt64(value206);\n\n        require(keccak256(result206.buf) == keccak256(expected206), \"'121' is not returning '79'\");\n\n        bytes memory expected207 = hex\"d701\";\n        uint64 value207 = 215;\n\n        Buffer.buffer memory result207 = Leb128.encodeUnsignedLeb128FromUInt64(value207);\n\n        require(keccak256(result207.buf) == keccak256(expected207), \"'215' is not returning 'd701'\");\n\n        bytes memory expected208 = hex\"7c\";\n        uint64 value208 = 124;\n\n        Buffer.buffer memory result208 = Leb128.encodeUnsignedLeb128FromUInt64(value208);\n\n        require(keccak256(result208.buf) == keccak256(expected208), \"'124' is not returning '7c'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated4.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated4Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected210 = hex\"c101\";\n        uint64 value210 = 193;\n\n        Buffer.buffer memory result210 = Leb128.encodeUnsignedLeb128FromUInt64(value210);\n\n        require(keccak256(result210.buf) == keccak256(expected210), \"'193' is not returning 'c101'\");\n\n        bytes memory expected211 = hex\"08\";\n        uint64 value211 = 8;\n\n        Buffer.buffer memory result211 = Leb128.encodeUnsignedLeb128FromUInt64(value211);\n\n        require(keccak256(result211.buf) == keccak256(expected211), \"'8' is not returning '08'\");\n\n        bytes memory expected212 = hex\"e701\";\n        uint64 value212 = 231;\n\n        Buffer.buffer memory result212 = Leb128.encodeUnsignedLeb128FromUInt64(value212);\n\n        require(keccak256(result212.buf) == keccak256(expected212), \"'231' is not returning 'e701'\");\n\n        bytes memory expected213 = hex\"8701\";\n        uint64 value213 = 135;\n\n        Buffer.buffer memory result213 = Leb128.encodeUnsignedLeb128FromUInt64(value213);\n\n        require(keccak256(result213.buf) == keccak256(expected213), \"'135' is not returning '8701'\");\n\n        bytes memory expected214 = hex\"20\";\n        uint64 value214 = 32;\n\n        Buffer.buffer memory result214 = Leb128.encodeUnsignedLeb128FromUInt64(value214);\n\n        require(keccak256(result214.buf) == keccak256(expected214), \"'32' is not returning '20'\");\n\n        bytes memory expected215 = hex\"66\";\n        uint64 value215 = 102;\n\n        Buffer.buffer memory result215 = Leb128.encodeUnsignedLeb128FromUInt64(value215);\n\n        require(keccak256(result215.buf) == keccak256(expected215), \"'102' is not returning '66'\");\n\n        bytes memory expected216 = hex\"08\";\n        uint64 value216 = 8;\n\n        Buffer.buffer memory result216 = Leb128.encodeUnsignedLeb128FromUInt64(value216);\n\n        require(keccak256(result216.buf) == keccak256(expected216), \"'8' is not returning '08'\");\n\n        bytes memory expected217 = hex\"10\";\n        uint64 value217 = 16;\n\n        Buffer.buffer memory result217 = Leb128.encodeUnsignedLeb128FromUInt64(value217);\n\n        require(keccak256(result217.buf) == keccak256(expected217), \"'16' is not returning '10'\");\n\n        bytes memory expected218 = hex\"dd01\";\n        uint64 value218 = 221;\n\n        Buffer.buffer memory result218 = Leb128.encodeUnsignedLeb128FromUInt64(value218);\n\n        require(keccak256(result218.buf) == keccak256(expected218), \"'221' is not returning 'dd01'\");\n\n        bytes memory expected219 = hex\"64\";\n        uint64 value219 = 100;\n\n        Buffer.buffer memory result219 = Leb128.encodeUnsignedLeb128FromUInt64(value219);\n\n        require(keccak256(result219.buf) == keccak256(expected219), \"'100' is not returning '64'\");\n\n        bytes memory expected220 = hex\"8c01\";\n        uint64 value220 = 140;\n\n        Buffer.buffer memory result220 = Leb128.encodeUnsignedLeb128FromUInt64(value220);\n\n        require(keccak256(result220.buf) == keccak256(expected220), \"'140' is not returning '8c01'\");\n\n        bytes memory expected221 = hex\"62\";\n        uint64 value221 = 98;\n\n        Buffer.buffer memory result221 = Leb128.encodeUnsignedLeb128FromUInt64(value221);\n\n        require(keccak256(result221.buf) == keccak256(expected221), \"'98' is not returning '62'\");\n\n        bytes memory expected222 = hex\"42\";\n        uint64 value222 = 66;\n\n        Buffer.buffer memory result222 = Leb128.encodeUnsignedLeb128FromUInt64(value222);\n\n        require(keccak256(result222.buf) == keccak256(expected222), \"'66' is not returning '42'\");\n\n        bytes memory expected223 = hex\"9f01\";\n        uint64 value223 = 159;\n\n        Buffer.buffer memory result223 = Leb128.encodeUnsignedLeb128FromUInt64(value223);\n\n        require(keccak256(result223.buf) == keccak256(expected223), \"'159' is not returning '9f01'\");\n\n        bytes memory expected224 = hex\"06\";\n        uint64 value224 = 6;\n\n        Buffer.buffer memory result224 = Leb128.encodeUnsignedLeb128FromUInt64(value224);\n\n        require(keccak256(result224.buf) == keccak256(expected224), \"'6' is not returning '06'\");\n\n        bytes memory expected225 = hex\"bf01\";\n        uint64 value225 = 191;\n\n        Buffer.buffer memory result225 = Leb128.encodeUnsignedLeb128FromUInt64(value225);\n\n        require(keccak256(result225.buf) == keccak256(expected225), \"'191' is not returning 'bf01'\");\n\n        bytes memory expected226 = hex\"ff01\";\n        uint64 value226 = 255;\n\n        Buffer.buffer memory result226 = Leb128.encodeUnsignedLeb128FromUInt64(value226);\n\n        require(keccak256(result226.buf) == keccak256(expected226), \"'255' is not returning 'ff01'\");\n\n        bytes memory expected227 = hex\"d001\";\n        uint64 value227 = 208;\n\n        Buffer.buffer memory result227 = Leb128.encodeUnsignedLeb128FromUInt64(value227);\n\n        require(keccak256(result227.buf) == keccak256(expected227), \"'208' is not returning 'd001'\");\n\n        bytes memory expected228 = hex\"8401\";\n        uint64 value228 = 132;\n\n        Buffer.buffer memory result228 = Leb128.encodeUnsignedLeb128FromUInt64(value228);\n\n        require(keccak256(result228.buf) == keccak256(expected228), \"'132' is not returning '8401'\");\n\n        bytes memory expected229 = hex\"d701\";\n        uint64 value229 = 215;\n\n        Buffer.buffer memory result229 = Leb128.encodeUnsignedLeb128FromUInt64(value229);\n\n        require(keccak256(result229.buf) == keccak256(expected229), \"'215' is not returning 'd701'\");\n\n        bytes memory expected230 = hex\"da01\";\n        uint64 value230 = 218;\n\n        Buffer.buffer memory result230 = Leb128.encodeUnsignedLeb128FromUInt64(value230);\n\n        require(keccak256(result230.buf) == keccak256(expected230), \"'218' is not returning 'da01'\");\n\n        bytes memory expected231 = hex\"48\";\n        uint64 value231 = 72;\n\n        Buffer.buffer memory result231 = Leb128.encodeUnsignedLeb128FromUInt64(value231);\n\n        require(keccak256(result231.buf) == keccak256(expected231), \"'72' is not returning '48'\");\n\n        bytes memory expected232 = hex\"17\";\n        uint64 value232 = 23;\n\n        Buffer.buffer memory result232 = Leb128.encodeUnsignedLeb128FromUInt64(value232);\n\n        require(keccak256(result232.buf) == keccak256(expected232), \"'23' is not returning '17'\");\n\n        bytes memory expected233 = hex\"12\";\n        uint64 value233 = 18;\n\n        Buffer.buffer memory result233 = Leb128.encodeUnsignedLeb128FromUInt64(value233);\n\n        require(keccak256(result233.buf) == keccak256(expected233), \"'18' is not returning '12'\");\n\n        bytes memory expected234 = hex\"9201\";\n        uint64 value234 = 146;\n\n        Buffer.buffer memory result234 = Leb128.encodeUnsignedLeb128FromUInt64(value234);\n\n        require(keccak256(result234.buf) == keccak256(expected234), \"'146' is not returning '9201'\");\n\n        bytes memory expected235 = hex\"76\";\n        uint64 value235 = 118;\n\n        Buffer.buffer memory result235 = Leb128.encodeUnsignedLeb128FromUInt64(value235);\n\n        require(keccak256(result235.buf) == keccak256(expected235), \"'118' is not returning '76'\");\n\n        bytes memory expected236 = hex\"71\";\n        uint64 value236 = 113;\n\n        Buffer.buffer memory result236 = Leb128.encodeUnsignedLeb128FromUInt64(value236);\n\n        require(keccak256(result236.buf) == keccak256(expected236), \"'113' is not returning '71'\");\n\n        bytes memory expected237 = hex\"4c\";\n        uint64 value237 = 76;\n\n        Buffer.buffer memory result237 = Leb128.encodeUnsignedLeb128FromUInt64(value237);\n\n        require(keccak256(result237.buf) == keccak256(expected237), \"'76' is not returning '4c'\");\n\n        bytes memory expected238 = hex\"cf01\";\n        uint64 value238 = 207;\n\n        Buffer.buffer memory result238 = Leb128.encodeUnsignedLeb128FromUInt64(value238);\n\n        require(keccak256(result238.buf) == keccak256(expected238), \"'207' is not returning 'cf01'\");\n\n        bytes memory expected239 = hex\"9101\";\n        uint64 value239 = 145;\n\n        Buffer.buffer memory result239 = Leb128.encodeUnsignedLeb128FromUInt64(value239);\n\n        require(keccak256(result239.buf) == keccak256(expected239), \"'145' is not returning '9101'\");\n\n        bytes memory expected240 = hex\"2f\";\n        uint64 value240 = 47;\n\n        Buffer.buffer memory result240 = Leb128.encodeUnsignedLeb128FromUInt64(value240);\n\n        require(keccak256(result240.buf) == keccak256(expected240), \"'47' is not returning '2f'\");\n\n        bytes memory expected241 = hex\"23\";\n        uint64 value241 = 35;\n\n        Buffer.buffer memory result241 = Leb128.encodeUnsignedLeb128FromUInt64(value241);\n\n        require(keccak256(result241.buf) == keccak256(expected241), \"'35' is not returning '23'\");\n\n        bytes memory expected242 = hex\"a401\";\n        uint64 value242 = 164;\n\n        Buffer.buffer memory result242 = Leb128.encodeUnsignedLeb128FromUInt64(value242);\n\n        require(keccak256(result242.buf) == keccak256(expected242), \"'164' is not returning 'a401'\");\n\n        bytes memory expected243 = hex\"72\";\n        uint64 value243 = 114;\n\n        Buffer.buffer memory result243 = Leb128.encodeUnsignedLeb128FromUInt64(value243);\n\n        require(keccak256(result243.buf) == keccak256(expected243), \"'114' is not returning '72'\");\n\n        bytes memory expected244 = hex\"f301\";\n        uint64 value244 = 243;\n\n        Buffer.buffer memory result244 = Leb128.encodeUnsignedLeb128FromUInt64(value244);\n\n        require(keccak256(result244.buf) == keccak256(expected244), \"'243' is not returning 'f301'\");\n\n        bytes memory expected245 = hex\"3f\";\n        uint64 value245 = 63;\n\n        Buffer.buffer memory result245 = Leb128.encodeUnsignedLeb128FromUInt64(value245);\n\n        require(keccak256(result245.buf) == keccak256(expected245), \"'63' is not returning '3f'\");\n\n        bytes memory expected246 = hex\"f101\";\n        uint64 value246 = 241;\n\n        Buffer.buffer memory result246 = Leb128.encodeUnsignedLeb128FromUInt64(value246);\n\n        require(keccak256(result246.buf) == keccak256(expected246), \"'241' is not returning 'f101'\");\n\n        bytes memory expected247 = hex\"dd01\";\n        uint64 value247 = 221;\n\n        Buffer.buffer memory result247 = Leb128.encodeUnsignedLeb128FromUInt64(value247);\n\n        require(keccak256(result247.buf) == keccak256(expected247), \"'221' is not returning 'dd01'\");\n\n        bytes memory expected248 = hex\"0e\";\n        uint64 value248 = 14;\n\n        Buffer.buffer memory result248 = Leb128.encodeUnsignedLeb128FromUInt64(value248);\n\n        require(keccak256(result248.buf) == keccak256(expected248), \"'14' is not returning '0e'\");\n\n        bytes memory expected249 = hex\"51\";\n        uint64 value249 = 81;\n\n        Buffer.buffer memory result249 = Leb128.encodeUnsignedLeb128FromUInt64(value249);\n\n        require(keccak256(result249.buf) == keccak256(expected249), \"'81' is not returning '51'\");\n\n        bytes memory expected250 = hex\"9b01\";\n        uint64 value250 = 155;\n\n        Buffer.buffer memory result250 = Leb128.encodeUnsignedLeb128FromUInt64(value250);\n\n        require(keccak256(result250.buf) == keccak256(expected250), \"'155' is not returning '9b01'\");\n\n        bytes memory expected251 = hex\"79\";\n        uint64 value251 = 121;\n\n        Buffer.buffer memory result251 = Leb128.encodeUnsignedLeb128FromUInt64(value251);\n\n        require(keccak256(result251.buf) == keccak256(expected251), \"'121' is not returning '79'\");\n\n        bytes memory expected252 = hex\"9d01\";\n        uint64 value252 = 157;\n\n        Buffer.buffer memory result252 = Leb128.encodeUnsignedLeb128FromUInt64(value252);\n\n        require(keccak256(result252.buf) == keccak256(expected252), \"'157' is not returning '9d01'\");\n\n        bytes memory expected253 = hex\"77\";\n        uint64 value253 = 119;\n\n        Buffer.buffer memory result253 = Leb128.encodeUnsignedLeb128FromUInt64(value253);\n\n        require(keccak256(result253.buf) == keccak256(expected253), \"'119' is not returning '77'\");\n\n        bytes memory expected254 = hex\"da01\";\n        uint64 value254 = 218;\n\n        Buffer.buffer memory result254 = Leb128.encodeUnsignedLeb128FromUInt64(value254);\n\n        require(keccak256(result254.buf) == keccak256(expected254), \"'218' is not returning 'da01'\");\n\n        bytes memory expected255 = hex\"3f\";\n        uint64 value255 = 63;\n\n        Buffer.buffer memory result255 = Leb128.encodeUnsignedLeb128FromUInt64(value255);\n\n        require(keccak256(result255.buf) == keccak256(expected255), \"'63' is not returning '3f'\");\n\n        bytes memory expected256 = hex\"ea9001\";\n        uint64 value256 = 18538;\n\n        Buffer.buffer memory result256 = Leb128.encodeUnsignedLeb128FromUInt64(value256);\n\n        require(keccak256(result256.buf) == keccak256(expected256), \"'18538' is not returning 'ea9001'\");\n\n        bytes memory expected257 = hex\"835e\";\n        uint64 value257 = 12035;\n\n        Buffer.buffer memory result257 = Leb128.encodeUnsignedLeb128FromUInt64(value257);\n\n        require(keccak256(result257.buf) == keccak256(expected257), \"'12035' is not returning '835e'\");\n\n        bytes memory expected258 = hex\"b9b701\";\n        uint64 value258 = 23481;\n\n        Buffer.buffer memory result258 = Leb128.encodeUnsignedLeb128FromUInt64(value258);\n\n        require(keccak256(result258.buf) == keccak256(expected258), \"'23481' is not returning 'b9b701'\");\n\n        bytes memory expected259 = hex\"b4b303\";\n        uint64 value259 = 55732;\n\n        Buffer.buffer memory result259 = Leb128.encodeUnsignedLeb128FromUInt64(value259);\n\n        require(keccak256(result259.buf) == keccak256(expected259), \"'55732' is not returning 'b4b303'\");\n\n        bytes memory expected260 = hex\"cea602\";\n        uint64 value260 = 37710;\n\n        Buffer.buffer memory result260 = Leb128.encodeUnsignedLeb128FromUInt64(value260);\n\n        require(keccak256(result260.buf) == keccak256(expected260), \"'37710' is not returning 'cea602'\");\n\n        bytes memory expected261 = hex\"c79f02\";\n        uint64 value261 = 36807;\n\n        Buffer.buffer memory result261 = Leb128.encodeUnsignedLeb128FromUInt64(value261);\n\n        require(keccak256(result261.buf) == keccak256(expected261), \"'36807' is not returning 'c79f02'\");\n\n        bytes memory expected262 = hex\"9ad702\";\n        uint64 value262 = 43930;\n\n        Buffer.buffer memory result262 = Leb128.encodeUnsignedLeb128FromUInt64(value262);\n\n        require(keccak256(result262.buf) == keccak256(expected262), \"'43930' is not returning '9ad702'\");\n\n        bytes memory expected263 = hex\"d69b01\";\n        uint64 value263 = 19926;\n\n        Buffer.buffer memory result263 = Leb128.encodeUnsignedLeb128FromUInt64(value263);\n\n        require(keccak256(result263.buf) == keccak256(expected263), \"'19926' is not returning 'd69b01'\");\n\n        bytes memory expected264 = hex\"bd8801\";\n        uint64 value264 = 17469;\n\n        Buffer.buffer memory result264 = Leb128.encodeUnsignedLeb128FromUInt64(value264);\n\n        require(keccak256(result264.buf) == keccak256(expected264), \"'17469' is not returning 'bd8801'\");\n\n        bytes memory expected265 = hex\"b66e\";\n        uint64 value265 = 14134;\n\n        Buffer.buffer memory result265 = Leb128.encodeUnsignedLeb128FromUInt64(value265);\n\n        require(keccak256(result265.buf) == keccak256(expected265), \"'14134' is not returning 'b66e'\");\n\n        bytes memory expected266 = hex\"ff49\";\n        uint64 value266 = 9471;\n\n        Buffer.buffer memory result266 = Leb128.encodeUnsignedLeb128FromUInt64(value266);\n\n        require(keccak256(result266.buf) == keccak256(expected266), \"'9471' is not returning 'ff49'\");\n\n        bytes memory expected267 = hex\"bfe301\";\n        uint64 value267 = 29119;\n\n        Buffer.buffer memory result267 = Leb128.encodeUnsignedLeb128FromUInt64(value267);\n\n        require(keccak256(result267.buf) == keccak256(expected267), \"'29119' is not returning 'bfe301'\");\n\n        bytes memory expected268 = hex\"cd0e\";\n        uint64 value268 = 1869;\n\n        Buffer.buffer memory result268 = Leb128.encodeUnsignedLeb128FromUInt64(value268);\n\n        require(keccak256(result268.buf) == keccak256(expected268), \"'1869' is not returning 'cd0e'\");\n\n        bytes memory expected269 = hex\"e85e\";\n        uint64 value269 = 12136;\n\n        Buffer.buffer memory result269 = Leb128.encodeUnsignedLeb128FromUInt64(value269);\n\n        require(keccak256(result269.buf) == keccak256(expected269), \"'12136' is not returning 'e85e'\");\n\n        bytes memory expected270 = hex\"b8ab02\";\n        uint64 value270 = 38328;\n\n        Buffer.buffer memory result270 = Leb128.encodeUnsignedLeb128FromUInt64(value270);\n\n        require(keccak256(result270.buf) == keccak256(expected270), \"'38328' is not returning 'b8ab02'\");\n\n        bytes memory expected271 = hex\"c043\";\n        uint64 value271 = 8640;\n\n        Buffer.buffer memory result271 = Leb128.encodeUnsignedLeb128FromUInt64(value271);\n\n        require(keccak256(result271.buf) == keccak256(expected271), \"'8640' is not returning 'c043'\");\n\n        bytes memory expected272 = hex\"c6ee02\";\n        uint64 value272 = 46918;\n\n        Buffer.buffer memory result272 = Leb128.encodeUnsignedLeb128FromUInt64(value272);\n\n        require(keccak256(result272.buf) == keccak256(expected272), \"'46918' is not returning 'c6ee02'\");\n\n        bytes memory expected273 = hex\"c3b403\";\n        uint64 value273 = 55875;\n\n        Buffer.buffer memory result273 = Leb128.encodeUnsignedLeb128FromUInt64(value273);\n\n        require(keccak256(result273.buf) == keccak256(expected273), \"'55875' is not returning 'c3b403'\");\n\n        bytes memory expected274 = hex\"9e05\";\n        uint64 value274 = 670;\n\n        Buffer.buffer memory result274 = Leb128.encodeUnsignedLeb128FromUInt64(value274);\n\n        require(keccak256(result274.buf) == keccak256(expected274), \"'670' is not returning '9e05'\");\n\n        bytes memory expected275 = hex\"d4d603\";\n        uint64 value275 = 60244;\n\n        Buffer.buffer memory result275 = Leb128.encodeUnsignedLeb128FromUInt64(value275);\n\n        require(keccak256(result275.buf) == keccak256(expected275), \"'60244' is not returning 'd4d603'\");\n\n        bytes memory expected276 = hex\"a4d801\";\n        uint64 value276 = 27684;\n\n        Buffer.buffer memory result276 = Leb128.encodeUnsignedLeb128FromUInt64(value276);\n\n        require(keccak256(result276.buf) == keccak256(expected276), \"'27684' is not returning 'a4d801'\");\n\n        bytes memory expected277 = hex\"d69803\";\n        uint64 value277 = 52310;\n\n        Buffer.buffer memory result277 = Leb128.encodeUnsignedLeb128FromUInt64(value277);\n\n        require(keccak256(result277.buf) == keccak256(expected277), \"'52310' is not returning 'd69803'\");\n\n        bytes memory expected278 = hex\"fc8d03\";\n        uint64 value278 = 50940;\n\n        Buffer.buffer memory result278 = Leb128.encodeUnsignedLeb128FromUInt64(value278);\n\n        require(keccak256(result278.buf) == keccak256(expected278), \"'50940' is not returning 'fc8d03'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated5.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated5Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected280 = hex\"e78701\";\n        uint64 value280 = 17383;\n\n        Buffer.buffer memory result280 = Leb128.encodeUnsignedLeb128FromUInt64(value280);\n\n        require(keccak256(result280.buf) == keccak256(expected280), \"'17383' is not returning 'e78701'\");\n\n        bytes memory expected281 = hex\"ccd002\";\n        uint64 value281 = 43084;\n\n        Buffer.buffer memory result281 = Leb128.encodeUnsignedLeb128FromUInt64(value281);\n\n        require(keccak256(result281.buf) == keccak256(expected281), \"'43084' is not returning 'ccd002'\");\n\n        bytes memory expected282 = hex\"b0fa02\";\n        uint64 value282 = 48432;\n\n        Buffer.buffer memory result282 = Leb128.encodeUnsignedLeb128FromUInt64(value282);\n\n        require(keccak256(result282.buf) == keccak256(expected282), \"'48432' is not returning 'b0fa02'\");\n\n        bytes memory expected283 = hex\"f4d403\";\n        uint64 value283 = 60020;\n\n        Buffer.buffer memory result283 = Leb128.encodeUnsignedLeb128FromUInt64(value283);\n\n        require(keccak256(result283.buf) == keccak256(expected283), \"'60020' is not returning 'f4d403'\");\n\n        bytes memory expected284 = hex\"c40e\";\n        uint64 value284 = 1860;\n\n        Buffer.buffer memory result284 = Leb128.encodeUnsignedLeb128FromUInt64(value284);\n\n        require(keccak256(result284.buf) == keccak256(expected284), \"'1860' is not returning 'c40e'\");\n\n        bytes memory expected285 = hex\"bcff02\";\n        uint64 value285 = 49084;\n\n        Buffer.buffer memory result285 = Leb128.encodeUnsignedLeb128FromUInt64(value285);\n\n        require(keccak256(result285.buf) == keccak256(expected285), \"'49084' is not returning 'bcff02'\");\n\n        bytes memory expected286 = hex\"c17c\";\n        uint64 value286 = 15937;\n\n        Buffer.buffer memory result286 = Leb128.encodeUnsignedLeb128FromUInt64(value286);\n\n        require(keccak256(result286.buf) == keccak256(expected286), \"'15937' is not returning 'c17c'\");\n\n        bytes memory expected287 = hex\"8ba501\";\n        uint64 value287 = 21131;\n\n        Buffer.buffer memory result287 = Leb128.encodeUnsignedLeb128FromUInt64(value287);\n\n        require(keccak256(result287.buf) == keccak256(expected287), \"'21131' is not returning '8ba501'\");\n\n        bytes memory expected288 = hex\"e6f801\";\n        uint64 value288 = 31846;\n\n        Buffer.buffer memory result288 = Leb128.encodeUnsignedLeb128FromUInt64(value288);\n\n        require(keccak256(result288.buf) == keccak256(expected288), \"'31846' is not returning 'e6f801'\");\n\n        bytes memory expected289 = hex\"9e8502\";\n        uint64 value289 = 33438;\n\n        Buffer.buffer memory result289 = Leb128.encodeUnsignedLeb128FromUInt64(value289);\n\n        require(keccak256(result289.buf) == keccak256(expected289), \"'33438' is not returning '9e8502'\");\n\n        bytes memory expected290 = hex\"8ffb01\";\n        uint64 value290 = 32143;\n\n        Buffer.buffer memory result290 = Leb128.encodeUnsignedLeb128FromUInt64(value290);\n\n        require(keccak256(result290.buf) == keccak256(expected290), \"'32143' is not returning '8ffb01'\");\n\n        bytes memory expected291 = hex\"c2c903\";\n        uint64 value291 = 58562;\n\n        Buffer.buffer memory result291 = Leb128.encodeUnsignedLeb128FromUInt64(value291);\n\n        require(keccak256(result291.buf) == keccak256(expected291), \"'58562' is not returning 'c2c903'\");\n\n        bytes memory expected292 = hex\"dcaf01\";\n        uint64 value292 = 22492;\n\n        Buffer.buffer memory result292 = Leb128.encodeUnsignedLeb128FromUInt64(value292);\n\n        require(keccak256(result292.buf) == keccak256(expected292), \"'22492' is not returning 'dcaf01'\");\n\n        bytes memory expected293 = hex\"e1b802\";\n        uint64 value293 = 40033;\n\n        Buffer.buffer memory result293 = Leb128.encodeUnsignedLeb128FromUInt64(value293);\n\n        require(keccak256(result293.buf) == keccak256(expected293), \"'40033' is not returning 'e1b802'\");\n\n        bytes memory expected294 = hex\"84fa02\";\n        uint64 value294 = 48388;\n\n        Buffer.buffer memory result294 = Leb128.encodeUnsignedLeb128FromUInt64(value294);\n\n        require(keccak256(result294.buf) == keccak256(expected294), \"'48388' is not returning '84fa02'\");\n\n        bytes memory expected295 = hex\"eae401\";\n        uint64 value295 = 29290;\n\n        Buffer.buffer memory result295 = Leb128.encodeUnsignedLeb128FromUInt64(value295);\n\n        require(keccak256(result295.buf) == keccak256(expected295), \"'29290' is not returning 'eae401'\");\n\n        bytes memory expected296 = hex\"a8a403\";\n        uint64 value296 = 53800;\n\n        Buffer.buffer memory result296 = Leb128.encodeUnsignedLeb128FromUInt64(value296);\n\n        require(keccak256(result296.buf) == keccak256(expected296), \"'53800' is not returning 'a8a403'\");\n\n        bytes memory expected297 = hex\"a2c003\";\n        uint64 value297 = 57378;\n\n        Buffer.buffer memory result297 = Leb128.encodeUnsignedLeb128FromUInt64(value297);\n\n        require(keccak256(result297.buf) == keccak256(expected297), \"'57378' is not returning 'a2c003'\");\n\n        bytes memory expected298 = hex\"b9f402\";\n        uint64 value298 = 47673;\n\n        Buffer.buffer memory result298 = Leb128.encodeUnsignedLeb128FromUInt64(value298);\n\n        require(keccak256(result298.buf) == keccak256(expected298), \"'47673' is not returning 'b9f402'\");\n\n        bytes memory expected299 = hex\"82ce03\";\n        uint64 value299 = 59138;\n\n        Buffer.buffer memory result299 = Leb128.encodeUnsignedLeb128FromUInt64(value299);\n\n        require(keccak256(result299.buf) == keccak256(expected299), \"'59138' is not returning '82ce03'\");\n\n        bytes memory expected300 = hex\"d2a202\";\n        uint64 value300 = 37202;\n\n        Buffer.buffer memory result300 = Leb128.encodeUnsignedLeb128FromUInt64(value300);\n\n        require(keccak256(result300.buf) == keccak256(expected300), \"'37202' is not returning 'd2a202'\");\n\n        bytes memory expected301 = hex\"a7ff02\";\n        uint64 value301 = 49063;\n\n        Buffer.buffer memory result301 = Leb128.encodeUnsignedLeb128FromUInt64(value301);\n\n        require(keccak256(result301.buf) == keccak256(expected301), \"'49063' is not returning 'a7ff02'\");\n\n        bytes memory expected302 = hex\"cbf502\";\n        uint64 value302 = 47819;\n\n        Buffer.buffer memory result302 = Leb128.encodeUnsignedLeb128FromUInt64(value302);\n\n        require(keccak256(result302.buf) == keccak256(expected302), \"'47819' is not returning 'cbf502'\");\n\n        bytes memory expected303 = hex\"e09c03\";\n        uint64 value303 = 52832;\n\n        Buffer.buffer memory result303 = Leb128.encodeUnsignedLeb128FromUInt64(value303);\n\n        require(keccak256(result303.buf) == keccak256(expected303), \"'52832' is not returning 'e09c03'\");\n\n        bytes memory expected304 = hex\"ccd603\";\n        uint64 value304 = 60236;\n\n        Buffer.buffer memory result304 = Leb128.encodeUnsignedLeb128FromUInt64(value304);\n\n        require(keccak256(result304.buf) == keccak256(expected304), \"'60236' is not returning 'ccd603'\");\n\n        bytes memory expected305 = hex\"cfb003\";\n        uint64 value305 = 55375;\n\n        Buffer.buffer memory result305 = Leb128.encodeUnsignedLeb128FromUInt64(value305);\n\n        require(keccak256(result305.buf) == keccak256(expected305), \"'55375' is not returning 'cfb003'\");\n\n        bytes memory expected306 = hex\"ef3b\";\n        uint64 value306 = 7663;\n\n        Buffer.buffer memory result306 = Leb128.encodeUnsignedLeb128FromUInt64(value306);\n\n        require(keccak256(result306.buf) == keccak256(expected306), \"'7663' is not returning 'ef3b'\");\n\n        bytes memory expected307 = hex\"a237\";\n        uint64 value307 = 7074;\n\n        Buffer.buffer memory result307 = Leb128.encodeUnsignedLeb128FromUInt64(value307);\n\n        require(keccak256(result307.buf) == keccak256(expected307), \"'7074' is not returning 'a237'\");\n\n        bytes memory expected308 = hex\"86c503\";\n        uint64 value308 = 57990;\n\n        Buffer.buffer memory result308 = Leb128.encodeUnsignedLeb128FromUInt64(value308);\n\n        require(keccak256(result308.buf) == keccak256(expected308), \"'57990' is not returning '86c503'\");\n\n        bytes memory expected309 = hex\"899401\";\n        uint64 value309 = 18953;\n\n        Buffer.buffer memory result309 = Leb128.encodeUnsignedLeb128FromUInt64(value309);\n\n        require(keccak256(result309.buf) == keccak256(expected309), \"'18953' is not returning '899401'\");\n\n        bytes memory expected310 = hex\"bd28\";\n        uint64 value310 = 5181;\n\n        Buffer.buffer memory result310 = Leb128.encodeUnsignedLeb128FromUInt64(value310);\n\n        require(keccak256(result310.buf) == keccak256(expected310), \"'5181' is not returning 'bd28'\");\n\n        bytes memory expected311 = hex\"b646\";\n        uint64 value311 = 9014;\n\n        Buffer.buffer memory result311 = Leb128.encodeUnsignedLeb128FromUInt64(value311);\n\n        require(keccak256(result311.buf) == keccak256(expected311), \"'9014' is not returning 'b646'\");\n\n        bytes memory expected312 = hex\"c953\";\n        uint64 value312 = 10697;\n\n        Buffer.buffer memory result312 = Leb128.encodeUnsignedLeb128FromUInt64(value312);\n\n        require(keccak256(result312.buf) == keccak256(expected312), \"'10697' is not returning 'c953'\");\n\n        bytes memory expected313 = hex\"e7f003\";\n        uint64 value313 = 63591;\n\n        Buffer.buffer memory result313 = Leb128.encodeUnsignedLeb128FromUInt64(value313);\n\n        require(keccak256(result313.buf) == keccak256(expected313), \"'63591' is not returning 'e7f003'\");\n\n        bytes memory expected314 = hex\"b1ed02\";\n        uint64 value314 = 46769;\n\n        Buffer.buffer memory result314 = Leb128.encodeUnsignedLeb128FromUInt64(value314);\n\n        require(keccak256(result314.buf) == keccak256(expected314), \"'46769' is not returning 'b1ed02'\");\n\n        bytes memory expected315 = hex\"edbc03\";\n        uint64 value315 = 56941;\n\n        Buffer.buffer memory result315 = Leb128.encodeUnsignedLeb128FromUInt64(value315);\n\n        require(keccak256(result315.buf) == keccak256(expected315), \"'56941' is not returning 'edbc03'\");\n\n        bytes memory expected316 = hex\"8fc902\";\n        uint64 value316 = 42127;\n\n        Buffer.buffer memory result316 = Leb128.encodeUnsignedLeb128FromUInt64(value316);\n\n        require(keccak256(result316.buf) == keccak256(expected316), \"'42127' is not returning '8fc902'\");\n\n        bytes memory expected317 = hex\"b99601\";\n        uint64 value317 = 19257;\n\n        Buffer.buffer memory result317 = Leb128.encodeUnsignedLeb128FromUInt64(value317);\n\n        require(keccak256(result317.buf) == keccak256(expected317), \"'19257' is not returning 'b99601'\");\n\n        bytes memory expected318 = hex\"948a01\";\n        uint64 value318 = 17684;\n\n        Buffer.buffer memory result318 = Leb128.encodeUnsignedLeb128FromUInt64(value318);\n\n        require(keccak256(result318.buf) == keccak256(expected318), \"'17684' is not returning '948a01'\");\n\n        bytes memory expected319 = hex\"ad0a\";\n        uint64 value319 = 1325;\n\n        Buffer.buffer memory result319 = Leb128.encodeUnsignedLeb128FromUInt64(value319);\n\n        require(keccak256(result319.buf) == keccak256(expected319), \"'1325' is not returning 'ad0a'\");\n\n        bytes memory expected320 = hex\"90e303\";\n        uint64 value320 = 61840;\n\n        Buffer.buffer memory result320 = Leb128.encodeUnsignedLeb128FromUInt64(value320);\n\n        require(keccak256(result320.buf) == keccak256(expected320), \"'61840' is not returning '90e303'\");\n\n        bytes memory expected321 = hex\"86be02\";\n        uint64 value321 = 40710;\n\n        Buffer.buffer memory result321 = Leb128.encodeUnsignedLeb128FromUInt64(value321);\n\n        require(keccak256(result321.buf) == keccak256(expected321), \"'40710' is not returning '86be02'\");\n\n        bytes memory expected322 = hex\"82e503\";\n        uint64 value322 = 62082;\n\n        Buffer.buffer memory result322 = Leb128.encodeUnsignedLeb128FromUInt64(value322);\n\n        require(keccak256(result322.buf) == keccak256(expected322), \"'62082' is not returning '82e503'\");\n\n        bytes memory expected323 = hex\"aeb601\";\n        uint64 value323 = 23342;\n\n        Buffer.buffer memory result323 = Leb128.encodeUnsignedLeb128FromUInt64(value323);\n\n        require(keccak256(result323.buf) == keccak256(expected323), \"'23342' is not returning 'aeb601'\");\n\n        bytes memory expected324 = hex\"f29102\";\n        uint64 value324 = 35058;\n\n        Buffer.buffer memory result324 = Leb128.encodeUnsignedLeb128FromUInt64(value324);\n\n        require(keccak256(result324.buf) == keccak256(expected324), \"'35058' is not returning 'f29102'\");\n\n        bytes memory expected325 = hex\"dfb902\";\n        uint64 value325 = 40159;\n\n        Buffer.buffer memory result325 = Leb128.encodeUnsignedLeb128FromUInt64(value325);\n\n        require(keccak256(result325.buf) == keccak256(expected325), \"'40159' is not returning 'dfb902'\");\n\n        bytes memory expected326 = hex\"9dd902\";\n        uint64 value326 = 44189;\n\n        Buffer.buffer memory result326 = Leb128.encodeUnsignedLeb128FromUInt64(value326);\n\n        require(keccak256(result326.buf) == keccak256(expected326), \"'44189' is not returning '9dd902'\");\n\n        bytes memory expected327 = hex\"d4e403\";\n        uint64 value327 = 62036;\n\n        Buffer.buffer memory result327 = Leb128.encodeUnsignedLeb128FromUInt64(value327);\n\n        require(keccak256(result327.buf) == keccak256(expected327), \"'62036' is not returning 'd4e403'\");\n\n        bytes memory expected328 = hex\"9fc202\";\n        uint64 value328 = 41247;\n\n        Buffer.buffer memory result328 = Leb128.encodeUnsignedLeb128FromUInt64(value328);\n\n        require(keccak256(result328.buf) == keccak256(expected328), \"'41247' is not returning '9fc202'\");\n\n        bytes memory expected329 = hex\"d8d003\";\n        uint64 value329 = 59480;\n\n        Buffer.buffer memory result329 = Leb128.encodeUnsignedLeb128FromUInt64(value329);\n\n        require(keccak256(result329.buf) == keccak256(expected329), \"'59480' is not returning 'd8d003'\");\n\n        bytes memory expected330 = hex\"a8aa02\";\n        uint64 value330 = 38184;\n\n        Buffer.buffer memory result330 = Leb128.encodeUnsignedLeb128FromUInt64(value330);\n\n        require(keccak256(result330.buf) == keccak256(expected330), \"'38184' is not returning 'a8aa02'\");\n\n        bytes memory expected331 = hex\"967a\";\n        uint64 value331 = 15638;\n\n        Buffer.buffer memory result331 = Leb128.encodeUnsignedLeb128FromUInt64(value331);\n\n        require(keccak256(result331.buf) == keccak256(expected331), \"'15638' is not returning '967a'\");\n\n        bytes memory expected332 = hex\"b1d003\";\n        uint64 value332 = 59441;\n\n        Buffer.buffer memory result332 = Leb128.encodeUnsignedLeb128FromUInt64(value332);\n\n        require(keccak256(result332.buf) == keccak256(expected332), \"'59441' is not returning 'b1d003'\");\n\n        bytes memory expected333 = hex\"859202\";\n        uint64 value333 = 35077;\n\n        Buffer.buffer memory result333 = Leb128.encodeUnsignedLeb128FromUInt64(value333);\n\n        require(keccak256(result333.buf) == keccak256(expected333), \"'35077' is not returning '859202'\");\n\n        bytes memory expected334 = hex\"8b1d\";\n        uint64 value334 = 3723;\n\n        Buffer.buffer memory result334 = Leb128.encodeUnsignedLeb128FromUInt64(value334);\n\n        require(keccak256(result334.buf) == keccak256(expected334), \"'3723' is not returning '8b1d'\");\n\n        bytes memory expected335 = hex\"e79601\";\n        uint64 value335 = 19303;\n\n        Buffer.buffer memory result335 = Leb128.encodeUnsignedLeb128FromUInt64(value335);\n\n        require(keccak256(result335.buf) == keccak256(expected335), \"'19303' is not returning 'e79601'\");\n\n        bytes memory expected336 = hex\"821e\";\n        uint64 value336 = 3842;\n\n        Buffer.buffer memory result336 = Leb128.encodeUnsignedLeb128FromUInt64(value336);\n\n        require(keccak256(result336.buf) == keccak256(expected336), \"'3842' is not returning '821e'\");\n\n        bytes memory expected337 = hex\"b1d001\";\n        uint64 value337 = 26673;\n\n        Buffer.buffer memory result337 = Leb128.encodeUnsignedLeb128FromUInt64(value337);\n\n        require(keccak256(result337.buf) == keccak256(expected337), \"'26673' is not returning 'b1d001'\");\n\n        bytes memory expected338 = hex\"e0fe03\";\n        uint64 value338 = 65376;\n\n        Buffer.buffer memory result338 = Leb128.encodeUnsignedLeb128FromUInt64(value338);\n\n        require(keccak256(result338.buf) == keccak256(expected338), \"'65376' is not returning 'e0fe03'\");\n\n        bytes memory expected339 = hex\"fdc602\";\n        uint64 value339 = 41853;\n\n        Buffer.buffer memory result339 = Leb128.encodeUnsignedLeb128FromUInt64(value339);\n\n        require(keccak256(result339.buf) == keccak256(expected339), \"'41853' is not returning 'fdc602'\");\n\n        bytes memory expected340 = hex\"f8e901\";\n        uint64 value340 = 29944;\n\n        Buffer.buffer memory result340 = Leb128.encodeUnsignedLeb128FromUInt64(value340);\n\n        require(keccak256(result340.buf) == keccak256(expected340), \"'29944' is not returning 'f8e901'\");\n\n        bytes memory expected341 = hex\"8ba802\";\n        uint64 value341 = 37899;\n\n        Buffer.buffer memory result341 = Leb128.encodeUnsignedLeb128FromUInt64(value341);\n\n        require(keccak256(result341.buf) == keccak256(expected341), \"'37899' is not returning '8ba802'\");\n\n        bytes memory expected342 = hex\"81c903\";\n        uint64 value342 = 58497;\n\n        Buffer.buffer memory result342 = Leb128.encodeUnsignedLeb128FromUInt64(value342);\n\n        require(keccak256(result342.buf) == keccak256(expected342), \"'58497' is not returning '81c903'\");\n\n        bytes memory expected343 = hex\"989501\";\n        uint64 value343 = 19096;\n\n        Buffer.buffer memory result343 = Leb128.encodeUnsignedLeb128FromUInt64(value343);\n\n        require(keccak256(result343.buf) == keccak256(expected343), \"'19096' is not returning '989501'\");\n\n        bytes memory expected344 = hex\"ba7a\";\n        uint64 value344 = 15674;\n\n        Buffer.buffer memory result344 = Leb128.encodeUnsignedLeb128FromUInt64(value344);\n\n        require(keccak256(result344.buf) == keccak256(expected344), \"'15674' is not returning 'ba7a'\");\n\n        bytes memory expected345 = hex\"99df01\";\n        uint64 value345 = 28569;\n\n        Buffer.buffer memory result345 = Leb128.encodeUnsignedLeb128FromUInt64(value345);\n\n        require(keccak256(result345.buf) == keccak256(expected345), \"'28569' is not returning '99df01'\");\n\n        bytes memory expected346 = hex\"edf703\";\n        uint64 value346 = 64493;\n\n        Buffer.buffer memory result346 = Leb128.encodeUnsignedLeb128FromUInt64(value346);\n\n        require(keccak256(result346.buf) == keccak256(expected346), \"'64493' is not returning 'edf703'\");\n\n        bytes memory expected347 = hex\"b4fd01\";\n        uint64 value347 = 32436;\n\n        Buffer.buffer memory result347 = Leb128.encodeUnsignedLeb128FromUInt64(value347);\n\n        require(keccak256(result347.buf) == keccak256(expected347), \"'32436' is not returning 'b4fd01'\");\n\n        bytes memory expected348 = hex\"f733\";\n        uint64 value348 = 6647;\n\n        Buffer.buffer memory result348 = Leb128.encodeUnsignedLeb128FromUInt64(value348);\n\n        require(keccak256(result348.buf) == keccak256(expected348), \"'6647' is not returning 'f733'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated6.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated6Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected350 = hex\"cc78\";\n        uint64 value350 = 15436;\n\n        Buffer.buffer memory result350 = Leb128.encodeUnsignedLeb128FromUInt64(value350);\n\n        require(keccak256(result350.buf) == keccak256(expected350), \"'15436' is not returning 'cc78'\");\n\n        bytes memory expected351 = hex\"e68d03\";\n        uint64 value351 = 50918;\n\n        Buffer.buffer memory result351 = Leb128.encodeUnsignedLeb128FromUInt64(value351);\n\n        require(keccak256(result351.buf) == keccak256(expected351), \"'50918' is not returning 'e68d03'\");\n\n        bytes memory expected352 = hex\"9873\";\n        uint64 value352 = 14744;\n\n        Buffer.buffer memory result352 = Leb128.encodeUnsignedLeb128FromUInt64(value352);\n\n        require(keccak256(result352.buf) == keccak256(expected352), \"'14744' is not returning '9873'\");\n\n        bytes memory expected353 = hex\"9d9302\";\n        uint64 value353 = 35229;\n\n        Buffer.buffer memory result353 = Leb128.encodeUnsignedLeb128FromUInt64(value353);\n\n        require(keccak256(result353.buf) == keccak256(expected353), \"'35229' is not returning '9d9302'\");\n\n        bytes memory expected354 = hex\"d0bf01\";\n        uint64 value354 = 24528;\n\n        Buffer.buffer memory result354 = Leb128.encodeUnsignedLeb128FromUInt64(value354);\n\n        require(keccak256(result354.buf) == keccak256(expected354), \"'24528' is not returning 'd0bf01'\");\n\n        bytes memory expected355 = hex\"988a03\";\n        uint64 value355 = 50456;\n\n        Buffer.buffer memory result355 = Leb128.encodeUnsignedLeb128FromUInt64(value355);\n\n        require(keccak256(result355.buf) == keccak256(expected355), \"'50456' is not returning '988a03'\");\n\n        bytes memory expected356 = hex\"a4b002\";\n        uint64 value356 = 38948;\n\n        Buffer.buffer memory result356 = Leb128.encodeUnsignedLeb128FromUInt64(value356);\n\n        require(keccak256(result356.buf) == keccak256(expected356), \"'38948' is not returning 'a4b002'\");\n\n        bytes memory expected357 = hex\"ddda02\";\n        uint64 value357 = 44381;\n\n        Buffer.buffer memory result357 = Leb128.encodeUnsignedLeb128FromUInt64(value357);\n\n        require(keccak256(result357.buf) == keccak256(expected357), \"'44381' is not returning 'ddda02'\");\n\n        bytes memory expected358 = hex\"feda02\";\n        uint64 value358 = 44414;\n\n        Buffer.buffer memory result358 = Leb128.encodeUnsignedLeb128FromUInt64(value358);\n\n        require(keccak256(result358.buf) == keccak256(expected358), \"'44414' is not returning 'feda02'\");\n\n        bytes memory expected359 = hex\"8aa203\";\n        uint64 value359 = 53514;\n\n        Buffer.buffer memory result359 = Leb128.encodeUnsignedLeb128FromUInt64(value359);\n\n        require(keccak256(result359.buf) == keccak256(expected359), \"'53514' is not returning '8aa203'\");\n\n        bytes memory expected360 = hex\"a5d001\";\n        uint64 value360 = 26661;\n\n        Buffer.buffer memory result360 = Leb128.encodeUnsignedLeb128FromUInt64(value360);\n\n        require(keccak256(result360.buf) == keccak256(expected360), \"'26661' is not returning 'a5d001'\");\n\n        bytes memory expected361 = hex\"9836\";\n        uint64 value361 = 6936;\n\n        Buffer.buffer memory result361 = Leb128.encodeUnsignedLeb128FromUInt64(value361);\n\n        require(keccak256(result361.buf) == keccak256(expected361), \"'6936' is not returning '9836'\");\n\n        bytes memory expected362 = hex\"b7f703\";\n        uint64 value362 = 64439;\n\n        Buffer.buffer memory result362 = Leb128.encodeUnsignedLeb128FromUInt64(value362);\n\n        require(keccak256(result362.buf) == keccak256(expected362), \"'64439' is not returning 'b7f703'\");\n\n        bytes memory expected363 = hex\"9032\";\n        uint64 value363 = 6416;\n\n        Buffer.buffer memory result363 = Leb128.encodeUnsignedLeb128FromUInt64(value363);\n\n        require(keccak256(result363.buf) == keccak256(expected363), \"'6416' is not returning '9032'\");\n\n        bytes memory expected364 = hex\"84fb03\";\n        uint64 value364 = 64900;\n\n        Buffer.buffer memory result364 = Leb128.encodeUnsignedLeb128FromUInt64(value364);\n\n        require(keccak256(result364.buf) == keccak256(expected364), \"'64900' is not returning '84fb03'\");\n\n        bytes memory expected365 = hex\"ed8001\";\n        uint64 value365 = 16493;\n\n        Buffer.buffer memory result365 = Leb128.encodeUnsignedLeb128FromUInt64(value365);\n\n        require(keccak256(result365.buf) == keccak256(expected365), \"'16493' is not returning 'ed8001'\");\n\n        bytes memory expected366 = hex\"96d903\";\n        uint64 value366 = 60566;\n\n        Buffer.buffer memory result366 = Leb128.encodeUnsignedLeb128FromUInt64(value366);\n\n        require(keccak256(result366.buf) == keccak256(expected366), \"'60566' is not returning '96d903'\");\n\n        bytes memory expected367 = hex\"b4d002\";\n        uint64 value367 = 43060;\n\n        Buffer.buffer memory result367 = Leb128.encodeUnsignedLeb128FromUInt64(value367);\n\n        require(keccak256(result367.buf) == keccak256(expected367), \"'43060' is not returning 'b4d002'\");\n\n        bytes memory expected368 = hex\"9fe802\";\n        uint64 value368 = 46111;\n\n        Buffer.buffer memory result368 = Leb128.encodeUnsignedLeb128FromUInt64(value368);\n\n        require(keccak256(result368.buf) == keccak256(expected368), \"'46111' is not returning '9fe802'\");\n\n        bytes memory expected369 = hex\"d559\";\n        uint64 value369 = 11477;\n\n        Buffer.buffer memory result369 = Leb128.encodeUnsignedLeb128FromUInt64(value369);\n\n        require(keccak256(result369.buf) == keccak256(expected369), \"'11477' is not returning 'd559'\");\n\n        bytes memory expected370 = hex\"ed19\";\n        uint64 value370 = 3309;\n\n        Buffer.buffer memory result370 = Leb128.encodeUnsignedLeb128FromUInt64(value370);\n\n        require(keccak256(result370.buf) == keccak256(expected370), \"'3309' is not returning 'ed19'\");\n\n        bytes memory expected371 = hex\"a1e202\";\n        uint64 value371 = 45345;\n\n        Buffer.buffer memory result371 = Leb128.encodeUnsignedLeb128FromUInt64(value371);\n\n        require(keccak256(result371.buf) == keccak256(expected371), \"'45345' is not returning 'a1e202'\");\n\n        bytes memory expected372 = hex\"dacd02\";\n        uint64 value372 = 42714;\n\n        Buffer.buffer memory result372 = Leb128.encodeUnsignedLeb128FromUInt64(value372);\n\n        require(keccak256(result372.buf) == keccak256(expected372), \"'42714' is not returning 'dacd02'\");\n\n        bytes memory expected373 = hex\"8e9e03\";\n        uint64 value373 = 53006;\n\n        Buffer.buffer memory result373 = Leb128.encodeUnsignedLeb128FromUInt64(value373);\n\n        require(keccak256(result373.buf) == keccak256(expected373), \"'53006' is not returning '8e9e03'\");\n\n        bytes memory expected374 = hex\"8520\";\n        uint64 value374 = 4101;\n\n        Buffer.buffer memory result374 = Leb128.encodeUnsignedLeb128FromUInt64(value374);\n\n        require(keccak256(result374.buf) == keccak256(expected374), \"'4101' is not returning '8520'\");\n\n        bytes memory expected375 = hex\"c5c001\";\n        uint64 value375 = 24645;\n\n        Buffer.buffer memory result375 = Leb128.encodeUnsignedLeb128FromUInt64(value375);\n\n        require(keccak256(result375.buf) == keccak256(expected375), \"'24645' is not returning 'c5c001'\");\n\n        bytes memory expected376 = hex\"db2c\";\n        uint64 value376 = 5723;\n\n        Buffer.buffer memory result376 = Leb128.encodeUnsignedLeb128FromUInt64(value376);\n\n        require(keccak256(result376.buf) == keccak256(expected376), \"'5723' is not returning 'db2c'\");\n\n        bytes memory expected377 = hex\"8df302\";\n        uint64 value377 = 47501;\n\n        Buffer.buffer memory result377 = Leb128.encodeUnsignedLeb128FromUInt64(value377);\n\n        require(keccak256(result377.buf) == keccak256(expected377), \"'47501' is not returning '8df302'\");\n\n        bytes memory expected378 = hex\"eabd03\";\n        uint64 value378 = 57066;\n\n        Buffer.buffer memory result378 = Leb128.encodeUnsignedLeb128FromUInt64(value378);\n\n        require(keccak256(result378.buf) == keccak256(expected378), \"'57066' is not returning 'eabd03'\");\n\n        bytes memory expected379 = hex\"898501\";\n        uint64 value379 = 17033;\n\n        Buffer.buffer memory result379 = Leb128.encodeUnsignedLeb128FromUInt64(value379);\n\n        require(keccak256(result379.buf) == keccak256(expected379), \"'17033' is not returning '898501'\");\n\n        bytes memory expected380 = hex\"ca31\";\n        uint64 value380 = 6346;\n\n        Buffer.buffer memory result380 = Leb128.encodeUnsignedLeb128FromUInt64(value380);\n\n        require(keccak256(result380.buf) == keccak256(expected380), \"'6346' is not returning 'ca31'\");\n\n        bytes memory expected381 = hex\"9862\";\n        uint64 value381 = 12568;\n\n        Buffer.buffer memory result381 = Leb128.encodeUnsignedLeb128FromUInt64(value381);\n\n        require(keccak256(result381.buf) == keccak256(expected381), \"'12568' is not returning '9862'\");\n\n        bytes memory expected382 = hex\"8fe603\";\n        uint64 value382 = 62223;\n\n        Buffer.buffer memory result382 = Leb128.encodeUnsignedLeb128FromUInt64(value382);\n\n        require(keccak256(result382.buf) == keccak256(expected382), \"'62223' is not returning '8fe603'\");\n\n        bytes memory expected383 = hex\"94b603\";\n        uint64 value383 = 56084;\n\n        Buffer.buffer memory result383 = Leb128.encodeUnsignedLeb128FromUInt64(value383);\n\n        require(keccak256(result383.buf) == keccak256(expected383), \"'56084' is not returning '94b603'\");\n\n        bytes memory expected384 = hex\"c3b603\";\n        uint64 value384 = 56131;\n\n        Buffer.buffer memory result384 = Leb128.encodeUnsignedLeb128FromUInt64(value384);\n\n        require(keccak256(result384.buf) == keccak256(expected384), \"'56131' is not returning 'c3b603'\");\n\n        bytes memory expected385 = hex\"91ea01\";\n        uint64 value385 = 29969;\n\n        Buffer.buffer memory result385 = Leb128.encodeUnsignedLeb128FromUInt64(value385);\n\n        require(keccak256(result385.buf) == keccak256(expected385), \"'29969' is not returning '91ea01'\");\n\n        bytes memory expected386 = hex\"f1fc01\";\n        uint64 value386 = 32369;\n\n        Buffer.buffer memory result386 = Leb128.encodeUnsignedLeb128FromUInt64(value386);\n\n        require(keccak256(result386.buf) == keccak256(expected386), \"'32369' is not returning 'f1fc01'\");\n\n        bytes memory expected387 = hex\"b7e003\";\n        uint64 value387 = 61495;\n\n        Buffer.buffer memory result387 = Leb128.encodeUnsignedLeb128FromUInt64(value387);\n\n        require(keccak256(result387.buf) == keccak256(expected387), \"'61495' is not returning 'b7e003'\");\n\n        bytes memory expected388 = hex\"95df02\";\n        uint64 value388 = 44949;\n\n        Buffer.buffer memory result388 = Leb128.encodeUnsignedLeb128FromUInt64(value388);\n\n        require(keccak256(result388.buf) == keccak256(expected388), \"'44949' is not returning '95df02'\");\n\n        bytes memory expected389 = hex\"d48603\";\n        uint64 value389 = 50004;\n\n        Buffer.buffer memory result389 = Leb128.encodeUnsignedLeb128FromUInt64(value389);\n\n        require(keccak256(result389.buf) == keccak256(expected389), \"'50004' is not returning 'd48603'\");\n\n        bytes memory expected390 = hex\"8448\";\n        uint64 value390 = 9220;\n\n        Buffer.buffer memory result390 = Leb128.encodeUnsignedLeb128FromUInt64(value390);\n\n        require(keccak256(result390.buf) == keccak256(expected390), \"'9220' is not returning '8448'\");\n\n        bytes memory expected391 = hex\"9050\";\n        uint64 value391 = 10256;\n\n        Buffer.buffer memory result391 = Leb128.encodeUnsignedLeb128FromUInt64(value391);\n\n        require(keccak256(result391.buf) == keccak256(expected391), \"'10256' is not returning '9050'\");\n\n        bytes memory expected392 = hex\"a4e502\";\n        uint64 value392 = 45732;\n\n        Buffer.buffer memory result392 = Leb128.encodeUnsignedLeb128FromUInt64(value392);\n\n        require(keccak256(result392.buf) == keccak256(expected392), \"'45732' is not returning 'a4e502'\");\n\n        bytes memory expected393 = hex\"a6d702\";\n        uint64 value393 = 43942;\n\n        Buffer.buffer memory result393 = Leb128.encodeUnsignedLeb128FromUInt64(value393);\n\n        require(keccak256(result393.buf) == keccak256(expected393), \"'43942' is not returning 'a6d702'\");\n\n        bytes memory expected394 = hex\"bd0b\";\n        uint64 value394 = 1469;\n\n        Buffer.buffer memory result394 = Leb128.encodeUnsignedLeb128FromUInt64(value394);\n\n        require(keccak256(result394.buf) == keccak256(expected394), \"'1469' is not returning 'bd0b'\");\n\n        bytes memory expected395 = hex\"b6e201\";\n        uint64 value395 = 28982;\n\n        Buffer.buffer memory result395 = Leb128.encodeUnsignedLeb128FromUInt64(value395);\n\n        require(keccak256(result395.buf) == keccak256(expected395), \"'28982' is not returning 'b6e201'\");\n\n        bytes memory expected396 = hex\"a103\";\n        uint64 value396 = 417;\n\n        Buffer.buffer memory result396 = Leb128.encodeUnsignedLeb128FromUInt64(value396);\n\n        require(keccak256(result396.buf) == keccak256(expected396), \"'417' is not returning 'a103'\");\n\n        bytes memory expected397 = hex\"d9c803\";\n        uint64 value397 = 58457;\n\n        Buffer.buffer memory result397 = Leb128.encodeUnsignedLeb128FromUInt64(value397);\n\n        require(keccak256(result397.buf) == keccak256(expected397), \"'58457' is not returning 'd9c803'\");\n\n        bytes memory expected398 = hex\"d5a502\";\n        uint64 value398 = 37589;\n\n        Buffer.buffer memory result398 = Leb128.encodeUnsignedLeb128FromUInt64(value398);\n\n        require(keccak256(result398.buf) == keccak256(expected398), \"'37589' is not returning 'd5a502'\");\n\n        bytes memory expected399 = hex\"c7e501\";\n        uint64 value399 = 29383;\n\n        Buffer.buffer memory result399 = Leb128.encodeUnsignedLeb128FromUInt64(value399);\n\n        require(keccak256(result399.buf) == keccak256(expected399), \"'29383' is not returning 'c7e501'\");\n\n        bytes memory expected400 = hex\"c0a401\";\n        uint64 value400 = 21056;\n\n        Buffer.buffer memory result400 = Leb128.encodeUnsignedLeb128FromUInt64(value400);\n\n        require(keccak256(result400.buf) == keccak256(expected400), \"'21056' is not returning 'c0a401'\");\n\n        bytes memory expected401 = hex\"8925\";\n        uint64 value401 = 4745;\n\n        Buffer.buffer memory result401 = Leb128.encodeUnsignedLeb128FromUInt64(value401);\n\n        require(keccak256(result401.buf) == keccak256(expected401), \"'4745' is not returning '8925'\");\n\n        bytes memory expected402 = hex\"ba9502\";\n        uint64 value402 = 35514;\n\n        Buffer.buffer memory result402 = Leb128.encodeUnsignedLeb128FromUInt64(value402);\n\n        require(keccak256(result402.buf) == keccak256(expected402), \"'35514' is not returning 'ba9502'\");\n\n        bytes memory expected403 = hex\"9ef103\";\n        uint64 value403 = 63646;\n\n        Buffer.buffer memory result403 = Leb128.encodeUnsignedLeb128FromUInt64(value403);\n\n        require(keccak256(result403.buf) == keccak256(expected403), \"'63646' is not returning '9ef103'\");\n\n        bytes memory expected404 = hex\"9a16\";\n        uint64 value404 = 2842;\n\n        Buffer.buffer memory result404 = Leb128.encodeUnsignedLeb128FromUInt64(value404);\n\n        require(keccak256(result404.buf) == keccak256(expected404), \"'2842' is not returning '9a16'\");\n\n        bytes memory expected405 = hex\"e2aa01\";\n        uint64 value405 = 21858;\n\n        Buffer.buffer memory result405 = Leb128.encodeUnsignedLeb128FromUInt64(value405);\n\n        require(keccak256(result405.buf) == keccak256(expected405), \"'21858' is not returning 'e2aa01'\");\n\n        bytes memory expected406 = hex\"c4bb02\";\n        uint64 value406 = 40388;\n\n        Buffer.buffer memory result406 = Leb128.encodeUnsignedLeb128FromUInt64(value406);\n\n        require(keccak256(result406.buf) == keccak256(expected406), \"'40388' is not returning 'c4bb02'\");\n\n        bytes memory expected407 = hex\"f8ec01\";\n        uint64 value407 = 30328;\n\n        Buffer.buffer memory result407 = Leb128.encodeUnsignedLeb128FromUInt64(value407);\n\n        require(keccak256(result407.buf) == keccak256(expected407), \"'30328' is not returning 'f8ec01'\");\n\n        bytes memory expected408 = hex\"8fb802\";\n        uint64 value408 = 39951;\n\n        Buffer.buffer memory result408 = Leb128.encodeUnsignedLeb128FromUInt64(value408);\n\n        require(keccak256(result408.buf) == keccak256(expected408), \"'39951' is not returning '8fb802'\");\n\n        bytes memory expected409 = hex\"bdbb01\";\n        uint64 value409 = 23997;\n\n        Buffer.buffer memory result409 = Leb128.encodeUnsignedLeb128FromUInt64(value409);\n\n        require(keccak256(result409.buf) == keccak256(expected409), \"'23997' is not returning 'bdbb01'\");\n\n        bytes memory expected410 = hex\"e2eb03\";\n        uint64 value410 = 62946;\n\n        Buffer.buffer memory result410 = Leb128.encodeUnsignedLeb128FromUInt64(value410);\n\n        require(keccak256(result410.buf) == keccak256(expected410), \"'62946' is not returning 'e2eb03'\");\n\n        bytes memory expected411 = hex\"c29602\";\n        uint64 value411 = 35650;\n\n        Buffer.buffer memory result411 = Leb128.encodeUnsignedLeb128FromUInt64(value411);\n\n        require(keccak256(result411.buf) == keccak256(expected411), \"'35650' is not returning 'c29602'\");\n\n        bytes memory expected412 = hex\"ae44\";\n        uint64 value412 = 8750;\n\n        Buffer.buffer memory result412 = Leb128.encodeUnsignedLeb128FromUInt64(value412);\n\n        require(keccak256(result412.buf) == keccak256(expected412), \"'8750' is not returning 'ae44'\");\n\n        bytes memory expected413 = hex\"81ea02\";\n        uint64 value413 = 46337;\n\n        Buffer.buffer memory result413 = Leb128.encodeUnsignedLeb128FromUInt64(value413);\n\n        require(keccak256(result413.buf) == keccak256(expected413), \"'46337' is not returning '81ea02'\");\n\n        bytes memory expected414 = hex\"81ae01\";\n        uint64 value414 = 22273;\n\n        Buffer.buffer memory result414 = Leb128.encodeUnsignedLeb128FromUInt64(value414);\n\n        require(keccak256(result414.buf) == keccak256(expected414), \"'22273' is not returning '81ae01'\");\n\n        bytes memory expected415 = hex\"8ca303\";\n        uint64 value415 = 53644;\n\n        Buffer.buffer memory result415 = Leb128.encodeUnsignedLeb128FromUInt64(value415);\n\n        require(keccak256(result415.buf) == keccak256(expected415), \"'53644' is not returning '8ca303'\");\n\n        bytes memory expected416 = hex\"c65b\";\n        uint64 value416 = 11718;\n\n        Buffer.buffer memory result416 = Leb128.encodeUnsignedLeb128FromUInt64(value416);\n\n        require(keccak256(result416.buf) == keccak256(expected416), \"'11718' is not returning 'c65b'\");\n\n        bytes memory expected417 = hex\"ea18\";\n        uint64 value417 = 3178;\n\n        Buffer.buffer memory result417 = Leb128.encodeUnsignedLeb128FromUInt64(value417);\n\n        require(keccak256(result417.buf) == keccak256(expected417), \"'3178' is not returning 'ea18'\");\n\n        bytes memory expected418 = hex\"8a8702\";\n        uint64 value418 = 33674;\n\n        Buffer.buffer memory result418 = Leb128.encodeUnsignedLeb128FromUInt64(value418);\n\n        require(keccak256(result418.buf) == keccak256(expected418), \"'33674' is not returning '8a8702'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated7.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated7Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected420 = hex\"8c12\";\n        uint64 value420 = 2316;\n\n        Buffer.buffer memory result420 = Leb128.encodeUnsignedLeb128FromUInt64(value420);\n\n        require(keccak256(result420.buf) == keccak256(expected420), \"'2316' is not returning '8c12'\");\n\n        bytes memory expected421 = hex\"d5cc03\";\n        uint64 value421 = 58965;\n\n        Buffer.buffer memory result421 = Leb128.encodeUnsignedLeb128FromUInt64(value421);\n\n        require(keccak256(result421.buf) == keccak256(expected421), \"'58965' is not returning 'd5cc03'\");\n\n        bytes memory expected422 = hex\"bf8302\";\n        uint64 value422 = 33215;\n\n        Buffer.buffer memory result422 = Leb128.encodeUnsignedLeb128FromUInt64(value422);\n\n        require(keccak256(result422.buf) == keccak256(expected422), \"'33215' is not returning 'bf8302'\");\n\n        bytes memory expected423 = hex\"8eb902\";\n        uint64 value423 = 40078;\n\n        Buffer.buffer memory result423 = Leb128.encodeUnsignedLeb128FromUInt64(value423);\n\n        require(keccak256(result423.buf) == keccak256(expected423), \"'40078' is not returning '8eb902'\");\n\n        bytes memory expected424 = hex\"a3d601\";\n        uint64 value424 = 27427;\n\n        Buffer.buffer memory result424 = Leb128.encodeUnsignedLeb128FromUInt64(value424);\n\n        require(keccak256(result424.buf) == keccak256(expected424), \"'27427' is not returning 'a3d601'\");\n\n        bytes memory expected425 = hex\"bd8102\";\n        uint64 value425 = 32957;\n\n        Buffer.buffer memory result425 = Leb128.encodeUnsignedLeb128FromUInt64(value425);\n\n        require(keccak256(result425.buf) == keccak256(expected425), \"'32957' is not returning 'bd8102'\");\n\n        bytes memory expected426 = hex\"fc8001\";\n        uint64 value426 = 16508;\n\n        Buffer.buffer memory result426 = Leb128.encodeUnsignedLeb128FromUInt64(value426);\n\n        require(keccak256(result426.buf) == keccak256(expected426), \"'16508' is not returning 'fc8001'\");\n\n        bytes memory expected427 = hex\"b2b302\";\n        uint64 value427 = 39346;\n\n        Buffer.buffer memory result427 = Leb128.encodeUnsignedLeb128FromUInt64(value427);\n\n        require(keccak256(result427.buf) == keccak256(expected427), \"'39346' is not returning 'b2b302'\");\n\n        bytes memory expected428 = hex\"9fe401\";\n        uint64 value428 = 29215;\n\n        Buffer.buffer memory result428 = Leb128.encodeUnsignedLeb128FromUInt64(value428);\n\n        require(keccak256(result428.buf) == keccak256(expected428), \"'29215' is not returning '9fe401'\");\n\n        bytes memory expected429 = hex\"c426\";\n        uint64 value429 = 4932;\n\n        Buffer.buffer memory result429 = Leb128.encodeUnsignedLeb128FromUInt64(value429);\n\n        require(keccak256(result429.buf) == keccak256(expected429), \"'4932' is not returning 'c426'\");\n\n        bytes memory expected430 = hex\"b7ca03\";\n        uint64 value430 = 58679;\n\n        Buffer.buffer memory result430 = Leb128.encodeUnsignedLeb128FromUInt64(value430);\n\n        require(keccak256(result430.buf) == keccak256(expected430), \"'58679' is not returning 'b7ca03'\");\n\n        bytes memory expected431 = hex\"cbf503\";\n        uint64 value431 = 64203;\n\n        Buffer.buffer memory result431 = Leb128.encodeUnsignedLeb128FromUInt64(value431);\n\n        require(keccak256(result431.buf) == keccak256(expected431), \"'64203' is not returning 'cbf503'\");\n\n        bytes memory expected432 = hex\"80f001\";\n        uint64 value432 = 30720;\n\n        Buffer.buffer memory result432 = Leb128.encodeUnsignedLeb128FromUInt64(value432);\n\n        require(keccak256(result432.buf) == keccak256(expected432), \"'30720' is not returning '80f001'\");\n\n        bytes memory expected433 = hex\"b3af03\";\n        uint64 value433 = 55219;\n\n        Buffer.buffer memory result433 = Leb128.encodeUnsignedLeb128FromUInt64(value433);\n\n        require(keccak256(result433.buf) == keccak256(expected433), \"'55219' is not returning 'b3af03'\");\n\n        bytes memory expected434 = hex\"e265\";\n        uint64 value434 = 13026;\n\n        Buffer.buffer memory result434 = Leb128.encodeUnsignedLeb128FromUInt64(value434);\n\n        require(keccak256(result434.buf) == keccak256(expected434), \"'13026' is not returning 'e265'\");\n\n        bytes memory expected435 = hex\"e69301\";\n        uint64 value435 = 18918;\n\n        Buffer.buffer memory result435 = Leb128.encodeUnsignedLeb128FromUInt64(value435);\n\n        require(keccak256(result435.buf) == keccak256(expected435), \"'18918' is not returning 'e69301'\");\n\n        bytes memory expected436 = hex\"99af03\";\n        uint64 value436 = 55193;\n\n        Buffer.buffer memory result436 = Leb128.encodeUnsignedLeb128FromUInt64(value436);\n\n        require(keccak256(result436.buf) == keccak256(expected436), \"'55193' is not returning '99af03'\");\n\n        bytes memory expected437 = hex\"aba803\";\n        uint64 value437 = 54315;\n\n        Buffer.buffer memory result437 = Leb128.encodeUnsignedLeb128FromUInt64(value437);\n\n        require(keccak256(result437.buf) == keccak256(expected437), \"'54315' is not returning 'aba803'\");\n\n        bytes memory expected438 = hex\"9db602\";\n        uint64 value438 = 39709;\n\n        Buffer.buffer memory result438 = Leb128.encodeUnsignedLeb128FromUInt64(value438);\n\n        require(keccak256(result438.buf) == keccak256(expected438), \"'39709' is not returning '9db602'\");\n\n        bytes memory expected439 = hex\"9559\";\n        uint64 value439 = 11413;\n\n        Buffer.buffer memory result439 = Leb128.encodeUnsignedLeb128FromUInt64(value439);\n\n        require(keccak256(result439.buf) == keccak256(expected439), \"'11413' is not returning '9559'\");\n\n        bytes memory expected440 = hex\"c43a\";\n        uint64 value440 = 7492;\n\n        Buffer.buffer memory result440 = Leb128.encodeUnsignedLeb128FromUInt64(value440);\n\n        require(keccak256(result440.buf) == keccak256(expected440), \"'7492' is not returning 'c43a'\");\n\n        bytes memory expected441 = hex\"a3f901\";\n        uint64 value441 = 31907;\n\n        Buffer.buffer memory result441 = Leb128.encodeUnsignedLeb128FromUInt64(value441);\n\n        require(keccak256(result441.buf) == keccak256(expected441), \"'31907' is not returning 'a3f901'\");\n\n        bytes memory expected442 = hex\"f139\";\n        uint64 value442 = 7409;\n\n        Buffer.buffer memory result442 = Leb128.encodeUnsignedLeb128FromUInt64(value442);\n\n        require(keccak256(result442.buf) == keccak256(expected442), \"'7409' is not returning 'f139'\");\n\n        bytes memory expected443 = hex\"8e8802\";\n        uint64 value443 = 33806;\n\n        Buffer.buffer memory result443 = Leb128.encodeUnsignedLeb128FromUInt64(value443);\n\n        require(keccak256(result443.buf) == keccak256(expected443), \"'33806' is not returning '8e8802'\");\n\n        bytes memory expected444 = hex\"c469\";\n        uint64 value444 = 13508;\n\n        Buffer.buffer memory result444 = Leb128.encodeUnsignedLeb128FromUInt64(value444);\n\n        require(keccak256(result444.buf) == keccak256(expected444), \"'13508' is not returning 'c469'\");\n\n        bytes memory expected445 = hex\"83b903\";\n        uint64 value445 = 56451;\n\n        Buffer.buffer memory result445 = Leb128.encodeUnsignedLeb128FromUInt64(value445);\n\n        require(keccak256(result445.buf) == keccak256(expected445), \"'56451' is not returning '83b903'\");\n\n        bytes memory expected446 = hex\"9c9402\";\n        uint64 value446 = 35356;\n\n        Buffer.buffer memory result446 = Leb128.encodeUnsignedLeb128FromUInt64(value446);\n\n        require(keccak256(result446.buf) == keccak256(expected446), \"'35356' is not returning '9c9402'\");\n\n        bytes memory expected447 = hex\"d0b003\";\n        uint64 value447 = 55376;\n\n        Buffer.buffer memory result447 = Leb128.encodeUnsignedLeb128FromUInt64(value447);\n\n        require(keccak256(result447.buf) == keccak256(expected447), \"'55376' is not returning 'd0b003'\");\n\n        bytes memory expected448 = hex\"968b01\";\n        uint64 value448 = 17814;\n\n        Buffer.buffer memory result448 = Leb128.encodeUnsignedLeb128FromUInt64(value448);\n\n        require(keccak256(result448.buf) == keccak256(expected448), \"'17814' is not returning '968b01'\");\n\n        bytes memory expected449 = hex\"85f803\";\n        uint64 value449 = 64517;\n\n        Buffer.buffer memory result449 = Leb128.encodeUnsignedLeb128FromUInt64(value449);\n\n        require(keccak256(result449.buf) == keccak256(expected449), \"'64517' is not returning '85f803'\");\n\n        bytes memory expected450 = hex\"b217\";\n        uint64 value450 = 2994;\n\n        Buffer.buffer memory result450 = Leb128.encodeUnsignedLeb128FromUInt64(value450);\n\n        require(keccak256(result450.buf) == keccak256(expected450), \"'2994' is not returning 'b217'\");\n\n        bytes memory expected451 = hex\"a1ce03\";\n        uint64 value451 = 59169;\n\n        Buffer.buffer memory result451 = Leb128.encodeUnsignedLeb128FromUInt64(value451);\n\n        require(keccak256(result451.buf) == keccak256(expected451), \"'59169' is not returning 'a1ce03'\");\n\n        bytes memory expected452 = hex\"8fb703\";\n        uint64 value452 = 56207;\n\n        Buffer.buffer memory result452 = Leb128.encodeUnsignedLeb128FromUInt64(value452);\n\n        require(keccak256(result452.buf) == keccak256(expected452), \"'56207' is not returning '8fb703'\");\n\n        bytes memory expected453 = hex\"83ad01\";\n        uint64 value453 = 22147;\n\n        Buffer.buffer memory result453 = Leb128.encodeUnsignedLeb128FromUInt64(value453);\n\n        require(keccak256(result453.buf) == keccak256(expected453), \"'22147' is not returning '83ad01'\");\n\n        bytes memory expected454 = hex\"bc6d\";\n        uint64 value454 = 14012;\n\n        Buffer.buffer memory result454 = Leb128.encodeUnsignedLeb128FromUInt64(value454);\n\n        require(keccak256(result454.buf) == keccak256(expected454), \"'14012' is not returning 'bc6d'\");\n\n        bytes memory expected455 = hex\"fe65\";\n        uint64 value455 = 13054;\n\n        Buffer.buffer memory result455 = Leb128.encodeUnsignedLeb128FromUInt64(value455);\n\n        require(keccak256(result455.buf) == keccak256(expected455), \"'13054' is not returning 'fe65'\");\n\n        bytes memory expected456 = hex\"9c26\";\n        uint64 value456 = 4892;\n\n        Buffer.buffer memory result456 = Leb128.encodeUnsignedLeb128FromUInt64(value456);\n\n        require(keccak256(result456.buf) == keccak256(expected456), \"'4892' is not returning '9c26'\");\n\n        bytes memory expected457 = hex\"83cb02\";\n        uint64 value457 = 42371;\n\n        Buffer.buffer memory result457 = Leb128.encodeUnsignedLeb128FromUInt64(value457);\n\n        require(keccak256(result457.buf) == keccak256(expected457), \"'42371' is not returning '83cb02'\");\n\n        bytes memory expected458 = hex\"8541\";\n        uint64 value458 = 8325;\n\n        Buffer.buffer memory result458 = Leb128.encodeUnsignedLeb128FromUInt64(value458);\n\n        require(keccak256(result458.buf) == keccak256(expected458), \"'8325' is not returning '8541'\");\n\n        bytes memory expected459 = hex\"a9a603\";\n        uint64 value459 = 54057;\n\n        Buffer.buffer memory result459 = Leb128.encodeUnsignedLeb128FromUInt64(value459);\n\n        require(keccak256(result459.buf) == keccak256(expected459), \"'54057' is not returning 'a9a603'\");\n\n        bytes memory expected460 = hex\"c2e202\";\n        uint64 value460 = 45378;\n\n        Buffer.buffer memory result460 = Leb128.encodeUnsignedLeb128FromUInt64(value460);\n\n        require(keccak256(result460.buf) == keccak256(expected460), \"'45378' is not returning 'c2e202'\");\n\n        bytes memory expected461 = hex\"a4d202\";\n        uint64 value461 = 43300;\n\n        Buffer.buffer memory result461 = Leb128.encodeUnsignedLeb128FromUInt64(value461);\n\n        require(keccak256(result461.buf) == keccak256(expected461), \"'43300' is not returning 'a4d202'\");\n\n        bytes memory expected462 = hex\"cbff01\";\n        uint64 value462 = 32715;\n\n        Buffer.buffer memory result462 = Leb128.encodeUnsignedLeb128FromUInt64(value462);\n\n        require(keccak256(result462.buf) == keccak256(expected462), \"'32715' is not returning 'cbff01'\");\n\n        bytes memory expected463 = hex\"bfb702\";\n        uint64 value463 = 39871;\n\n        Buffer.buffer memory result463 = Leb128.encodeUnsignedLeb128FromUInt64(value463);\n\n        require(keccak256(result463.buf) == keccak256(expected463), \"'39871' is not returning 'bfb702'\");\n\n        bytes memory expected464 = hex\"c4b103\";\n        uint64 value464 = 55492;\n\n        Buffer.buffer memory result464 = Leb128.encodeUnsignedLeb128FromUInt64(value464);\n\n        require(keccak256(result464.buf) == keccak256(expected464), \"'55492' is not returning 'c4b103'\");\n\n        bytes memory expected465 = hex\"b8ca03\";\n        uint64 value465 = 58680;\n\n        Buffer.buffer memory result465 = Leb128.encodeUnsignedLeb128FromUInt64(value465);\n\n        require(keccak256(result465.buf) == keccak256(expected465), \"'58680' is not returning 'b8ca03'\");\n\n        bytes memory expected466 = hex\"cf8402\";\n        uint64 value466 = 33359;\n\n        Buffer.buffer memory result466 = Leb128.encodeUnsignedLeb128FromUInt64(value466);\n\n        require(keccak256(result466.buf) == keccak256(expected466), \"'33359' is not returning 'cf8402'\");\n\n        bytes memory expected467 = hex\"fa8902\";\n        uint64 value467 = 34042;\n\n        Buffer.buffer memory result467 = Leb128.encodeUnsignedLeb128FromUInt64(value467);\n\n        require(keccak256(result467.buf) == keccak256(expected467), \"'34042' is not returning 'fa8902'\");\n\n        bytes memory expected468 = hex\"928902\";\n        uint64 value468 = 33938;\n\n        Buffer.buffer memory result468 = Leb128.encodeUnsignedLeb128FromUInt64(value468);\n\n        require(keccak256(result468.buf) == keccak256(expected468), \"'33938' is not returning '928902'\");\n\n        bytes memory expected469 = hex\"cd15\";\n        uint64 value469 = 2765;\n\n        Buffer.buffer memory result469 = Leb128.encodeUnsignedLeb128FromUInt64(value469);\n\n        require(keccak256(result469.buf) == keccak256(expected469), \"'2765' is not returning 'cd15'\");\n\n        bytes memory expected470 = hex\"e29a01\";\n        uint64 value470 = 19810;\n\n        Buffer.buffer memory result470 = Leb128.encodeUnsignedLeb128FromUInt64(value470);\n\n        require(keccak256(result470.buf) == keccak256(expected470), \"'19810' is not returning 'e29a01'\");\n\n        bytes memory expected471 = hex\"b507\";\n        uint64 value471 = 949;\n\n        Buffer.buffer memory result471 = Leb128.encodeUnsignedLeb128FromUInt64(value471);\n\n        require(keccak256(result471.buf) == keccak256(expected471), \"'949' is not returning 'b507'\");\n\n        bytes memory expected472 = hex\"b2e003\";\n        uint64 value472 = 61490;\n\n        Buffer.buffer memory result472 = Leb128.encodeUnsignedLeb128FromUInt64(value472);\n\n        require(keccak256(result472.buf) == keccak256(expected472), \"'61490' is not returning 'b2e003'\");\n\n        bytes memory expected473 = hex\"adbf03\";\n        uint64 value473 = 57261;\n\n        Buffer.buffer memory result473 = Leb128.encodeUnsignedLeb128FromUInt64(value473);\n\n        require(keccak256(result473.buf) == keccak256(expected473), \"'57261' is not returning 'adbf03'\");\n\n        bytes memory expected474 = hex\"f3ef03\";\n        uint64 value474 = 63475;\n\n        Buffer.buffer memory result474 = Leb128.encodeUnsignedLeb128FromUInt64(value474);\n\n        require(keccak256(result474.buf) == keccak256(expected474), \"'63475' is not returning 'f3ef03'\");\n\n        bytes memory expected475 = hex\"a7a601\";\n        uint64 value475 = 21287;\n\n        Buffer.buffer memory result475 = Leb128.encodeUnsignedLeb128FromUInt64(value475);\n\n        require(keccak256(result475.buf) == keccak256(expected475), \"'21287' is not returning 'a7a601'\");\n\n        bytes memory expected476 = hex\"aef402\";\n        uint64 value476 = 47662;\n\n        Buffer.buffer memory result476 = Leb128.encodeUnsignedLeb128FromUInt64(value476);\n\n        require(keccak256(result476.buf) == keccak256(expected476), \"'47662' is not returning 'aef402'\");\n\n        bytes memory expected477 = hex\"a2b603\";\n        uint64 value477 = 56098;\n\n        Buffer.buffer memory result477 = Leb128.encodeUnsignedLeb128FromUInt64(value477);\n\n        require(keccak256(result477.buf) == keccak256(expected477), \"'56098' is not returning 'a2b603'\");\n\n        bytes memory expected478 = hex\"d6a703\";\n        uint64 value478 = 54230;\n\n        Buffer.buffer memory result478 = Leb128.encodeUnsignedLeb128FromUInt64(value478);\n\n        require(keccak256(result478.buf) == keccak256(expected478), \"'54230' is not returning 'd6a703'\");\n\n        bytes memory expected479 = hex\"edb102\";\n        uint64 value479 = 39149;\n\n        Buffer.buffer memory result479 = Leb128.encodeUnsignedLeb128FromUInt64(value479);\n\n        require(keccak256(result479.buf) == keccak256(expected479), \"'39149' is not returning 'edb102'\");\n\n        bytes memory expected480 = hex\"ace002\";\n        uint64 value480 = 45100;\n\n        Buffer.buffer memory result480 = Leb128.encodeUnsignedLeb128FromUInt64(value480);\n\n        require(keccak256(result480.buf) == keccak256(expected480), \"'45100' is not returning 'ace002'\");\n\n        bytes memory expected481 = hex\"c6dc03\";\n        uint64 value481 = 60998;\n\n        Buffer.buffer memory result481 = Leb128.encodeUnsignedLeb128FromUInt64(value481);\n\n        require(keccak256(result481.buf) == keccak256(expected481), \"'60998' is not returning 'c6dc03'\");\n\n        bytes memory expected482 = hex\"a1f901\";\n        uint64 value482 = 31905;\n\n        Buffer.buffer memory result482 = Leb128.encodeUnsignedLeb128FromUInt64(value482);\n\n        require(keccak256(result482.buf) == keccak256(expected482), \"'31905' is not returning 'a1f901'\");\n\n        bytes memory expected483 = hex\"94b201\";\n        uint64 value483 = 22804;\n\n        Buffer.buffer memory result483 = Leb128.encodeUnsignedLeb128FromUInt64(value483);\n\n        require(keccak256(result483.buf) == keccak256(expected483), \"'22804' is not returning '94b201'\");\n\n        bytes memory expected484 = hex\"dedb02\";\n        uint64 value484 = 44510;\n\n        Buffer.buffer memory result484 = Leb128.encodeUnsignedLeb128FromUInt64(value484);\n\n        require(keccak256(result484.buf) == keccak256(expected484), \"'44510' is not returning 'dedb02'\");\n\n        bytes memory expected485 = hex\"9077\";\n        uint64 value485 = 15248;\n\n        Buffer.buffer memory result485 = Leb128.encodeUnsignedLeb128FromUInt64(value485);\n\n        require(keccak256(result485.buf) == keccak256(expected485), \"'15248' is not returning '9077'\");\n\n        bytes memory expected486 = hex\"f972\";\n        uint64 value486 = 14713;\n\n        Buffer.buffer memory result486 = Leb128.encodeUnsignedLeb128FromUInt64(value486);\n\n        require(keccak256(result486.buf) == keccak256(expected486), \"'14713' is not returning 'f972'\");\n\n        bytes memory expected487 = hex\"b1c703\";\n        uint64 value487 = 58289;\n\n        Buffer.buffer memory result487 = Leb128.encodeUnsignedLeb128FromUInt64(value487);\n\n        require(keccak256(result487.buf) == keccak256(expected487), \"'58289' is not returning 'b1c703'\");\n\n        bytes memory expected488 = hex\"8943\";\n        uint64 value488 = 8585;\n\n        Buffer.buffer memory result488 = Leb128.encodeUnsignedLeb128FromUInt64(value488);\n\n        require(keccak256(result488.buf) == keccak256(expected488), \"'8585' is not returning '8943'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated8.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated8Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected490 = hex\"cc8e02\";\n        uint64 value490 = 34636;\n\n        Buffer.buffer memory result490 = Leb128.encodeUnsignedLeb128FromUInt64(value490);\n\n        require(keccak256(result490.buf) == keccak256(expected490), \"'34636' is not returning 'cc8e02'\");\n\n        bytes memory expected491 = hex\"c28f01\";\n        uint64 value491 = 18370;\n\n        Buffer.buffer memory result491 = Leb128.encodeUnsignedLeb128FromUInt64(value491);\n\n        require(keccak256(result491.buf) == keccak256(expected491), \"'18370' is not returning 'c28f01'\");\n\n        bytes memory expected492 = hex\"def201\";\n        uint64 value492 = 31070;\n\n        Buffer.buffer memory result492 = Leb128.encodeUnsignedLeb128FromUInt64(value492);\n\n        require(keccak256(result492.buf) == keccak256(expected492), \"'31070' is not returning 'def201'\");\n\n        bytes memory expected493 = hex\"d58702\";\n        uint64 value493 = 33749;\n\n        Buffer.buffer memory result493 = Leb128.encodeUnsignedLeb128FromUInt64(value493);\n\n        require(keccak256(result493.buf) == keccak256(expected493), \"'33749' is not returning 'd58702'\");\n\n        bytes memory expected494 = hex\"b9f302\";\n        uint64 value494 = 47545;\n\n        Buffer.buffer memory result494 = Leb128.encodeUnsignedLeb128FromUInt64(value494);\n\n        require(keccak256(result494.buf) == keccak256(expected494), \"'47545' is not returning 'b9f302'\");\n\n        bytes memory expected495 = hex\"b317\";\n        uint64 value495 = 2995;\n\n        Buffer.buffer memory result495 = Leb128.encodeUnsignedLeb128FromUInt64(value495);\n\n        require(keccak256(result495.buf) == keccak256(expected495), \"'2995' is not returning 'b317'\");\n\n        bytes memory expected496 = hex\"f49502\";\n        uint64 value496 = 35572;\n\n        Buffer.buffer memory result496 = Leb128.encodeUnsignedLeb128FromUInt64(value496);\n\n        require(keccak256(result496.buf) == keccak256(expected496), \"'35572' is not returning 'f49502'\");\n\n        bytes memory expected497 = hex\"a2b703\";\n        uint64 value497 = 56226;\n\n        Buffer.buffer memory result497 = Leb128.encodeUnsignedLeb128FromUInt64(value497);\n\n        require(keccak256(result497.buf) == keccak256(expected497), \"'56226' is not returning 'a2b703'\");\n\n        bytes memory expected498 = hex\"c8a102\";\n        uint64 value498 = 37064;\n\n        Buffer.buffer memory result498 = Leb128.encodeUnsignedLeb128FromUInt64(value498);\n\n        require(keccak256(result498.buf) == keccak256(expected498), \"'37064' is not returning 'c8a102'\");\n\n        bytes memory expected499 = hex\"f2ff03\";\n        uint64 value499 = 65522;\n\n        Buffer.buffer memory result499 = Leb128.encodeUnsignedLeb128FromUInt64(value499);\n\n        require(keccak256(result499.buf) == keccak256(expected499), \"'65522' is not returning 'f2ff03'\");\n\n        bytes memory expected500 = hex\"808002\";\n        uint64 value500 = 32768;\n\n        Buffer.buffer memory result500 = Leb128.encodeUnsignedLeb128FromUInt64(value500);\n\n        require(keccak256(result500.buf) == keccak256(expected500), \"'32768' is not returning '808002'\");\n\n        bytes memory expected501 = hex\"eec301\";\n        uint64 value501 = 25070;\n\n        Buffer.buffer memory result501 = Leb128.encodeUnsignedLeb128FromUInt64(value501);\n\n        require(keccak256(result501.buf) == keccak256(expected501), \"'25070' is not returning 'eec301'\");\n\n        bytes memory expected502 = hex\"a29d01\";\n        uint64 value502 = 20130;\n\n        Buffer.buffer memory result502 = Leb128.encodeUnsignedLeb128FromUInt64(value502);\n\n        require(keccak256(result502.buf) == keccak256(expected502), \"'20130' is not returning 'a29d01'\");\n\n        bytes memory expected503 = hex\"96f603\";\n        uint64 value503 = 64278;\n\n        Buffer.buffer memory result503 = Leb128.encodeUnsignedLeb128FromUInt64(value503);\n\n        require(keccak256(result503.buf) == keccak256(expected503), \"'64278' is not returning '96f603'\");\n\n        bytes memory expected504 = hex\"faa402\";\n        uint64 value504 = 37498;\n\n        Buffer.buffer memory result504 = Leb128.encodeUnsignedLeb128FromUInt64(value504);\n\n        require(keccak256(result504.buf) == keccak256(expected504), \"'37498' is not returning 'faa402'\");\n\n        bytes memory expected505 = hex\"cebe02\";\n        uint64 value505 = 40782;\n\n        Buffer.buffer memory result505 = Leb128.encodeUnsignedLeb128FromUInt64(value505);\n\n        require(keccak256(result505.buf) == keccak256(expected505), \"'40782' is not returning 'cebe02'\");\n\n        bytes memory expected506 = hex\"81d203\";\n        uint64 value506 = 59649;\n\n        Buffer.buffer memory result506 = Leb128.encodeUnsignedLeb128FromUInt64(value506);\n\n        require(keccak256(result506.buf) == keccak256(expected506), \"'59649' is not returning '81d203'\");\n\n        bytes memory expected507 = hex\"e7d503\";\n        uint64 value507 = 60135;\n\n        Buffer.buffer memory result507 = Leb128.encodeUnsignedLeb128FromUInt64(value507);\n\n        require(keccak256(result507.buf) == keccak256(expected507), \"'60135' is not returning 'e7d503'\");\n\n        bytes memory expected508 = hex\"d224\";\n        uint64 value508 = 4690;\n\n        Buffer.buffer memory result508 = Leb128.encodeUnsignedLeb128FromUInt64(value508);\n\n        require(keccak256(result508.buf) == keccak256(expected508), \"'4690' is not returning 'd224'\");\n\n        bytes memory expected509 = hex\"a01f\";\n        uint64 value509 = 4000;\n\n        Buffer.buffer memory result509 = Leb128.encodeUnsignedLeb128FromUInt64(value509);\n\n        require(keccak256(result509.buf) == keccak256(expected509), \"'4000' is not returning 'a01f'\");\n\n        bytes memory expected510 = hex\"d7ab03\";\n        uint64 value510 = 54743;\n\n        Buffer.buffer memory result510 = Leb128.encodeUnsignedLeb128FromUInt64(value510);\n\n        require(keccak256(result510.buf) == keccak256(expected510), \"'54743' is not returning 'd7ab03'\");\n\n        bytes memory expected511 = hex\"878702\";\n        uint64 value511 = 33671;\n\n        Buffer.buffer memory result511 = Leb128.encodeUnsignedLeb128FromUInt64(value511);\n\n        require(keccak256(result511.buf) == keccak256(expected511), \"'33671' is not returning '878702'\");\n\n        bytes memory expected512 = hex\"fbb2e5ef05\";\n        uint64 value512 = 1576622459;\n\n        Buffer.buffer memory result512 = Leb128.encodeUnsignedLeb128FromUInt64(value512);\n\n        require(keccak256(result512.buf) == keccak256(expected512), \"'1576622459' is not returning 'fbb2e5ef05'\");\n\n        bytes memory expected513 = hex\"c8b5d9c108\";\n        uint64 value513 = 2285263560;\n\n        Buffer.buffer memory result513 = Leb128.encodeUnsignedLeb128FromUInt64(value513);\n\n        require(keccak256(result513.buf) == keccak256(expected513), \"'2285263560' is not returning 'c8b5d9c108'\");\n\n        bytes memory expected514 = hex\"dddccf7d\";\n        uint64 value514 = 263450205;\n\n        Buffer.buffer memory result514 = Leb128.encodeUnsignedLeb128FromUInt64(value514);\n\n        require(keccak256(result514.buf) == keccak256(expected514), \"'263450205' is not returning 'dddccf7d'\");\n\n        bytes memory expected515 = hex\"8aadd8e709\";\n        uint64 value515 = 2633373322;\n\n        Buffer.buffer memory result515 = Leb128.encodeUnsignedLeb128FromUInt64(value515);\n\n        require(keccak256(result515.buf) == keccak256(expected515), \"'2633373322' is not returning '8aadd8e709'\");\n\n        bytes memory expected516 = hex\"cd8998e502\";\n        uint64 value516 = 749077709;\n\n        Buffer.buffer memory result516 = Leb128.encodeUnsignedLeb128FromUInt64(value516);\n\n        require(keccak256(result516.buf) == keccak256(expected516), \"'749077709' is not returning 'cd8998e502'\");\n\n        bytes memory expected517 = hex\"fd85818403\";\n        uint64 value517 = 813712125;\n\n        Buffer.buffer memory result517 = Leb128.encodeUnsignedLeb128FromUInt64(value517);\n\n        require(keccak256(result517.buf) == keccak256(expected517), \"'813712125' is not returning 'fd85818403'\");\n\n        bytes memory expected518 = hex\"b7a099970a\";\n        uint64 value518 = 2733002807;\n\n        Buffer.buffer memory result518 = Leb128.encodeUnsignedLeb128FromUInt64(value518);\n\n        require(keccak256(result518.buf) == keccak256(expected518), \"'2733002807' is not returning 'b7a099970a'\");\n\n        bytes memory expected519 = hex\"e4e6eac608\";\n        uint64 value519 = 2296034148;\n\n        Buffer.buffer memory result519 = Leb128.encodeUnsignedLeb128FromUInt64(value519);\n\n        require(keccak256(result519.buf) == keccak256(expected519), \"'2296034148' is not returning 'e4e6eac608'\");\n\n        bytes memory expected520 = hex\"c2ffd1cd0f\";\n        uint64 value520 = 4189355970;\n\n        Buffer.buffer memory result520 = Leb128.encodeUnsignedLeb128FromUInt64(value520);\n\n        require(keccak256(result520.buf) == keccak256(expected520), \"'4189355970' is not returning 'c2ffd1cd0f'\");\n\n        bytes memory expected521 = hex\"80bbb09b08\";\n        uint64 value521 = 2204900736;\n\n        Buffer.buffer memory result521 = Leb128.encodeUnsignedLeb128FromUInt64(value521);\n\n        require(keccak256(result521.buf) == keccak256(expected521), \"'2204900736' is not returning '80bbb09b08'\");\n\n        bytes memory expected522 = hex\"eaffeff201\";\n        uint64 value522 = 509345770;\n\n        Buffer.buffer memory result522 = Leb128.encodeUnsignedLeb128FromUInt64(value522);\n\n        require(keccak256(result522.buf) == keccak256(expected522), \"'509345770' is not returning 'eaffeff201'\");\n\n        bytes memory expected523 = hex\"eba7a0bc0e\";\n        uint64 value523 = 3884454891;\n\n        Buffer.buffer memory result523 = Leb128.encodeUnsignedLeb128FromUInt64(value523);\n\n        require(keccak256(result523.buf) == keccak256(expected523), \"'3884454891' is not returning 'eba7a0bc0e'\");\n\n        bytes memory expected524 = hex\"89cb80970d\";\n        uint64 value524 = 3537905033;\n\n        Buffer.buffer memory result524 = Leb128.encodeUnsignedLeb128FromUInt64(value524);\n\n        require(keccak256(result524.buf) == keccak256(expected524), \"'3537905033' is not returning '89cb80970d'\");\n\n        bytes memory expected525 = hex\"cecbf8c90a\";\n        uint64 value525 = 2839422414;\n\n        Buffer.buffer memory result525 = Leb128.encodeUnsignedLeb128FromUInt64(value525);\n\n        require(keccak256(result525.buf) == keccak256(expected525), \"'2839422414' is not returning 'cecbf8c90a'\");\n\n        bytes memory expected526 = hex\"f6eaed8509\";\n        uint64 value526 = 2428204406;\n\n        Buffer.buffer memory result526 = Leb128.encodeUnsignedLeb128FromUInt64(value526);\n\n        require(keccak256(result526.buf) == keccak256(expected526), \"'2428204406' is not returning 'f6eaed8509'\");\n\n        bytes memory expected527 = hex\"bd99f3f10d\";\n        uint64 value527 = 3728526525;\n\n        Buffer.buffer memory result527 = Leb128.encodeUnsignedLeb128FromUInt64(value527);\n\n        require(keccak256(result527.buf) == keccak256(expected527), \"'3728526525' is not returning 'bd99f3f10d'\");\n\n        bytes memory expected528 = hex\"82b894ae0b\";\n        uint64 value528 = 3049593858;\n\n        Buffer.buffer memory result528 = Leb128.encodeUnsignedLeb128FromUInt64(value528);\n\n        require(keccak256(result528.buf) == keccak256(expected528), \"'3049593858' is not returning '82b894ae0b'\");\n\n        bytes memory expected529 = hex\"e9b981b705\";\n        uint64 value529 = 1457544425;\n\n        Buffer.buffer memory result529 = Leb128.encodeUnsignedLeb128FromUInt64(value529);\n\n        require(keccak256(result529.buf) == keccak256(expected529), \"'1457544425' is not returning 'e9b981b705'\");\n\n        bytes memory expected530 = hex\"8587c9bc05\";\n        uint64 value530 = 1469203333;\n\n        Buffer.buffer memory result530 = Leb128.encodeUnsignedLeb128FromUInt64(value530);\n\n        require(keccak256(result530.buf) == keccak256(expected530), \"'1469203333' is not returning '8587c9bc05'\");\n\n        bytes memory expected531 = hex\"98f2e9870e\";\n        uint64 value531 = 3774511384;\n\n        Buffer.buffer memory result531 = Leb128.encodeUnsignedLeb128FromUInt64(value531);\n\n        require(keccak256(result531.buf) == keccak256(expected531), \"'3774511384' is not returning '98f2e9870e'\");\n\n        bytes memory expected532 = hex\"b1d291b10a\";\n        uint64 value532 = 2787404081;\n\n        Buffer.buffer memory result532 = Leb128.encodeUnsignedLeb128FromUInt64(value532);\n\n        require(keccak256(result532.buf) == keccak256(expected532), \"'2787404081' is not returning 'b1d291b10a'\");\n\n        bytes memory expected533 = hex\"e2fabdf10e\";\n        uint64 value533 = 3996089698;\n\n        Buffer.buffer memory result533 = Leb128.encodeUnsignedLeb128FromUInt64(value533);\n\n        require(keccak256(result533.buf) == keccak256(expected533), \"'3996089698' is not returning 'e2fabdf10e'\");\n\n        bytes memory expected534 = hex\"be8ef0ef08\";\n        uint64 value534 = 2382104382;\n\n        Buffer.buffer memory result534 = Leb128.encodeUnsignedLeb128FromUInt64(value534);\n\n        require(keccak256(result534.buf) == keccak256(expected534), \"'2382104382' is not returning 'be8ef0ef08'\");\n\n        bytes memory expected535 = hex\"d4cf87f80a\";\n        uint64 value535 = 2936137684;\n\n        Buffer.buffer memory result535 = Leb128.encodeUnsignedLeb128FromUInt64(value535);\n\n        require(keccak256(result535.buf) == keccak256(expected535), \"'2936137684' is not returning 'd4cf87f80a'\");\n\n        bytes memory expected536 = hex\"9ad4958a0e\";\n        uint64 value536 = 3779422746;\n\n        Buffer.buffer memory result536 = Leb128.encodeUnsignedLeb128FromUInt64(value536);\n\n        require(keccak256(result536.buf) == keccak256(expected536), \"'3779422746' is not returning '9ad4958a0e'\");\n\n        bytes memory expected537 = hex\"8ce9bce80f\";\n        uint64 value537 = 4245632140;\n\n        Buffer.buffer memory result537 = Leb128.encodeUnsignedLeb128FromUInt64(value537);\n\n        require(keccak256(result537.buf) == keccak256(expected537), \"'4245632140' is not returning '8ce9bce80f'\");\n\n        bytes memory expected538 = hex\"858f938c08\";\n        uint64 value538 = 2172962693;\n\n        Buffer.buffer memory result538 = Leb128.encodeUnsignedLeb128FromUInt64(value538);\n\n        require(keccak256(result538.buf) == keccak256(expected538), \"'2172962693' is not returning '858f938c08'\");\n\n        bytes memory expected539 = hex\"e18dc7fa05\";\n        uint64 value539 = 1599194849;\n\n        Buffer.buffer memory result539 = Leb128.encodeUnsignedLeb128FromUInt64(value539);\n\n        require(keccak256(result539.buf) == keccak256(expected539), \"'1599194849' is not returning 'e18dc7fa05'\");\n\n        bytes memory expected540 = hex\"8abbf7d602\";\n        uint64 value540 = 719183242;\n\n        Buffer.buffer memory result540 = Leb128.encodeUnsignedLeb128FromUInt64(value540);\n\n        require(keccak256(result540.buf) == keccak256(expected540), \"'719183242' is not returning '8abbf7d602'\");\n\n        bytes memory expected541 = hex\"d5dae6ad02\";\n        uint64 value541 = 632925525;\n\n        Buffer.buffer memory result541 = Leb128.encodeUnsignedLeb128FromUInt64(value541);\n\n        require(keccak256(result541.buf) == keccak256(expected541), \"'632925525' is not returning 'd5dae6ad02'\");\n\n        bytes memory expected542 = hex\"b4d3859b0f\";\n        uint64 value542 = 4083247540;\n\n        Buffer.buffer memory result542 = Leb128.encodeUnsignedLeb128FromUInt64(value542);\n\n        require(keccak256(result542.buf) == keccak256(expected542), \"'4083247540' is not returning 'b4d3859b0f'\");\n\n        bytes memory expected543 = hex\"e78188ee01\";\n        uint64 value543 = 499253479;\n\n        Buffer.buffer memory result543 = Leb128.encodeUnsignedLeb128FromUInt64(value543);\n\n        require(keccak256(result543.buf) == keccak256(expected543), \"'499253479' is not returning 'e78188ee01'\");\n\n        bytes memory expected544 = hex\"d398c49b0b\";\n        uint64 value544 = 3010530387;\n\n        Buffer.buffer memory result544 = Leb128.encodeUnsignedLeb128FromUInt64(value544);\n\n        require(keccak256(result544.buf) == keccak256(expected544), \"'3010530387' is not returning 'd398c49b0b'\");\n\n        bytes memory expected545 = hex\"9ffec1d102\";\n        uint64 value545 = 707821343;\n\n        Buffer.buffer memory result545 = Leb128.encodeUnsignedLeb128FromUInt64(value545);\n\n        require(keccak256(result545.buf) == keccak256(expected545), \"'707821343' is not returning '9ffec1d102'\");\n\n        bytes memory expected546 = hex\"9189b5a103\";\n        uint64 value546 = 875381905;\n\n        Buffer.buffer memory result546 = Leb128.encodeUnsignedLeb128FromUInt64(value546);\n\n        require(keccak256(result546.buf) == keccak256(expected546), \"'875381905' is not returning '9189b5a103'\");\n\n        bytes memory expected547 = hex\"d6d79ddc0f\";\n        uint64 value547 = 4219956182;\n\n        Buffer.buffer memory result547 = Leb128.encodeUnsignedLeb128FromUInt64(value547);\n\n        require(keccak256(result547.buf) == keccak256(expected547), \"'4219956182' is not returning 'd6d79ddc0f'\");\n\n        bytes memory expected548 = hex\"ccc198e305\";\n        uint64 value548 = 1550196940;\n\n        Buffer.buffer memory result548 = Leb128.encodeUnsignedLeb128FromUInt64(value548);\n\n        require(keccak256(result548.buf) == keccak256(expected548), \"'1550196940' is not returning 'ccc198e305'\");\n\n        bytes memory expected549 = hex\"d1a5978c03\";\n        uint64 value549 = 830853841;\n\n        Buffer.buffer memory result549 = Leb128.encodeUnsignedLeb128FromUInt64(value549);\n\n        require(keccak256(result549.buf) == keccak256(expected549), \"'830853841' is not returning 'd1a5978c03'\");\n\n        bytes memory expected550 = hex\"b0a4d6a206\";\n        uint64 value550 = 1683329584;\n\n        Buffer.buffer memory result550 = Leb128.encodeUnsignedLeb128FromUInt64(value550);\n\n        require(keccak256(result550.buf) == keccak256(expected550), \"'1683329584' is not returning 'b0a4d6a206'\");\n\n        bytes memory expected551 = hex\"9feedbd209\";\n        uint64 value551 = 2589390623;\n\n        Buffer.buffer memory result551 = Leb128.encodeUnsignedLeb128FromUInt64(value551);\n\n        require(keccak256(result551.buf) == keccak256(expected551), \"'2589390623' is not returning '9feedbd209'\");\n\n        bytes memory expected552 = hex\"e5fcd0b601\";\n        uint64 value552 = 383008357;\n\n        Buffer.buffer memory result552 = Leb128.encodeUnsignedLeb128FromUInt64(value552);\n\n        require(keccak256(result552.buf) == keccak256(expected552), \"'383008357' is not returning 'e5fcd0b601'\");\n\n        bytes memory expected553 = hex\"8ee0f59708\";\n        uint64 value553 = 2197647374;\n\n        Buffer.buffer memory result553 = Leb128.encodeUnsignedLeb128FromUInt64(value553);\n\n        require(keccak256(result553.buf) == keccak256(expected553), \"'2197647374' is not returning '8ee0f59708'\");\n\n        bytes memory expected554 = hex\"9afda1990b\";\n        uint64 value554 = 3005775514;\n\n        Buffer.buffer memory result554 = Leb128.encodeUnsignedLeb128FromUInt64(value554);\n\n        require(keccak256(result554.buf) == keccak256(expected554), \"'3005775514' is not returning '9afda1990b'\");\n\n        bytes memory expected555 = hex\"eaa6eaf50f\";\n        uint64 value555 = 4273640298;\n\n        Buffer.buffer memory result555 = Leb128.encodeUnsignedLeb128FromUInt64(value555);\n\n        require(keccak256(result555.buf) == keccak256(expected555), \"'4273640298' is not returning 'eaa6eaf50f'\");\n\n        bytes memory expected556 = hex\"b6b998dd0b\";\n        uint64 value556 = 3148225718;\n\n        Buffer.buffer memory result556 = Leb128.encodeUnsignedLeb128FromUInt64(value556);\n\n        require(keccak256(result556.buf) == keccak256(expected556), \"'3148225718' is not returning 'b6b998dd0b'\");\n\n        bytes memory expected557 = hex\"a892f8bc0c\";\n        uint64 value557 = 3349023016;\n\n        Buffer.buffer memory result557 = Leb128.encodeUnsignedLeb128FromUInt64(value557);\n\n        require(keccak256(result557.buf) == keccak256(expected557), \"'3349023016' is not returning 'a892f8bc0c'\");\n\n        bytes memory expected558 = hex\"b584abbc0c\";\n        uint64 value558 = 3347759669;\n\n        Buffer.buffer memory result558 = Leb128.encodeUnsignedLeb128FromUInt64(value558);\n\n        require(keccak256(result558.buf) == keccak256(expected558), \"'3347759669' is not returning 'b584abbc0c'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.generated9.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Generated9Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding_generated() public pure {\n        bytes memory expected560 = hex\"cfe7959f04\";\n        uint64 value560 = 1139110863;\n\n        Buffer.buffer memory result560 = Leb128.encodeUnsignedLeb128FromUInt64(value560);\n\n        require(keccak256(result560.buf) == keccak256(expected560), \"'1139110863' is not returning 'cfe7959f04'\");\n\n        bytes memory expected561 = hex\"fee6869d0a\";\n        uint64 value561 = 2745283454;\n\n        Buffer.buffer memory result561 = Leb128.encodeUnsignedLeb128FromUInt64(value561);\n\n        require(keccak256(result561.buf) == keccak256(expected561), \"'2745283454' is not returning 'fee6869d0a'\");\n\n        bytes memory expected562 = hex\"bdb794dd02\";\n        uint64 value562 = 732240829;\n\n        Buffer.buffer memory result562 = Leb128.encodeUnsignedLeb128FromUInt64(value562);\n\n        require(keccak256(result562.buf) == keccak256(expected562), \"'732240829' is not returning 'bdb794dd02'\");\n\n        bytes memory expected563 = hex\"88e2bca101\";\n        uint64 value563 = 338637064;\n\n        Buffer.buffer memory result563 = Leb128.encodeUnsignedLeb128FromUInt64(value563);\n\n        require(keccak256(result563.buf) == keccak256(expected563), \"'338637064' is not returning '88e2bca101'\");\n\n        bytes memory expected564 = hex\"92fdbf8f03\";\n        uint64 value564 = 837811858;\n\n        Buffer.buffer memory result564 = Leb128.encodeUnsignedLeb128FromUInt64(value564);\n\n        require(keccak256(result564.buf) == keccak256(expected564), \"'837811858' is not returning '92fdbf8f03'\");\n\n        bytes memory expected565 = hex\"e198cd8907\";\n        uint64 value565 = 1899187297;\n\n        Buffer.buffer memory result565 = Leb128.encodeUnsignedLeb128FromUInt64(value565);\n\n        require(keccak256(result565.buf) == keccak256(expected565), \"'1899187297' is not returning 'e198cd8907'\");\n\n        bytes memory expected566 = hex\"cbf9a6d706\";\n        uint64 value566 = 1793703115;\n\n        Buffer.buffer memory result566 = Leb128.encodeUnsignedLeb128FromUInt64(value566);\n\n        require(keccak256(result566.buf) == keccak256(expected566), \"'1793703115' is not returning 'cbf9a6d706'\");\n\n        bytes memory expected567 = hex\"b8e4f4ce09\";\n        uint64 value567 = 2581410360;\n\n        Buffer.buffer memory result567 = Leb128.encodeUnsignedLeb128FromUInt64(value567);\n\n        require(keccak256(result567.buf) == keccak256(expected567), \"'2581410360' is not returning 'b8e4f4ce09'\");\n\n        bytes memory expected568 = hex\"848cf1d70b\";\n        uint64 value568 = 3137095172;\n\n        Buffer.buffer memory result568 = Leb128.encodeUnsignedLeb128FromUInt64(value568);\n\n        require(keccak256(result568.buf) == keccak256(expected568), \"'3137095172' is not returning '848cf1d70b'\");\n\n        bytes memory expected569 = hex\"a795c503\";\n        uint64 value569 = 7424679;\n\n        Buffer.buffer memory result569 = Leb128.encodeUnsignedLeb128FromUInt64(value569);\n\n        require(keccak256(result569.buf) == keccak256(expected569), \"'7424679' is not returning 'a795c503'\");\n\n        bytes memory expected570 = hex\"efd493b305\";\n        uint64 value570 = 1449454191;\n\n        Buffer.buffer memory result570 = Leb128.encodeUnsignedLeb128FromUInt64(value570);\n\n        require(keccak256(result570.buf) == keccak256(expected570), \"'1449454191' is not returning 'efd493b305'\");\n\n        bytes memory expected571 = hex\"bdd9b6990f\";\n        uint64 value571 = 4079856829;\n\n        Buffer.buffer memory result571 = Leb128.encodeUnsignedLeb128FromUInt64(value571);\n\n        require(keccak256(result571.buf) == keccak256(expected571), \"'4079856829' is not returning 'bdd9b6990f'\");\n\n        bytes memory expected572 = hex\"c882ffc909\";\n        uint64 value572 = 2571092296;\n\n        Buffer.buffer memory result572 = Leb128.encodeUnsignedLeb128FromUInt64(value572);\n\n        require(keccak256(result572.buf) == keccak256(expected572), \"'2571092296' is not returning 'c882ffc909'\");\n\n        bytes memory expected573 = hex\"9987e2ec0d\";\n        uint64 value573 = 3717759897;\n\n        Buffer.buffer memory result573 = Leb128.encodeUnsignedLeb128FromUInt64(value573);\n\n        require(keccak256(result573.buf) == keccak256(expected573), \"'3717759897' is not returning '9987e2ec0d'\");\n\n        bytes memory expected574 = hex\"f7a0e2de0a\";\n        uint64 value574 = 2883096695;\n\n        Buffer.buffer memory result574 = Leb128.encodeUnsignedLeb128FromUInt64(value574);\n\n        require(keccak256(result574.buf) == keccak256(expected574), \"'2883096695' is not returning 'f7a0e2de0a'\");\n\n        bytes memory expected575 = hex\"a7bfb2a606\";\n        uint64 value575 = 1691131815;\n\n        Buffer.buffer memory result575 = Leb128.encodeUnsignedLeb128FromUInt64(value575);\n\n        require(keccak256(result575.buf) == keccak256(expected575), \"'1691131815' is not returning 'a7bfb2a606'\");\n\n        bytes memory expected576 = hex\"b6a39ef707\";\n        uint64 value576 = 2129105334;\n\n        Buffer.buffer memory result576 = Leb128.encodeUnsignedLeb128FromUInt64(value576);\n\n        require(keccak256(result576.buf) == keccak256(expected576), \"'2129105334' is not returning 'b6a39ef707'\");\n\n        bytes memory expected577 = hex\"8ea7cce103\";\n        uint64 value577 = 1009980302;\n\n        Buffer.buffer memory result577 = Leb128.encodeUnsignedLeb128FromUInt64(value577);\n\n        require(keccak256(result577.buf) == keccak256(expected577), \"'1009980302' is not returning '8ea7cce103'\");\n\n        bytes memory expected578 = hex\"fdd3c4e50c\";\n        uint64 value578 = 3434162685;\n\n        Buffer.buffer memory result578 = Leb128.encodeUnsignedLeb128FromUInt64(value578);\n\n        require(keccak256(result578.buf) == keccak256(expected578), \"'3434162685' is not returning 'fdd3c4e50c'\");\n\n        bytes memory expected579 = hex\"fdf193b102\";\n        uint64 value579 = 639957245;\n\n        Buffer.buffer memory result579 = Leb128.encodeUnsignedLeb128FromUInt64(value579);\n\n        require(keccak256(result579.buf) == keccak256(expected579), \"'639957245' is not returning 'fdf193b102'\");\n\n        bytes memory expected580 = hex\"cff9e7bc03\";\n        uint64 value580 = 932838607;\n\n        Buffer.buffer memory result580 = Leb128.encodeUnsignedLeb128FromUInt64(value580);\n\n        require(keccak256(result580.buf) == keccak256(expected580), \"'932838607' is not returning 'cff9e7bc03'\");\n\n        bytes memory expected581 = hex\"bcc0e7860c\";\n        uint64 value581 = 3235504188;\n\n        Buffer.buffer memory result581 = Leb128.encodeUnsignedLeb128FromUInt64(value581);\n\n        require(keccak256(result581.buf) == keccak256(expected581), \"'3235504188' is not returning 'bcc0e7860c'\");\n\n        bytes memory expected582 = hex\"8bcde0b204\";\n        uint64 value582 = 1180182155;\n\n        Buffer.buffer memory result582 = Leb128.encodeUnsignedLeb128FromUInt64(value582);\n\n        require(keccak256(result582.buf) == keccak256(expected582), \"'1180182155' is not returning '8bcde0b204'\");\n\n        bytes memory expected583 = hex\"e8f6c2940b\";\n        uint64 value583 = 2995829608;\n\n        Buffer.buffer memory result583 = Leb128.encodeUnsignedLeb128FromUInt64(value583);\n\n        require(keccak256(result583.buf) == keccak256(expected583), \"'2995829608' is not returning 'e8f6c2940b'\");\n\n        bytes memory expected584 = hex\"ab8bbccc03\";\n        uint64 value584 = 965674411;\n\n        Buffer.buffer memory result584 = Leb128.encodeUnsignedLeb128FromUInt64(value584);\n\n        require(keccak256(result584.buf) == keccak256(expected584), \"'965674411' is not returning 'ab8bbccc03'\");\n\n        bytes memory expected585 = hex\"a3b7c0b401\";\n        uint64 value585 = 378543011;\n\n        Buffer.buffer memory result585 = Leb128.encodeUnsignedLeb128FromUInt64(value585);\n\n        require(keccak256(result585.buf) == keccak256(expected585), \"'378543011' is not returning 'a3b7c0b401'\");\n\n        bytes memory expected586 = hex\"cfc5c2fb0f\";\n        uint64 value586 = 4285571791;\n\n        Buffer.buffer memory result586 = Leb128.encodeUnsignedLeb128FromUInt64(value586);\n\n        require(keccak256(result586.buf) == keccak256(expected586), \"'4285571791' is not returning 'cfc5c2fb0f'\");\n\n        bytes memory expected587 = hex\"c195bd8601\";\n        uint64 value587 = 282020545;\n\n        Buffer.buffer memory result587 = Leb128.encodeUnsignedLeb128FromUInt64(value587);\n\n        require(keccak256(result587.buf) == keccak256(expected587), \"'282020545' is not returning 'c195bd8601'\");\n\n        bytes memory expected588 = hex\"db98edfa08\";\n        uint64 value588 = 2405125211;\n\n        Buffer.buffer memory result588 = Leb128.encodeUnsignedLeb128FromUInt64(value588);\n\n        require(keccak256(result588.buf) == keccak256(expected588), \"'2405125211' is not returning 'db98edfa08'\");\n\n        bytes memory expected589 = hex\"af88dc9e03\";\n        uint64 value589 = 869729327;\n\n        Buffer.buffer memory result589 = Leb128.encodeUnsignedLeb128FromUInt64(value589);\n\n        require(keccak256(result589.buf) == keccak256(expected589), \"'869729327' is not returning 'af88dc9e03'\");\n\n        bytes memory expected590 = hex\"8097af8808\";\n        uint64 value590 = 2165033856;\n\n        Buffer.buffer memory result590 = Leb128.encodeUnsignedLeb128FromUInt64(value590);\n\n        require(keccak256(result590.buf) == keccak256(expected590), \"'2165033856' is not returning '8097af8808'\");\n\n        bytes memory expected591 = hex\"ec98c7f10b\";\n        uint64 value591 = 3190934636;\n\n        Buffer.buffer memory result591 = Leb128.encodeUnsignedLeb128FromUInt64(value591);\n\n        require(keccak256(result591.buf) == keccak256(expected591), \"'3190934636' is not returning 'ec98c7f10b'\");\n\n        bytes memory expected592 = hex\"e3cfa6e805\";\n        uint64 value592 = 1560913891;\n\n        Buffer.buffer memory result592 = Leb128.encodeUnsignedLeb128FromUInt64(value592);\n\n        require(keccak256(result592.buf) == keccak256(expected592), \"'1560913891' is not returning 'e3cfa6e805'\");\n\n        bytes memory expected593 = hex\"dcffe7ee0e\";\n        uint64 value593 = 3990487004;\n\n        Buffer.buffer memory result593 = Leb128.encodeUnsignedLeb128FromUInt64(value593);\n\n        require(keccak256(result593.buf) == keccak256(expected593), \"'3990487004' is not returning 'dcffe7ee0e'\");\n\n        bytes memory expected594 = hex\"e9ed92ee0b\";\n        uint64 value594 = 3183785705;\n\n        Buffer.buffer memory result594 = Leb128.encodeUnsignedLeb128FromUInt64(value594);\n\n        require(keccak256(result594.buf) == keccak256(expected594), \"'3183785705' is not returning 'e9ed92ee0b'\");\n\n        bytes memory expected595 = hex\"dbb1c29509\";\n        uint64 value595 = 2461047003;\n\n        Buffer.buffer memory result595 = Leb128.encodeUnsignedLeb128FromUInt64(value595);\n\n        require(keccak256(result595.buf) == keccak256(expected595), \"'2461047003' is not returning 'dbb1c29509'\");\n\n        bytes memory expected596 = hex\"b7b7c9f00f\";\n        uint64 value596 = 4262615991;\n\n        Buffer.buffer memory result596 = Leb128.encodeUnsignedLeb128FromUInt64(value596);\n\n        require(keccak256(result596.buf) == keccak256(expected596), \"'4262615991' is not returning 'b7b7c9f00f'\");\n\n        bytes memory expected597 = hex\"facab9a205\";\n        uint64 value597 = 1414423930;\n\n        Buffer.buffer memory result597 = Leb128.encodeUnsignedLeb128FromUInt64(value597);\n\n        require(keccak256(result597.buf) == keccak256(expected597), \"'1414423930' is not returning 'facab9a205'\");\n\n        bytes memory expected598 = hex\"c6e4c4dc03\";\n        uint64 value598 = 999371334;\n\n        Buffer.buffer memory result598 = Leb128.encodeUnsignedLeb128FromUInt64(value598);\n\n        require(keccak256(result598.buf) == keccak256(expected598), \"'999371334' is not returning 'c6e4c4dc03'\");\n\n        bytes memory expected599 = hex\"b9ffbba506\";\n        uint64 value599 = 1689190329;\n\n        Buffer.buffer memory result599 = Leb128.encodeUnsignedLeb128FromUInt64(value599);\n\n        require(keccak256(result599.buf) == keccak256(expected599), \"'1689190329' is not returning 'b9ffbba506'\");\n\n        bytes memory expected600 = hex\"a3e2c420\";\n        uint64 value600 = 68235555;\n\n        Buffer.buffer memory result600 = Leb128.encodeUnsignedLeb128FromUInt64(value600);\n\n        require(keccak256(result600.buf) == keccak256(expected600), \"'68235555' is not returning 'a3e2c420'\");\n\n        bytes memory expected601 = hex\"e9fdd476\";\n        uint64 value601 = 248856297;\n\n        Buffer.buffer memory result601 = Leb128.encodeUnsignedLeb128FromUInt64(value601);\n\n        require(keccak256(result601.buf) == keccak256(expected601), \"'248856297' is not returning 'e9fdd476'\");\n\n        bytes memory expected602 = hex\"feefa79f0f\";\n        uint64 value602 = 4092196862;\n\n        Buffer.buffer memory result602 = Leb128.encodeUnsignedLeb128FromUInt64(value602);\n\n        require(keccak256(result602.buf) == keccak256(expected602), \"'4092196862' is not returning 'feefa79f0f'\");\n\n        bytes memory expected603 = hex\"e3db9f820d\";\n        uint64 value603 = 3494374883;\n\n        Buffer.buffer memory result603 = Leb128.encodeUnsignedLeb128FromUInt64(value603);\n\n        require(keccak256(result603.buf) == keccak256(expected603), \"'3494374883' is not returning 'e3db9f820d'\");\n\n        bytes memory expected604 = hex\"e3fed9bd0a\";\n        uint64 value604 = 2813755235;\n\n        Buffer.buffer memory result604 = Leb128.encodeUnsignedLeb128FromUInt64(value604);\n\n        require(keccak256(result604.buf) == keccak256(expected604), \"'2813755235' is not returning 'e3fed9bd0a'\");\n\n        bytes memory expected605 = hex\"cbc2bdf204\";\n        uint64 value605 = 1313825099;\n\n        Buffer.buffer memory result605 = Leb128.encodeUnsignedLeb128FromUInt64(value605);\n\n        require(keccak256(result605.buf) == keccak256(expected605), \"'1313825099' is not returning 'cbc2bdf204'\");\n\n        bytes memory expected606 = hex\"9ef5c5d309\";\n        uint64 value606 = 2591128222;\n\n        Buffer.buffer memory result606 = Leb128.encodeUnsignedLeb128FromUInt64(value606);\n\n        require(keccak256(result606.buf) == keccak256(expected606), \"'2591128222' is not returning '9ef5c5d309'\");\n\n        bytes memory expected607 = hex\"bac0d7d605\";\n        uint64 value607 = 1523966010;\n\n        Buffer.buffer memory result607 = Leb128.encodeUnsignedLeb128FromUInt64(value607);\n\n        require(keccak256(result607.buf) == keccak256(expected607), \"'1523966010' is not returning 'bac0d7d605'\");\n\n        bytes memory expected608 = hex\"fae2d89904\";\n        uint64 value608 = 1127625082;\n\n        Buffer.buffer memory result608 = Leb128.encodeUnsignedLeb128FromUInt64(value608);\n\n        require(keccak256(result608.buf) == keccak256(expected608), \"'1127625082' is not returning 'fae2d89904'\");\n\n        bytes memory expected609 = hex\"8ab19dd704\";\n        uint64 value609 = 1256675466;\n\n        Buffer.buffer memory result609 = Leb128.encodeUnsignedLeb128FromUInt64(value609);\n\n        require(keccak256(result609.buf) == keccak256(expected609), \"'1256675466' is not returning '8ab19dd704'\");\n\n        bytes memory expected610 = hex\"95bad7b704\";\n        uint64 value610 = 1190518037;\n\n        Buffer.buffer memory result610 = Leb128.encodeUnsignedLeb128FromUInt64(value610);\n\n        require(keccak256(result610.buf) == keccak256(expected610), \"'1190518037' is not returning '95bad7b704'\");\n\n        bytes memory expected611 = hex\"cac383b30a\";\n        uint64 value611 = 2791367114;\n\n        Buffer.buffer memory result611 = Leb128.encodeUnsignedLeb128FromUInt64(value611);\n\n        require(keccak256(result611.buf) == keccak256(expected611), \"'2791367114' is not returning 'cac383b30a'\");\n\n        bytes memory expected612 = hex\"ce8de5870e\";\n        uint64 value612 = 3774432974;\n\n        Buffer.buffer memory result612 = Leb128.encodeUnsignedLeb128FromUInt64(value612);\n\n        require(keccak256(result612.buf) == keccak256(expected612), \"'3774432974' is not returning 'ce8de5870e'\");\n\n        bytes memory expected613 = hex\"838385dc0c\";\n        uint64 value613 = 3414245763;\n\n        Buffer.buffer memory result613 = Leb128.encodeUnsignedLeb128FromUInt64(value613);\n\n        require(keccak256(result613.buf) == keccak256(expected613), \"'3414245763' is not returning '838385dc0c'\");\n\n        bytes memory expected614 = hex\"b8a2c3f905\";\n        uint64 value614 = 1597034808;\n\n        Buffer.buffer memory result614 = Leb128.encodeUnsignedLeb128FromUInt64(value614);\n\n        require(keccak256(result614.buf) == keccak256(expected614), \"'1597034808' is not returning 'b8a2c3f905'\");\n\n        bytes memory expected615 = hex\"8aaa8cf70e\";\n        uint64 value615 = 4007859466;\n\n        Buffer.buffer memory result615 = Leb128.encodeUnsignedLeb128FromUInt64(value615);\n\n        require(keccak256(result615.buf) == keccak256(expected615), \"'4007859466' is not returning '8aaa8cf70e'\");\n\n        bytes memory expected616 = hex\"fe8f8acf09\";\n        uint64 value616 = 2581759998;\n\n        Buffer.buffer memory result616 = Leb128.encodeUnsignedLeb128FromUInt64(value616);\n\n        require(keccak256(result616.buf) == keccak256(expected616), \"'2581759998' is not returning 'fe8f8acf09'\");\n\n        bytes memory expected617 = hex\"86c4adf90b\";\n        uint64 value617 = 3207291398;\n\n        Buffer.buffer memory result617 = Leb128.encodeUnsignedLeb128FromUInt64(value617);\n\n        require(keccak256(result617.buf) == keccak256(expected617), \"'3207291398' is not returning '86c4adf90b'\");\n\n        bytes memory expected618 = hex\"f3a5cdeb09\";\n        uint64 value618 = 2641580787;\n\n        Buffer.buffer memory result618 = Leb128.encodeUnsignedLeb128FromUInt64(value618);\n\n        require(keccak256(result618.buf) == keccak256(expected618), \"'2641580787' is not returning 'f3a5cdeb09'\");\n\n        bytes memory expected619 = hex\"bcb7abd40f\";\n        uint64 value619 = 4203404220;\n\n        Buffer.buffer memory result619 = Leb128.encodeUnsignedLeb128FromUInt64(value619);\n\n        require(keccak256(result619.buf) == keccak256(expected619), \"'4203404220' is not returning 'bcb7abd40f'\");\n\n        bytes memory expected620 = hex\"9e87a5a10e\";\n        uint64 value620 = 3827909534;\n\n        Buffer.buffer memory result620 = Leb128.encodeUnsignedLeb128FromUInt64(value620);\n\n        require(keccak256(result620.buf) == keccak256(expected620), \"'3827909534' is not returning '9e87a5a10e'\");\n\n        bytes memory expected621 = hex\"8bdbdbd50c\";\n        uint64 value621 = 3400985995;\n\n        Buffer.buffer memory result621 = Leb128.encodeUnsignedLeb128FromUInt64(value621);\n\n        require(keccak256(result621.buf) == keccak256(expected621), \"'3400985995' is not returning '8bdbdbd50c'\");\n\n        bytes memory expected622 = hex\"a78cabc809\";\n        uint64 value622 = 2567620135;\n\n        Buffer.buffer memory result622 = Leb128.encodeUnsignedLeb128FromUInt64(value622);\n\n        require(keccak256(result622.buf) == keccak256(expected622), \"'2567620135' is not returning 'a78cabc809'\");\n\n        bytes memory expected623 = hex\"a392ffcc08\";\n        uint64 value623 = 2308950307;\n\n        Buffer.buffer memory result623 = Leb128.encodeUnsignedLeb128FromUInt64(value623);\n\n        require(keccak256(result623.buf) == keccak256(expected623), \"'2308950307' is not returning 'a392ffcc08'\");\n\n        bytes memory expected624 = hex\"ffacfbf204\";\n        uint64 value624 = 1314838143;\n\n        Buffer.buffer memory result624 = Leb128.encodeUnsignedLeb128FromUInt64(value624);\n\n        require(keccak256(result624.buf) == keccak256(expected624), \"'1314838143' is not returning 'ffacfbf204'\");\n\n        bytes memory expected625 = hex\"a5b3fe8e08\";\n        uint64 value625 = 2178914725;\n\n        Buffer.buffer memory result625 = Leb128.encodeUnsignedLeb128FromUInt64(value625);\n\n        require(keccak256(result625.buf) == keccak256(expected625), \"'2178914725' is not returning 'a5b3fe8e08'\");\n\n        bytes memory expected626 = hex\"b3d5bbba06\";\n        uint64 value626 = 1733225139;\n\n        Buffer.buffer memory result626 = Leb128.encodeUnsignedLeb128FromUInt64(value626);\n\n        require(keccak256(result626.buf) == keccak256(expected626), \"'1733225139' is not returning 'b3d5bbba06'\");\n\n        bytes memory expected627 = hex\"d08be3e405\";\n        uint64 value627 = 1553515984;\n\n        Buffer.buffer memory result627 = Leb128.encodeUnsignedLeb128FromUInt64(value627);\n\n        require(keccak256(result627.buf) == keccak256(expected627), \"'1553515984' is not returning 'd08be3e405'\");\n\n        bytes memory expected628 = hex\"9ae2b2fb07\";\n        uint64 value628 = 2137829658;\n\n        Buffer.buffer memory result628 = Leb128.encodeUnsignedLeb128FromUInt64(value628);\n\n        require(keccak256(result628.buf) == keccak256(expected628), \"'2137829658' is not returning '9ae2b2fb07'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/leb128.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../utils/Leb128.sol\";\nimport \"../utils/FilAddresses.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the Leb128 lib, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract Leb128Test {\n    using Buffer for Buffer.buffer;\n\n    function unsiged_integer_leb128_encoding() public pure {\n        bytes memory expected = hex\"e58e26\";\n        uint64 value = 624485;\n\n        Buffer.buffer memory result = Leb128.encodeUnsignedLeb128FromUInt64(value);\n\n        require(keccak256(result.buf) == keccak256(expected), \"'624485' is not returning 'e58e26'\");\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/market.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../MarketAPI.sol\";\nimport \"../types/MarketTypes.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the market actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract MarketApiTest {\n    function add_balance(CommonTypes.FilAddress memory providerOrClient, uint256 value) public payable {\n        MarketAPI.addBalance(providerOrClient, value);\n    }\n\n    function withdraw_balance(MarketTypes.WithdrawBalanceParams memory params) public returns (CommonTypes.BigInt memory) {\n        return MarketAPI.withdrawBalance(params);\n    }\n\n    function get_balance(CommonTypes.FilAddress memory addr) public returns (MarketTypes.GetBalanceReturn memory) {\n        return MarketAPI.getBalance(addr);\n    }\n\n    function get_deal_data_commitment(uint64 dealID) public returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        return MarketAPI.getDealDataCommitment(dealID);\n    }\n\n    function get_deal_client(uint64 dealID) public returns (uint64) {\n        return MarketAPI.getDealClient(dealID);\n    }\n\n    function get_deal_provider(uint64 dealID) public returns (uint64) {\n        return MarketAPI.getDealProvider(dealID);\n    }\n\n    function get_deal_label(uint64 dealID) public returns (CommonTypes.DealLabel memory) {\n        return MarketAPI.getDealLabel(dealID);\n    }\n\n    function get_deal_term(uint64 dealID) public returns (MarketTypes.GetDealTermReturn memory) {\n        return MarketAPI.getDealTerm(dealID);\n    }\n\n    function get_deal_total_price(uint64 dealID) public returns (CommonTypes.BigInt memory) {\n        return MarketAPI.getDealTotalPrice(dealID);\n    }\n\n    function get_deal_client_collateral(uint64 dealID) public returns (CommonTypes.BigInt memory) {\n        return MarketAPI.getDealClientCollateral(dealID);\n    }\n\n    function get_deal_provider_collateral(uint64 dealID) public returns (CommonTypes.BigInt memory) {\n        return MarketAPI.getDealProviderCollateral(dealID);\n    }\n\n    function get_deal_verified(uint64 dealID) public returns (bool) {\n        return MarketAPI.getDealVerified(dealID);\n    }\n\n    function get_deal_activation(uint64 dealID) public returns (MarketTypes.GetDealActivationReturn memory) {\n        return MarketAPI.getDealActivation(dealID);\n    }\n\n    function publish_storage_deals(MarketTypes.PublishStorageDealsParams memory params) public returns (MarketTypes.PublishStorageDealsReturn memory) {\n        return MarketAPI.publishStorageDeals(params);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/marketcbor.test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport {MarketTypes} from \"../types/MarketTypes.sol\";\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {MarketCBOR} from \"../cbor/MarketCbor.sol\";\nimport {BigIntCBOR} from \"../cbor/BigIntCbor.sol\";\nimport \"../utils/FilAddresses.sol\";\n\ncontract MarketCBORTest {\n    using MarketCBOR for *;\n\n    function bigIntEqual(CommonTypes.BigInt memory n1, CommonTypes.BigInt memory n2) internal pure {\n        require(keccak256(n1.val) == keccak256(n2.val));\n        require(n1.neg == n2.neg);\n    }\n\n    function testDealProposalSerDes() public pure {\n        MarketTypes.DealProposal memory proposal;\n        proposal.piece_cid = CommonTypes.Cid(hex\"000181E2039220206B86B273FF34FCE19D6B804EFF5A3F5747ADA4EAA22F1D49C01E52DDB7875B4B\");\n        proposal.piece_size = 1024;\n        proposal.verified_deal = true;\n        proposal.client = FilAddresses.fromBytes(hex\"001234\");\n        proposal.provider = FilAddresses.fromBytes(hex\"005678\");\n        proposal.label = CommonTypes.DealLabel(bytes(\"test\"), true);\n        proposal.start_epoch = CommonTypes.ChainEpoch.wrap(20000);\n        proposal.end_epoch = CommonTypes.ChainEpoch.wrap(40000);\n        proposal.storage_price_per_epoch = CommonTypes.BigInt(hex\"50\", false);\n        proposal.provider_collateral = CommonTypes.BigInt(hex\"10\", false);\n        proposal.client_collateral = CommonTypes.BigInt(hex\"20\", false);\n\n        bytes memory cborBytes = proposal.serializeDealProposal();\n\n        MarketTypes.DealProposal memory deserProposal = cborBytes.deserializeDealProposal();\n        require(keccak256(proposal.piece_cid.data) == keccak256(deserProposal.piece_cid.data), \"unequal piece_cid\");\n        require(proposal.piece_size == deserProposal.piece_size, \"unequal piece_size\");\n        require(proposal.verified_deal == deserProposal.verified_deal, \"unequal verified_deal\");\n        require(keccak256(proposal.client.data) == keccak256(deserProposal.client.data), \"unequal client\");\n        require(keccak256(proposal.provider.data) == keccak256(deserProposal.provider.data), \"unequal provider\");\n        require(keccak256(abi.encodePacked(proposal.label.data)) == keccak256(abi.encodePacked(deserProposal.label.data)), \"unequal label\");\n        require(proposal.label.isString == deserProposal.label.isString, \"unequal label type\");\n        require(CommonTypes.ChainEpoch.unwrap(proposal.start_epoch) == CommonTypes.ChainEpoch.unwrap(deserProposal.start_epoch), \"unequal start_epoch\");\n        require(CommonTypes.ChainEpoch.unwrap(proposal.end_epoch) == CommonTypes.ChainEpoch.unwrap(deserProposal.end_epoch), \"unequal end_epoch\");\n        bigIntEqual(proposal.storage_price_per_epoch, deserProposal.storage_price_per_epoch);\n        bigIntEqual(proposal.provider_collateral, deserProposal.provider_collateral);\n        bigIntEqual(proposal.client_collateral, deserProposal.client_collateral);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/miner.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../MinerAPI.sol\";\nimport \"../types/MinerTypes.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the miner actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract MinerApiTest {\n    function get_owner(CommonTypes.FilActorId target) public returns (MinerTypes.GetOwnerReturn memory) {\n        return MinerAPI.getOwner(target);\n    }\n\n    function change_owner_address(CommonTypes.FilActorId target, CommonTypes.FilAddress memory addr) public {\n        MinerAPI.changeOwnerAddress(target, addr);\n    }\n\n    function is_controlling_address(CommonTypes.FilActorId target, CommonTypes.FilAddress memory addr) public returns (bool) {\n        return MinerAPI.isControllingAddress(target, addr);\n    }\n\n    function get_sector_size(CommonTypes.FilActorId target) public returns (uint64) {\n        return MinerAPI.getSectorSize(target);\n    }\n\n    function get_available_balance(CommonTypes.FilActorId target) public returns (CommonTypes.BigInt memory) {\n        return MinerAPI.getAvailableBalance(target);\n    }\n\n    function get_vesting_funds(CommonTypes.FilActorId target) public returns (MinerTypes.GetVestingFundsReturn memory) {\n        return MinerAPI.getVestingFunds(target);\n    }\n\n    function change_beneficiary(CommonTypes.FilActorId target, MinerTypes.ChangeBeneficiaryParams memory params) public {\n        return MinerAPI.changeBeneficiary(target, params);\n    }\n\n    function get_beneficiary(CommonTypes.FilActorId target) public returns (MinerTypes.GetBeneficiaryReturn memory) {\n        return MinerAPI.getBeneficiary(target);\n    }\n\n    function change_worker_address(CommonTypes.FilActorId target, MinerTypes.ChangeWorkerAddressParams memory params) public {\n        MinerAPI.changeWorkerAddress(target, params);\n    }\n\n    function change_peer_id(CommonTypes.FilActorId target, CommonTypes.FilAddress memory newId) public {\n        MinerAPI.changePeerId(target, newId);\n    }\n\n    function change_multiaddresses(CommonTypes.FilActorId target, MinerTypes.ChangeMultiaddrsParams memory params) public {\n        MinerAPI.changeMultiaddresses(target, params);\n    }\n\n    function repay_debt(CommonTypes.FilActorId target) public {\n        MinerAPI.repayDebt(target);\n    }\n\n    function confirm_change_worker_address(CommonTypes.FilActorId target) public {\n        MinerAPI.confirmChangeWorkerAddress(target);\n    }\n\n    function get_peer_id(CommonTypes.FilActorId target) public returns (CommonTypes.FilAddress memory) {\n        return MinerAPI.getPeerId(target);\n    }\n\n    function get_multiaddresses(CommonTypes.FilActorId target) public returns (MinerTypes.GetMultiaddrsReturn memory) {\n        return MinerAPI.getMultiaddresses(target);\n    }\n\n    function withdraw_balance(CommonTypes.FilActorId target, CommonTypes.BigInt memory amount) public returns (CommonTypes.BigInt memory) {\n        return MinerAPI.withdrawBalance(target, amount);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/power.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/PowerTypes.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"../PowerAPI.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the power actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract PowerApiTest {\n    function create_miner(PowerTypes.CreateMinerParams memory params, uint256 value) public payable returns (PowerTypes.CreateMinerReturn memory) {\n        return PowerAPI.createMiner(params, value);\n    }\n\n    function miner_count() public returns (uint64) {\n        return PowerAPI.minerCount();\n    }\n\n    function miner_consensus_count() public returns (int64) {\n        return PowerAPI.minerConsensusCount();\n    }\n\n    function network_raw_power() public returns (CommonTypes.BigInt memory) {\n        return PowerAPI.networkRawPower();\n    }\n\n    function miner_raw_power(uint64 minerID) public returns (PowerTypes.MinerRawPowerReturn memory) {\n        return PowerAPI.minerRawPower(minerID);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/precompiles.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../PrecompilesAPI.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the precompiles API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract PrecompilesApiTest {\n    function resolve_address(CommonTypes.FilAddress memory addr) public view returns (uint64) {\n        return PrecompilesAPI.resolveAddress(addr);\n    }\n\n    function resolve_eth_address(address addr) public view returns (uint64) {\n        return PrecompilesAPI.resolveEthAddress(addr);\n    }\n\n    function lookup_delegated_address(uint64 actor_id) public view returns (bytes memory) {\n        return PrecompilesAPI.lookupDelegatedAddress(actor_id);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/send.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../SendAPI.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the send utilities, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract SendApiTest {\n    function send(CommonTypes.FilActorId target, uint256 amount) public {\n        return SendAPI.send(target, amount);\n    }\n\n    function send(CommonTypes.FilAddress memory target, uint256 amount) public {\n        return SendAPI.send(target, amount);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/tests/verifreg.test.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/VerifRegTypes.sol\";\nimport \"../types/CommonTypes.sol\";\nimport \"../VerifRegAPI.sol\";\n\n/// @notice This file is meant to serve as a deployable contract of the verified registry actor API, as the library by itself is not.\n/// @notice It imports the library and create a callable method for each method in the library\n/// @author Zondax AG\ncontract VerifRegApiTest {\n    function get_claims(VerifRegTypes.GetClaimsParams memory params) public returns (VerifRegTypes.GetClaimsReturn memory) {\n        return VerifRegAPI.getClaims(params);\n    }\n\n    function add_verified_client(VerifRegTypes.AddVerifiedClientParams memory params) public {\n        VerifRegAPI.addVerifiedClient(params);\n    }\n\n    function remove_expired_allocations(\n        VerifRegTypes.RemoveExpiredAllocationsParams memory params\n    ) public returns (VerifRegTypes.RemoveExpiredAllocationsReturn memory) {\n        return VerifRegAPI.removeExpiredAllocations(params);\n    }\n\n    function extend_claim_terms(VerifRegTypes.ExtendClaimTermsParams memory params) public returns (CommonTypes.BatchReturn memory) {\n        return VerifRegAPI.extendClaimTerms(params);\n    }\n\n    function remove_expired_claims(VerifRegTypes.RemoveExpiredClaimsParams memory params) public returns (VerifRegTypes.RemoveExpiredClaimsReturn memory) {\n        return VerifRegAPI.removeExpiredClaims(params);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/AccountTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin account actor types for Solidity.\n/// @author Zondax AG\nlibrary AccountTypes {\n    uint constant AuthenticateMessageMethodNum = 2643134072;\n\n    /// @param it should be a raw byte of signature, NOT a serialized signature object with a signatureType.\n    /// @param message The message which is signed by the corresponding account address.\n    struct AuthenticateMessageParams {\n        bytes signature;\n        bytes message;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\n\n    /// @param idx index for the failure in batch\n    /// @param code failure code\n    struct FailCode {\n        uint32 idx;\n        uint32 code;\n    }\n\n    /// @param success_count total successes in batch\n    /// @param fail_codes list of failures code and index for each failure in batch\n    struct BatchReturn {\n        uint32 success_count;\n        FailCode[] fail_codes;\n    }\n\n    /// @param type_ asset type\n    /// @param payload payload corresponding to asset type\n    struct UniversalReceiverParams {\n        uint32 type_;\n        bytes payload;\n    }\n\n    /// @param val contains the actual arbitrary number written as binary\n    /// @param neg indicates if val is negative or not\n    struct BigInt {\n        bytes val;\n        bool neg;\n    }\n\n    /// @param data filecoin address in bytes format\n    struct FilAddress {\n        bytes data;\n    }\n\n    /// @param data cid in bytes format\n    struct Cid {\n        bytes data;\n    }\n\n    /// @param data deal proposal label in bytes format (it can be utf8 string or arbitrary bytes string).\n    /// @param isString indicates if the data is string or raw bytes\n    struct DealLabel {\n        bytes data;\n        bool isString;\n    }\n\n    type FilActorId is uint64;\n\n    type ChainEpoch is int64;\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/DataCapTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title Filecoin datacap actor types for Solidity.\n/// @author Zondax AG\nlibrary DataCapTypes {\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(7);\n    uint constant NameMethodNum = 48890204;\n    uint constant SymbolMethodNum = 2061153854;\n    uint constant TotalSupplyMethodNum = 114981429;\n    uint constant BalanceOfMethodNum = 3261979605;\n    uint constant TransferMethodNum = 80475954;\n    uint constant TransferFromMethodNum = 3621052141;\n    uint constant IncreaseAllowanceMethodNum = 1777121560;\n    uint constant DecreaseAllowanceMethodNum = 1529376545;\n    uint constant RevokeAllowanceMethodNum = 2765635761;\n    uint constant BurnMethodNum = 1434719642;\n    uint constant BurnFromMethodNum = 2979674018;\n    uint constant AllowanceMethodNum = 4205072950;\n\n    /// @param owner the wallet address of the owner.\n    /// @param operator the wallet address of the owner.\n    struct GetAllowanceParams {\n        CommonTypes.FilAddress owner;\n        CommonTypes.FilAddress operator;\n    }\n\n    /// @param to the address to receive DataCap token.\n    /// @param amount a non-negative amount to transfer.\n    /// @param operator_data Arbitrary data to pass on via the receiver hook.\n    struct TransferParams {\n        CommonTypes.FilAddress to;\n        CommonTypes.BigInt amount;\n        bytes operator_data;\n    }\n\n    /// @param from_balance the balance of from_address.\n    /// @param to_balance the balance of to_address.\n    /// @param recipient_data data returned from receive hook.\n    struct TransferReturn {\n        CommonTypes.BigInt from_balance;\n        CommonTypes.BigInt to_balance;\n        bytes recipient_data;\n    }\n\n    /// @param from the address to send DataCap Token.\n    /// @param to the address to receive DataCap Token.\n    /// @param amount a non-negative amount to transfer.\n    /// @param operator_data arbitrary data to pass on via the receiver hook.\n    struct TransferFromParams {\n        CommonTypes.FilAddress from;\n        CommonTypes.FilAddress to;\n        CommonTypes.BigInt amount;\n        bytes operator_data;\n    }\n\n    /// @param from_balance the balance of from_address.\n    /// @param to_balance the balance of to_address.\n    /// @param allowance the remaining allowance of owner address.\n    /// @param recipient_data data returned from receive hook.\n    struct TransferFromReturn {\n        CommonTypes.BigInt from_balance;\n        CommonTypes.BigInt to_balance;\n        CommonTypes.BigInt allowance;\n        bytes recipient_data;\n    }\n\n    /// @param operator the  wallet address of the operator.\n    /// @param increase increase DataCap token allowance for the operator address.\n    struct IncreaseAllowanceParams {\n        CommonTypes.FilAddress operator;\n        CommonTypes.BigInt increase;\n    }\n\n    /// @param operator the wallet address of the operator.\n    /// @param decrease the decreased DataCap token allowance of the operator address.\n    struct DecreaseAllowanceParams {\n        CommonTypes.FilAddress operator;\n        CommonTypes.BigInt decrease;\n    }\n\n    /// @param owner the wallet address of the owner.\n    /// @param amount the amount of DataCap token to be burned.\n    struct BurnFromParams {\n        CommonTypes.FilAddress owner;\n        CommonTypes.BigInt amount;\n    }\n\n    /// @param balance new balance in the account after the successful burn.\n    /// @param allowance new remaining allowance between the owner and operator (caller)\n    struct BurnFromReturn {\n        CommonTypes.BigInt balance;\n        CommonTypes.BigInt allowance;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(5);\n    uint constant AddBalanceMethodNum = 822473126;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n    uint constant GetBalanceMethodNum = 726108461;\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\n    uint constant GetDealClientMethodNum = 128053329;\n    uint constant GetDealProviderMethodNum = 935081690;\n    uint constant GetDealLabelMethodNum = 46363526;\n    uint constant GetDealTermMethodNum = 163777312;\n    uint constant GetDealTotalPriceMethodNum = 4287162428;\n    uint constant GetDealClientCollateralMethodNum = 200567895;\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\n    uint constant GetDealVerifiedMethodNum = 2627389465;\n    uint constant GetDealActivationMethodNum = 2567238399;\n    uint constant PublishStorageDealsMethodNum = 2236929350;\n\n    /// @param provider_or_client the address of provider or client.\n    /// @param tokenAmount the token amount to withdraw.\n    struct WithdrawBalanceParams {\n        CommonTypes.FilAddress provider_or_client;\n        CommonTypes.BigInt tokenAmount;\n    }\n\n    /// @param balance the escrow balance for this address.\n    /// @param locked the escrow locked amount for this address.\n    struct GetBalanceReturn {\n        CommonTypes.BigInt balance;\n        CommonTypes.BigInt locked;\n    }\n\n    /// @param data the data commitment of this deal.\n    /// @param size the size of this deal.\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    /// @param start the chain epoch to start the deal.\n    /// @param endthe chain epoch to end the deal.\n    struct GetDealTermReturn {\n        CommonTypes.ChainEpoch start;\n        CommonTypes.ChainEpoch end;\n    }\n\n    /// @param activated Epoch at which the deal was activated, or -1.\n    /// @param terminated Epoch at which the deal was terminated abnormally, or -1.\n    struct GetDealActivationReturn {\n        CommonTypes.ChainEpoch activated;\n        CommonTypes.ChainEpoch terminated;\n    }\n\n    /// @param deals list of deal proposals signed by a client\n    struct PublishStorageDealsParams {\n        ClientDealProposal[] deals;\n    }\n\n    /// @param ids returned storage deal IDs.\n    /// @param valid_deals represent all the valid deals.\n    struct PublishStorageDealsReturn {\n        uint64[] ids;\n        bytes valid_deals;\n    }\n\n    /// @param piece_cid PieceCID.\n    /// @param piece_size the size of the piece.\n    /// @param verified_deal if the deal is verified or not.\n    /// @param client the address of the storage client.\n    /// @param provider the address of the storage provider.\n    /// @param label any label that client choose for the deal.\n    /// @param start_epoch the chain epoch to start the deal.\n    /// @param end_epoch the chain epoch to end the deal.\n    /// @param storage_price_per_epoch the token amount to pay to provider per epoch.\n    /// @param provider_collateral the token amount as collateral paid by the provider.\n    /// @param client_collateral the token amount as collateral paid by the client.\n    struct DealProposal {\n        CommonTypes.Cid piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        CommonTypes.FilAddress client;\n        CommonTypes.FilAddress provider;\n        CommonTypes.DealLabel label;\n        CommonTypes.ChainEpoch start_epoch;\n        CommonTypes.ChainEpoch end_epoch;\n        CommonTypes.BigInt storage_price_per_epoch;\n        CommonTypes.BigInt provider_collateral;\n        CommonTypes.BigInt client_collateral;\n    }\n\n    /// @param proposal Proposal\n    /// @param client_signature the signature signed by the client.\n    struct ClientDealProposal {\n        DealProposal proposal;\n        bytes client_signature;\n    }\n\n    struct MarketDealNotifyParams {\n        bytes dealProposal;\n        uint64 dealId;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/MinerTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin miner actor types for Solidity.\n/// @author Zondax AG\nlibrary MinerTypes {\n    uint constant GetOwnerMethodNum = 3275365574;\n    uint constant ChangeOwnerAddressMethodNum = 1010589339;\n    uint constant IsControllingAddressMethodNum = 348244887;\n    uint constant GetSectorSizeMethodNum = 3858292296;\n    uint constant GetAvailableBalanceMethodNum = 4026106874;\n    uint constant GetVestingFundsMethodNum = 1726876304;\n    uint constant ChangeBeneficiaryMethodNum = 1570634796;\n    uint constant GetBeneficiaryMethodNum = 4158972569;\n    uint constant ChangeWorkerAddressMethodNum = 3302309124;\n    uint constant ChangePeerIDMethodNum = 1236548004;\n    uint constant ChangeMultiaddrsMethodNum = 1063480576;\n    uint constant RepayDebtMethodNum = 3665352697;\n    uint constant ConfirmChangeWorkerAddressMethodNum = 2354970453;\n    uint constant GetPeerIDMethodNum = 2812875329;\n    uint constant GetMultiaddrsMethodNum = 1332909407;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n\n    /// @param owner owner address.\n    /// @param proposed owner address.\n    struct GetOwnerReturn {\n        CommonTypes.FilAddress owner;\n        CommonTypes.FilAddress proposed;\n    }\n\n    /// @param vesting_funds funds\n    struct GetVestingFundsReturn {\n        VestingFunds[] vesting_funds;\n    }\n\n    /// @param new_beneficiary the new beneficiary address.\n    /// @param new_quota the new quota token amount.\n    /// @param new_expiration the epoch that the new quota will be expired.\n    struct ChangeBeneficiaryParams {\n        CommonTypes.FilAddress new_beneficiary;\n        CommonTypes.BigInt new_quota;\n        CommonTypes.ChainEpoch new_expiration;\n    }\n\n    /// @param active current active beneficiary.\n    /// @param proposed the proposed and pending beneficiary.\n    struct GetBeneficiaryReturn {\n        ActiveBeneficiary active;\n        PendingBeneficiaryChange proposed;\n    }\n\n    /// @param new_worker the new worker address.\n    /// @param new_control_addresses the new controller addresses.\n    struct ChangeWorkerAddressParams {\n        CommonTypes.FilAddress new_worker;\n        CommonTypes.FilAddress[] new_control_addresses;\n    }\n\n    /// @param new_multi_addrs the new multi-signature address.\n    struct ChangeMultiaddrsParams {\n        CommonTypes.FilAddress[] new_multi_addrs;\n    }\n\n    /// @param multi_addrs the multi-signature address.\n    struct GetMultiaddrsReturn {\n        CommonTypes.FilAddress[] multi_addrs;\n    }\n\n    /// @param epoch the epoch of funds vested.\n    /// @param amount the amount of funds vested.\n    struct VestingFunds {\n        CommonTypes.ChainEpoch epoch;\n        CommonTypes.BigInt amount;\n    }\n\n    /// @param quota the quota token amount.\n    /// @param used_quota the used quota token amount.\n    /// @param expiration the epoch that the quota will be expired.\n    struct BeneficiaryTerm {\n        CommonTypes.BigInt quota;\n        CommonTypes.BigInt used_quota;\n        CommonTypes.ChainEpoch expiration;\n    }\n\n    /// @param beneficiary the address of the beneficiary.\n    /// @param term BeneficiaryTerm\n    struct ActiveBeneficiary {\n        CommonTypes.FilAddress beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    /// @param new_beneficiary the new beneficiary address.\n    /// @param new_quota the new quota token amount.\n    /// @param new_expiration the epoch that the new quota will be expired.\n    /// @param approved_by_beneficiary if this proposal is approved by beneficiary or not.\n    /// @param approved_by_nominee if this proposal is approved by nominee or not.\n    struct PendingBeneficiaryChange {\n        CommonTypes.FilAddress new_beneficiary;\n        CommonTypes.BigInt new_quota;\n        CommonTypes.ChainEpoch new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/PowerTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin power actor types for Solidity.\n/// @author Zondax AG\nlibrary PowerTypes {\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(4);\n    uint constant CreateMinerMethodNum = 1173380165;\n    uint constant MinerCountMethodNum = 1987646258;\n    uint constant MinerConsensusCountMethodNum = 196739875;\n    uint constant NetworkRawPowerMethodNum = 931722534;\n    uint constant MinerRawPowerMethodNum = 3753401894;\n\n    /// @param ownerthe address of the owner.\n    /// @param worker the address of the worker.\n    /// @param window_post_proof_type the type of RegisteredPoStProof.\n    /// @param peer peer ID.\n    /// @param multiaddrs the multi-address which is used to control new created miner.\n    struct CreateMinerParams {\n        CommonTypes.FilAddress owner;\n        CommonTypes.FilAddress worker;\n        RegisteredPoStProof window_post_proof_type;\n        CommonTypes.FilAddress peer;\n        CommonTypes.FilAddress[] multiaddrs;\n    }\n\n    /// @param id_address the canonical ID-based address for the actor.\n    /// @param robust_address a more expensive but re-org-safe address for the newly created actor.\n    struct CreateMinerReturn {\n        /// Canonical ID-based address for the actor.\n        CommonTypes.FilAddress id_address;\n        /// Re-org safe address for created actor.\n        CommonTypes.FilAddress robust_address;\n    }\n\n    /// @param raw_byte_power the row power of the miner.\n    /// @param meets_consensus_minimum if the miner power meets the minimum for consensus.\n    struct MinerRawPowerReturn {\n        CommonTypes.BigInt raw_byte_power;\n        bool meets_consensus_minimum;\n    }\n\n    /// @notice the type of RegisteredPoStProof.\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/types/VerifRegTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin Verified Registry actor types for Solidity.\n/// @author Zondax AG\nlibrary VerifRegTypes {\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(6);\n    uint constant GetClaimsMethodNum = 2199871187;\n    uint constant AddVerifiedClientMethodNum = 3916220144;\n    uint constant RemoveExpiredAllocationsMethodNum = 2421068268;\n    uint constant ExtendClaimTermsMethodNum = 1752273514;\n    uint constant RemoveExpiredClaimsMethodNum = 2873373899;\n\n    /// @param provider the provider address.\n    /// @param  claim_ids a list of Claim IDs for specific provider.\n    struct GetClaimsParams {\n        CommonTypes.FilActorId provider;\n        CommonTypes.FilActorId[] claim_ids;\n    }\n\n    /// @param  claims list of Claims returned.\n    /// @param  batch_info total success and failures of the batch process\n    struct GetClaimsReturn {\n        CommonTypes.BatchReturn batch_info;\n        Claim[] claims;\n    }\n\n    /// @param addr the verified client address\n    /// @param allowance approved DataCap for this verified client\n    struct AddVerifiedClientParams {\n        CommonTypes.FilAddress addr;\n        CommonTypes.BigInt allowance;\n    }\n\n    /// @param client the client address for which to expired allocations.\n    /// @param allocation_ids list of allocation IDs to attempt to remove. If empty, will remove all eligible expired allocations.\n    struct RemoveExpiredAllocationsParams {\n        CommonTypes.FilActorId client;\n        CommonTypes.FilActorId[] allocation_ids;\n    }\n\n    /// @param considered Allocation IDs are either specified by the caller or discovered to be expired.\n    /// @param results results for each processed allocation.\n    /// @param datacap_recovered the amount of DataCap token reclaimed for the client.\n    struct RemoveExpiredAllocationsReturn {\n        CommonTypes.FilActorId[] considered;\n        CommonTypes.BatchReturn results;\n        CommonTypes.BigInt datacap_recovered;\n    }\n\n    /// @param provider the provider address (need not be the caller)\n    /// @param claim_ids a list of Claim IDs with expired term. If no claims are specified, all eligible claims will be removed.\n    struct RemoveExpiredClaimsParams {\n        CommonTypes.FilActorId provider;\n        CommonTypes.FilActorId[] claim_ids;\n    }\n\n    /// @param considered a list of IDs of the claims that were either specified by the caller or discovered to be expired.\n    /// @param results results for each processed claim.\n    struct RemoveExpiredClaimsReturn {\n        CommonTypes.FilActorId[] considered;\n        CommonTypes.BatchReturn results;\n    }\n\n    /// @param terms list of claim terms to extend\n    struct ExtendClaimTermsParams {\n        ClaimTerm[] terms;\n    }\n\n    /// @param provider the provider address which storing the data.\n    /// @param claim_id claim ID.\n    /// @param term_max the max chain epoch to extend.\n    struct ClaimTerm {\n        CommonTypes.FilActorId provider;\n        CommonTypes.FilActorId claim_id;\n        CommonTypes.ChainEpoch term_max;\n    }\n\n    /// @param provider the provider storing the data.\n    /// @param client the client which allocated the DataCap.\n    /// @param data identifier for the data committed.\n    /// @param size the size of the data.\n    /// @param term_min the min period after term started which the provider must commit to storing data.\n    /// @param term_max the max period after term started for which the provider can earn QA-power for the data.\n    /// @param term_start the epoch at which the piece was committed.\n    /// @param sector ID of the provider's sector in which the data is committed.\n    struct Claim {\n        CommonTypes.FilActorId provider;\n        CommonTypes.FilActorId client;\n        bytes data;\n        uint64 size;\n        CommonTypes.ChainEpoch term_min;\n        CommonTypes.ChainEpoch term_max;\n        CommonTypes.ChainEpoch term_start;\n        CommonTypes.FilActorId sector;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/Utils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./cbor/AccountCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./cbor/FilecoinCbor.sol\";\n\nimport \"./types/AccountTypes.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./types/DataCapTypes.sol\";\n\nimport \"./utils/Actor.sol\";\n\n/// @title This library compiles a bunch of helper functions.\n/// @author Zondax AG\nlibrary Utils {\n    using AccountCBOR for *;\n    using FilecoinCBOR for *;\n    using BytesCBOR for bytes;\n\n    /// @notice the codec received is not valid\n    error InvalidCodec(uint64);\n\n    /// @notice filecoin method not handled\n    error MethodNotHandled(uint64);\n\n    /// @notice utility function meant to handle calls from other builtin actors. Arguments are passed as cbor serialized data (in filecoin native format)\n    /// @param method the filecoin method id that is being called\n    /// @param params raw data (in bytes) passed as arguments to the method call\n    function handleFilecoinMethod(uint64 method, uint64 codec, bytes calldata params) internal pure returns (CommonTypes.UniversalReceiverParams memory) {\n        if (method == CommonTypes.UniversalReceiverHookMethodNum) {\n            if (codec != Misc.CBOR_CODEC) {\n                revert InvalidCodec(codec);\n            }\n\n            return params.deserializeUniversalReceiverParams();\n        } else {\n            revert MethodNotHandled(method);\n        }\n    }\n\n    /// @param target The actor id you want to interact with\n    function universalReceiverHook(CommonTypes.FilActorId target, CommonTypes.UniversalReceiverParams memory params) internal returns (bytes memory) {\n        bytes memory raw_request = params.serializeUniversalReceiverParams();\n\n        bytes memory result = Actor.callByID(target, CommonTypes.UniversalReceiverHookMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/Actor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./Misc.sol\";\nimport \"../types/CommonTypes.sol\";\n\n/// @title Call actors utilities library, meant to interact with Filecoin builtin actors\n/// @author Zondax AG\nlibrary Actor {\n    /// @notice precompile address for the call_actor precompile\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\n\n    /// @notice precompile address for the call_actor_id precompile\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\n\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a static_call to the desired actor\n    uint64 constant READ_ONLY_FLAG = 0x00000001;\n\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a call to the desired actor\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    /// @notice the provided address is not valid\n    error InvalidAddress(bytes addr);\n\n    /// @notice the smart contract has no enough balance to transfer\n    error NotEnoughBalance(uint256 balance, uint256 value);\n\n    /// @notice the provided actor id is not valid\n    error InvalidActorID(CommonTypes.FilActorId actorId);\n\n    /// @notice an error happened trying to call the actor\n    error FailToCallActor();\n\n    /// @notice the response received is not correct. In some case no response is expected and we received one, or a response was indeed expected and we received none.\n    error InvalidResponseLength();\n\n    /// @notice the codec received is not valid\n    error InvalidCodec(uint64);\n\n    /// @notice the called actor returned an error as part of its expected behaviour\n    error ActorError(int256 errorCode);\n\n    /// @notice the actor is not found\n    error ActorNotFound();\n\n    /// @notice allows to interact with an specific actor by its address (bytes format)\n    /// @param actor_address actor address (bytes format) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transferred to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\n    function callByAddress(\n        bytes memory actor_address,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        if (actor_address.length < 2) {\n            revert InvalidAddress(actor_address);\n        }\n\n        validatePrecompileCall(CALL_ACTOR_ADDRESS, value);\n\n        // We have to delegate-call the call-actor precompile because the call-actor precompile will\n        // call the target actor on our behalf. This will _not_ delegate to the target `actor_address`.\n        //\n        // Specifically:\n        //\n        // - `static_call == false`: `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(CALL)-> actor_address\n        // - `static_call == true`:  `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(STATICCALL)-> actor_address\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, actor_address)\n        );\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        return readRespData(data);\n    }\n\n    /// @notice allows to interact with an specific actor by its id (uint64)\n    /// @param target actor id (uint64) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transferred to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\n    function callByID(\n        CommonTypes.FilActorId target,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        validatePrecompileCall(CALL_ACTOR_ID, value);\n\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, target)\n        );\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        return readRespData(data);\n    }\n\n    /// @notice allows to run some generic validations before calling the precompile actor\n    /// @param addr precompile actor address to run check to\n    /// @param value tokens to be transferred to the called actor\n    function validatePrecompileCall(address addr, uint256 value) internal view {\n        uint balance = address(this).balance;\n        if (balance < value) {\n            revert NotEnoughBalance(balance, value);\n        }\n\n        bool actorExists = Misc.addressExists(addr);\n        if (!actorExists) {\n            revert ActorNotFound();\n        }\n    }\n\n    /// @notice allows to interact with an non-singleton actors by its id (uint64)\n    /// @param target actor id (uint64) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transfered to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @dev it requires the id to be bigger than 99, as singleton actors are smaller than that\n    function callNonSingletonByID(\n        CommonTypes.FilActorId target,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        if (CommonTypes.FilActorId.unwrap(target) < 100) {\n            revert InvalidActorID(target);\n        }\n\n        return callByID(target, method_num, codec, raw_request, value, static_call);\n    }\n\n    /// @notice parse the response an actor returned\n    /// @notice it will validate the return code (success) and the codec (valid one)\n    /// @param raw_response raw data (bytes) the actor returned\n    /// @return the actual raw data (payload, in bytes) to be parsed according to the actor and method called\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(raw_response, (int256, uint64, bytes));\n\n        if (return_codec == Misc.NONE_CODEC) {\n            if (return_value.length != 0) {\n                revert InvalidResponseLength();\n            }\n        } else if (return_codec == Misc.CBOR_CODEC || return_codec == Misc.DAG_CBOR_CODEC) {\n            if (return_value.length == 0) {\n                revert InvalidResponseLength();\n            }\n        } else {\n            revert InvalidCodec(return_codec);\n        }\n\n        if (exit != 0) {\n            revert ActorError(exit);\n        }\n\n        return return_value;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/BigInts.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"src/v0.8/vendor/solidity-bignumber/src/BigNumbers.sol\";\n\nimport \"../types/CommonTypes.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @notice This library is a set a functions that allows to handle filecoin addresses conversions and validations\n/// @author Zondax AG\nlibrary BigInts {\n    uint256 constant MAX_UINT = (2 ** 256) - 1;\n    uint256 constant MAX_INT = ((2 ** 256) / 2) - 1;\n\n    error NegativeValueNotAllowed();\n\n    /// @notice allow to get a BigInt from a uint256 value\n    /// @param value uint256 number\n    /// @return new BigInt\n    function fromUint256(\n        uint256 value\n    ) internal view returns (CommonTypes.BigInt memory) {\n        BigNumber memory bigNum = BigNumbers.init(value, false);\n        return CommonTypes.BigInt(bigNum.val, bigNum.neg);\n    }\n\n    /// @notice allow to get a BigInt from a int256 value\n    /// @param value int256 number\n    /// @return new BigInt\n    function fromInt256(\n        int256 value\n    ) internal view returns (CommonTypes.BigInt memory) {\n        uint256 valueAbs = Misc.abs(value);\n        BigNumber memory bigNum = BigNumbers.init(valueAbs, value < 0);\n        return CommonTypes.BigInt(bigNum.val, bigNum.neg);\n    }\n\n    /// @notice allow to get a uint256 from a BigInt value.\n    /// @notice If the value is negative, it will generate an error.\n    /// @param value BigInt number\n    /// @return a uint256 value and flog that indicates whether it was possible to convert or not (the value overflows uint256 type)\n    function toUint256(\n        CommonTypes.BigInt memory value\n    ) internal view returns (uint256, bool) {\n        if (value.neg) {\n            revert NegativeValueNotAllowed();\n        }\n\n        BigNumber memory max = BigNumbers.init(MAX_UINT, false);\n        BigNumber memory bigNumValue = BigNumbers.init(value.val, value.neg);\n        if (BigNumbers.gt(bigNumValue, max)) {\n            return (0, true);\n        }\n\n        return (uint256(bytes32(bigNumValue.val)), false);\n    }\n\n    /// @notice allow to get a int256 from a BigInt value.\n    /// @notice If the value is grater than what a int256 can store, it will generate an error.\n    /// @param value BigInt number\n    /// @return a int256 value and flog that indicates whether it was possible to convert or not (the value overflows int256 type)\n    function toInt256(\n        CommonTypes.BigInt memory value\n    ) internal view returns (int256, bool) {\n        BigNumber memory max = BigNumbers.init(MAX_INT, false);\n        BigNumber memory bigNumValue = BigNumbers.init(value.val, false);\n        if (BigNumbers.gt(bigNumValue, max)) {\n            return (0, true);\n        }\n\n        int256 parsedValue = int256(uint256(bytes32(bigNumValue.val)));\n        return (value.neg ? -1 * parsedValue : parsedValue, false);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\n// \tMajUnsignedInt = 0\n// \tMajSignedInt   = 1\n// \tMajByteString  = 2\n// \tMajTextString  = 3\n// \tMajArray       = 4\n// \tMajMap         = 5\n// \tMajTag         = 6\n// \tMajOther       = 7\n\nuint8 constant MajUnsignedInt = 0;\nuint8 constant MajSignedInt = 1;\nuint8 constant MajByteString = 2;\nuint8 constant MajTextString = 3;\nuint8 constant MajArray = 4;\nuint8 constant MajMap = 5;\nuint8 constant MajTag = 6;\nuint8 constant MajOther = 7;\n\nuint8 constant TagTypeBigNum = 2;\nuint8 constant TagTypeNegativeBigNum = 3;\n\nuint8 constant True_Type = 21;\nuint8 constant False_Type = 20;\n\n/// @notice This library is a set a functions that allows anyone to decode cbor encoded bytes\n/// @dev methods in this library try to read the data type indicated from cbor encoded data stored in bytes at a specific index\n/// @dev if it successes, methods will return the read value and the new index (intial index plus read bytes)\n/// @author Zondax AG\nlibrary CBORDecoder {\n    /// @notice check if next value on the cbor encoded data is null\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    function isNullNext(bytes memory cborData, uint byteIdx) internal pure returns (bool) {\n        return cborData[byteIdx] == hex\"f6\";\n    }\n\n    /// @notice attempt to read a bool value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a bool decoded from input bytes and the byte index after moving past the value\n    function readBool(bytes memory cborData, uint byteIdx) internal pure returns (bool, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajOther, \"invalid maj (expected MajOther)\");\n        assert(value == True_Type || value == False_Type);\n\n        return (value != False_Type, byteIdx);\n    }\n\n    /// @notice attempt to read the length of a fixed array\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return length of the fixed array decoded from input bytes and the byte index after moving past the value\n    function readFixedArray(bytes memory cborData, uint byteIdx) internal pure returns (uint, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajArray, \"invalid maj (expected MajArray)\");\n\n        return (len, byteIdx);\n    }\n\n    /// @notice attempt to read an arbitrary length string value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return arbitrary length string decoded from input bytes and the byte index after moving past the value\n    function readString(bytes memory cborData, uint byteIdx) internal pure returns (string memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTextString, \"invalid maj (expected MajTextString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (string(slice), byteIdx + len);\n    }\n\n    /// @notice attempt to read an arbitrary byte string value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return arbitrary byte string decoded from input bytes and the byte index after moving past the value\n    function readBytes(bytes memory cborData, uint byteIdx) internal pure returns (bytes memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajByteString, \"invalid maj (expected MajTag or MajByteString)\");\n\n        if (maj == MajTag) {\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            assert(maj == MajByteString);\n        }\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (slice, byteIdx + len);\n    }\n\n    /// @notice attempt to read a bytes32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a bytes32 decoded from input bytes and the byte index after moving past the value\n    function readBytes32(bytes memory cborData, uint byteIdx) internal pure returns (bytes32, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(32);\n        uint slice_index = 32 - len;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (bytes32(slice), byteIdx + len);\n    }\n\n    /// @notice attempt to read a uint256 value encoded per cbor specification\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint256 decoded from input bytes and the byte index after moving past the value\n    function readUInt256(bytes memory cborData, uint byteIdx) internal pure returns (uint256, uint) {\n        uint8 maj;\n        uint256 value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajUnsignedInt, \"invalid maj (expected MajTag or MajUnsignedInt)\");\n\n        if (maj == MajTag) {\n            require(value == TagTypeBigNum, \"invalid tag (expected TagTypeBigNum)\");\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n            require(cborData.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborData, add(len, byteIdx)))\n            }\n\n            return (value, byteIdx + len);\n        }\n\n        return (value, byteIdx);\n    }\n\n    /// @notice attempt to read a int256 value encoded per cbor specification\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int256 decoded from input bytes and the byte index after moving past the value\n    function readInt256(bytes memory cborData, uint byteIdx) internal pure returns (int256, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajSignedInt, \"invalid maj (expected MajTag or MajSignedInt)\");\n\n        if (maj == MajTag) {\n            assert(value == TagTypeNegativeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n            require(cborData.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborData, add(len, byteIdx)))\n            }\n\n            return (int256(value), byteIdx + len);\n        }\n\n        return (int256(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint64 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint64 decoded from input bytes and the byte index after moving past the value\n    function readUInt64(bytes memory cborData, uint byteIdx) internal pure returns (uint64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint64(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint32 decoded from input bytes and the byte index after moving past the value\n    function readUInt32(bytes memory cborData, uint byteIdx) internal pure returns (uint32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint32(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint16 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint16 decoded from input bytes and the byte index after moving past the value\n    function readUInt16(bytes memory cborData, uint byteIdx) internal pure returns (uint16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint16(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint8 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint8 decoded from input bytes and the byte index after moving past the value\n    function readUInt8(bytes memory cborData, uint byteIdx) internal pure returns (uint8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint8(value), byteIdx);\n    }\n\n    /// @notice attempt to read a int64 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int64 decoded from input bytes and the byte index after moving past the value\n    function readInt64(bytes memory cborData, uint byteIdx) internal pure returns (int64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int64(uint64(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int32 decoded from input bytes and the byte index after moving past the value\n    function readInt32(bytes memory cborData, uint byteIdx) internal pure returns (int32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int32(uint32(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int16 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int16 decoded from input bytes and the byte index after moving past the value\n    function readInt16(bytes memory cborData, uint byteIdx) internal pure returns (int16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int16(uint16(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int8 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int8 decoded from input bytes and the byte index after moving past the value\n    function readInt8(bytes memory cborData, uint byteIdx) internal pure returns (int8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int8(uint8(value)), byteIdx);\n    }\n\n    /// @notice slice uint8 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint8 sliced from bytes\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\n        require(bs.length >= start + 1, \"slicing out of range\");\n        return uint8(bs[start]);\n    }\n\n    /// @notice slice uint16 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint16 sliced from bytes\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\n        require(bs.length >= start + 2, \"slicing out of range\");\n        bytes2 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint16(x);\n    }\n\n    /// @notice slice uint32 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint32 sliced from bytes\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\n        require(bs.length >= start + 4, \"slicing out of range\");\n        bytes4 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint32(x);\n    }\n\n    /// @notice slice uint64 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint64 sliced from bytes\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\n        require(bs.length >= start + 8, \"slicing out of range\");\n        bytes8 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint64(x);\n    }\n\n    /// @notice Parse cbor header for major type and extra info.\n    /// @param cbor cbor encoded bytes to parse from\n    /// @param byteIndex current position to read on the cbor encoded bytes\n    /// @return major type, extra info and the byte index after moving past header bytes\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\n        uint8 first = sliceUInt8(cbor, byteIndex);\n        byteIndex += 1;\n        uint8 maj = (first & 0xe0) >> 5;\n        uint8 low = first & 0x1f;\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\n        require(low < 28, \"cannot handle headers with extra > 27\");\n\n        // extra is lower bits\n        if (low < 24) {\n            return (maj, low, byteIndex);\n        }\n\n        // extra in next byte\n        if (low == 24) {\n            uint8 next = sliceUInt8(cbor, byteIndex);\n            byteIndex += 1;\n            require(next >= 24, \"invalid cbor\"); // otherwise this is invalid cbor\n            return (maj, next, byteIndex);\n        }\n\n        // extra in next 2 bytes\n        if (low == 25) {\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\n            byteIndex += 2;\n            return (maj, extra16, byteIndex);\n        }\n\n        // extra in next 4 bytes\n        if (low == 26) {\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\n            byteIndex += 4;\n            return (maj, extra32, byteIndex);\n        }\n\n        // extra in next 8 bytes\n        assert(low == 27);\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\n        byteIndex += 8;\n        return (maj, extra64, byteIndex);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This library is a set a functions that allows to handle filecoin addresses conversions and validations\n/// @author Zondax AG\nlibrary FilAddresses {\n    using Buffer for Buffer.buffer;\n\n    error InvalidAddress();\n\n    /// @notice allow to get a FilAddress from an eth address\n    /// @param addr eth address to convert\n    /// @return new filecoin address\n    function fromEthAddress(address addr) internal pure returns (CommonTypes.FilAddress memory) {\n        return CommonTypes.FilAddress(abi.encodePacked(hex\"040a\", addr));\n    }\n\n    /// @notice allow to create a Filecoin address from an actorID\n    /// @param actorID uint64 actorID\n    /// @return address filecoin address\n    function fromActorID(uint64 actorID) internal pure returns (CommonTypes.FilAddress memory) {\n        Buffer.buffer memory result = Leb128.encodeUnsignedLeb128FromUInt64(actorID);\n        return CommonTypes.FilAddress(abi.encodePacked(hex\"00\", result.buf));\n    }\n\n    /// @notice allow to create a Filecoin address from bytes\n    /// @param data address in bytes format\n    /// @return filecoin address\n    function fromBytes(bytes memory data) internal pure returns (CommonTypes.FilAddress memory) {\n        CommonTypes.FilAddress memory newAddr = CommonTypes.FilAddress(data);\n        if (!validate(newAddr)) {\n            revert InvalidAddress();\n        }\n\n        return newAddr;\n    }\n\n    /// @notice allow to validate if an address is valid or not\n    /// @dev we are only validating known address types. If the type is not known, the default value is true\n    /// @param addr the filecoin address to validate\n    /// @return whether the address is valid or not\n    function validate(CommonTypes.FilAddress memory addr) internal pure returns (bool) {\n        if (addr.data[0] == 0x00) {\n            return addr.data.length <= 10;\n        } else if (addr.data[0] == 0x01 || addr.data[0] == 0x02) {\n            return addr.data.length == 21;\n        } else if (addr.data[0] == 0x03) {\n            return addr.data.length == 49;\n        } else if (addr.data[0] == 0x04) {\n            return addr.data.length <= 64;\n        }\n\n        return addr.data.length <= 256;\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/Leb128.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This library implement the leb128\n/// @author Zondax AG\nlibrary Leb128 {\n    using Buffer for Buffer.buffer;\n\n    /// @notice encode a unsigned integer 64bits into bytes\n    /// @param value the actor ID to encode\n    /// @return result return the value in bytes\n    function encodeUnsignedLeb128FromUInt64(uint64 value) internal pure returns (Buffer.buffer memory result) {\n        while (true) {\n            uint64 byte_ = value & 0x7f;\n            value >>= 7;\n            if (value == 0) {\n                result.appendUint8(uint8(byte_));\n                return result;\n            }\n            result.appendUint8(uint8(byte_ | 0x80));\n        }\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/utils/Misc.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\n\n/// @title Library containing miscellaneous functions used on the project\n/// @author Zondax AG\nlibrary Misc {\n    uint64 constant DAG_CBOR_CODEC = 0x71;\n    uint64 constant CBOR_CODEC = 0x51;\n    uint64 constant NONE_CODEC = 0x00;\n\n    // Code taken from Openzeppelin repo\n    // Link: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0320a718e8e07b1d932f5acb8ad9cec9d9eed99b/contracts/utils/math/SignedMath.sol#L37-L42\n    /// @notice get the abs from a signed number\n    /// @param n number to get abs from\n    /// @return unsigned number\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n\n    /// @notice validate if an address exists or not\n    /// @dev read this article for more information https://blog.finxter.com/how-to-find-out-if-an-ethereum-address-is-a-contract/\n    /// @param addr address to check\n    /// @return whether the address exists or not\n    function addressExists(address addr) internal view returns (bool) {\n        bytes32 codehash;\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return codehash != 0x0;\n    }\n\n    /// Returns the data size required by CBOR.writeFixedNumeric\n    function getPrefixSize(uint256 data_size) internal pure returns (uint256) {\n        if (data_size <= 23) {\n            return 1;\n        } else if (data_size <= 0xFF) {\n            return 2;\n        } else if (data_size <= 0xFFFF) {\n            return 3;\n        } else if (data_size <= 0xFFFFFFFF) {\n            return 5;\n        }\n        return 9;\n    }\n\n    function getBytesSize(bytes memory value) internal pure returns (uint256) {\n        return getPrefixSize(value.length) + value.length;\n    }\n\n    function getCidSize(bytes memory value) internal pure returns (uint256) {\n        return getPrefixSize(2) + value.length;\n    }\n\n    function getFilActorIdSize(CommonTypes.FilActorId value) internal pure returns (uint256) {\n        uint64 val = CommonTypes.FilActorId.unwrap(value);\n        return getPrefixSize(uint256(val));\n    }\n\n    function getChainEpochSize(CommonTypes.ChainEpoch value) internal pure returns (uint256) {\n        int64 val = CommonTypes.ChainEpoch.unwrap(value);\n        if (val >= 0) {\n            return getPrefixSize(uint256(uint64(val)));\n        } else {\n            return getPrefixSize(uint256(uint64(-1 - val)));\n        }\n    }\n\n    function getBoolSize() internal pure returns (uint256) {\n        return getPrefixSize(1);\n    }\n}\n"
    },
    "src/v0.8/vendor/filecoin-solidity/contracts/v0.8/VerifRegAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/VerifRegTypes.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./cbor/VerifRegCbor.sol\";\n\nimport \"./utils/Actor.sol\";\nimport \"./Utils.sol\";\n\n/// @title This library is a proxy to a built-in VerifReg actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary VerifRegAPI {\n    using VerifRegCBOR for *;\n\n    /// @notice get a list of claims corresponding to the requested claim ID for specific provider.\n    function getClaims(VerifRegTypes.GetClaimsParams memory params) internal returns (VerifRegTypes.GetClaimsReturn memory) {\n        bytes memory raw_request = params.serializeGetClaimsParams();\n\n        bytes memory result = Actor.callByID(VerifRegTypes.ActorID, VerifRegTypes.GetClaimsMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetClaimsReturn();\n    }\n\n    /// @notice add a verified Client address to Filecoin Plus program.\n    function addVerifiedClient(VerifRegTypes.AddVerifiedClientParams memory params) internal {\n        bytes memory raw_request = params.serializeAddVerifiedClientParams();\n\n        bytes memory result = Actor.callByID(VerifRegTypes.ActorID, VerifRegTypes.AddVerifiedClientMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n        if (result.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @notice remove the expired DataCap allocations and reclaimed those DataCap token back to Client. If the allocation amount is not specified, all expired DataCap allocation will be removed.\n    function removeExpiredAllocations(\n        VerifRegTypes.RemoveExpiredAllocationsParams memory params\n    ) internal returns (VerifRegTypes.RemoveExpiredAllocationsReturn memory) {\n        bytes memory raw_request = params.serializeRemoveExpiredAllocationsParams();\n\n        bytes memory result = Actor.callByID(VerifRegTypes.ActorID, VerifRegTypes.RemoveExpiredAllocationsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeRemoveExpiredAllocationsReturn();\n    }\n\n    /// @notice extends the  maximum term of some claims up to the largest value they could have been originally allocated. This method can only be called by the claims' client.\n    function extendClaimTerms(VerifRegTypes.ExtendClaimTermsParams memory params) internal returns (CommonTypes.BatchReturn memory) {\n        bytes memory raw_request = params.serializeExtendClaimTermsParams();\n\n        bytes memory result = Actor.callByID(VerifRegTypes.ActorID, VerifRegTypes.ExtendClaimTermsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBatchReturn();\n    }\n\n    /// @notice remove a claim with its maximum term has elapsed.\n    function removeExpiredClaims(VerifRegTypes.RemoveExpiredClaimsParams memory params) internal returns (VerifRegTypes.RemoveExpiredClaimsReturn memory) {\n        bytes memory raw_request = params.serializeRemoveExpiredClaimsParams();\n\n        bytes memory result = Actor.callByID(VerifRegTypes.ActorID, VerifRegTypes.RemoveExpiredClaimsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeRemoveExpiredClaimsReturn();\n    }\n}\n"
    },
    "src/v0.8/vendor/solidity-bignumber/src/BigNumbers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Definition here allows both the lib and inheriting contracts to use BigNumber directly.\nstruct BigNumber { \n    bytes val;\n    bool neg;\n    uint bitlen;\n}\n\n/**\n * @notice BigNumbers library for Solidity.\n */\nlibrary BigNumbers {\n    \n    /// @notice the value for number 0 of a BigNumber instance.\n    bytes constant ZERO = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    /// @notice the value for number 1 of a BigNumber instance.\n    bytes constant  ONE = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n    /// @notice the value for number 2 of a BigNumber instance.\n    bytes constant  TWO = hex\"0000000000000000000000000000000000000000000000000000000000000002\";\n\n    // ***************** BEGIN EXPOSED MANAGEMENT FUNCTIONS ******************\n    /** @notice verify a BN instance\n     *  @dev checks if the BN is in the correct format. operations should only be carried out on\n     *       verified BNs, so it is necessary to call this if your function takes an arbitrary BN\n     *       as input.\n     *\n     *  @param bn BigNumber instance\n     */\n    function verify(\n        BigNumber memory bn\n    ) internal pure {\n        uint msword; \n        bytes memory val = bn.val;\n        assembly {msword := mload(add(val,0x20))} //get msword of result\n        if(msword==0) require(isZero(bn));\n        else require((bn.val.length % 32 == 0) && (msword>>((bn.bitlen%256)-1)==1));\n    }\n\n    /** @notice initialize a BN instance\n     *  @dev wrapper function for _init. initializes from bytes value.\n     *       Allows passing bitLength of value. This is NOT verified in the internal function. Only use where bitlen is\n     *       explicitly known; otherwise use the other init function.\n     *\n     *  @param val BN value. may be of any size.\n     *  @param neg neg whether the BN is +/-\n     *  @param bitlen bit length of output.\n     *  @return BigNumber instance\n     */\n    function init(\n        bytes memory val, \n        bool neg, \n        uint bitlen\n    ) internal view returns(BigNumber memory){\n        return _init(val, neg, bitlen);\n    }\n    \n    /** @notice initialize a BN instance\n     *  @dev wrapper function for _init. initializes from bytes value.\n     *\n     *  @param val BN value. may be of any size.\n     *  @param neg neg whether the BN is +/-\n     *  @return BigNumber instance\n     */\n    function init(\n        bytes memory val, \n        bool neg\n    ) internal view returns(BigNumber memory){\n        return _init(val, neg, 0);\n    }\n\n    /** @notice initialize a BN instance\n     *  @dev wrapper function for _init. initializes from uint value (converts to bytes); \n     *       tf. resulting BN is in the range -2^256-1 ... 2^256-1.\n     *\n     *  @param val uint value.\n     *  @param neg neg whether the BN is +/-\n     *  @return BigNumber instance\n     */\n    function init(\n        uint val, \n        bool neg\n    ) internal view returns(BigNumber memory){\n        return _init(abi.encodePacked(val), neg, 0);\n    }\n    // ***************** END EXPOSED MANAGEMENT FUNCTIONS ******************\n\n\n\n\n    // ***************** BEGIN EXPOSED CORE CALCULATION FUNCTIONS ******************\n    /** @notice BigNumber addition: a + b.\n      * @dev add: Initially prepare BigNumbers for addition operation; internally calls actual addition/subtraction,\n      *           depending on inputs.\n      *           In order to do correct addition or subtraction we have to handle the sign.\n      *           This function discovers the sign of the result based on the inputs, and calls the correct operation.\n      *\n      * @param a first BN\n      * @param b second BN\n      * @return r result  - addition of a and b.\n      */\n    function add(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(BigNumber memory r) {\n        if(a.bitlen==0 && b.bitlen==0) return zero();\n        if(a.bitlen==0) return b;\n        if(b.bitlen==0) return a;\n        bytes memory val;\n        uint bitlen;\n        int compare = cmp(a,b,false);\n\n        if(a.neg || b.neg){\n            if(a.neg && b.neg){\n                if(compare>=0) (val, bitlen) = _add(a.val,b.val,a.bitlen);\n                else (val, bitlen) = _add(b.val,a.val,b.bitlen);\n                r.neg = true;\n            }\n            else {\n                if(compare==1){\n                    (val, bitlen) = _sub(a.val,b.val);\n                    r.neg = a.neg;\n                }\n                else if(compare==-1){\n                    (val, bitlen) = _sub(b.val,a.val);\n                    r.neg = !a.neg;\n                }\n                else return zero();//one pos and one neg, and same value.\n            }\n        }\n        else{\n            if(compare>=0){ // a>=b\n                (val, bitlen) = _add(a.val,b.val,a.bitlen);\n            }\n            else {\n                (val, bitlen) = _add(b.val,a.val,b.bitlen);\n            }\n            r.neg = false;\n        }\n\n        r.val = val;\n        r.bitlen = (bitlen);\n    }\n\n    /** @notice BigNumber subtraction: a - b.\n      * @dev sub: Initially prepare BigNumbers for subtraction operation; internally calls actual addition/subtraction,\n                  depending on inputs.\n      *           In order to do correct addition or subtraction we have to handle the sign.\n      *           This function discovers the sign of the result based on the inputs, and calls the correct operation.\n      *\n      * @param a first BN\n      * @param b second BN\n      * @return r result - subtraction of a and b.\n      */  \n    function sub(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(BigNumber memory r) {\n        if(a.bitlen==0 && b.bitlen==0) return zero();\n        bytes memory val;\n        int compare;\n        uint bitlen;\n        compare = cmp(a,b,false);\n        if(a.neg || b.neg) {\n            if(a.neg && b.neg){           \n                if(compare == 1) { \n                    (val,bitlen) = _sub(a.val,b.val); \n                    r.neg = true;\n                }\n                else if(compare == -1) { \n\n                    (val,bitlen) = _sub(b.val,a.val); \n                    r.neg = false;\n                }\n                else return zero();\n            }\n            else {\n                if(compare >= 0) (val,bitlen) = _add(a.val,b.val,a.bitlen);\n                else (val,bitlen) = _add(b.val,a.val,b.bitlen);\n                \n                r.neg = (a.neg) ? true : false;\n            }\n        }\n        else {\n            if(compare == 1) {\n                (val,bitlen) = _sub(a.val,b.val);\n                r.neg = false;\n             }\n            else if(compare == -1) { \n                (val,bitlen) = _sub(b.val,a.val);\n                r.neg = true;\n            }\n            else return zero(); \n        }\n        \n        r.val = val;\n        r.bitlen = (bitlen);\n    }\n\n    /** @notice BigNumber multiplication: a * b.\n      * @dev mul: takes two BigNumbers and multiplys them. Order is irrelevant.\n      *              multiplication achieved using modexp precompile:\n      *                 (a * b) = ((a + b)**2 - (a - b)**2) / 4\n      *\n      * @param a first BN\n      * @param b second BN\n      * @return r result - multiplication of a and b.\n      */\n    function mul(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal view returns(BigNumber memory r){\n            \n        BigNumber memory lhs = add(a,b);\n        BigNumber memory fst = modexp(lhs, two(), _powModulus(lhs, 2)); // (a+b)^2\n        \n        // no need to do subtraction part of the equation if a == b; if so, it has no effect on final result.\n        if(!eq(a,b)) {\n            BigNumber memory rhs = sub(a,b);\n            BigNumber memory snd = modexp(rhs, two(), _powModulus(rhs, 2)); // (a-b)^2\n            r = _shr(sub(fst, snd) , 2); // (a * b) = (((a + b)**2 - (a - b)**2) / 4\n        }\n        else {\n            r = _shr(fst, 2); // a==b ? (((a + b)**2 / 4\n        }\n    }\n\n    /** @notice BigNumber division verification: a * b.\n      * @dev div: takes three BigNumbers (a,b and result), and verifies that a/b == result.\n      * Performing BigNumber division on-chain is a significantly expensive operation. As a result, \n      * we expose the ability to verify the result of a division operation, which is a constant time operation. \n      *              (a/b = result) == (a = b * result)\n      *              Integer division only; therefore:\n      *                verify ((b*result) + (a % (b*result))) == a.\n      *              eg. 17/7 == 2:\n      *                verify  (7*2) + (17 % (7*2)) == 17.\n      * The function returns a bool on successful verification. The require statements will ensure that false can never\n      *  be returned, however inheriting contracts may also want to put this function inside a require statement.\n      *  \n      * @param a first BigNumber\n      * @param b second BigNumber\n      * @param r result BigNumber\n      * @return bool whether or not the operation was verified\n      */\n    function divVerify(\n        BigNumber memory a, \n        BigNumber memory b, \n        BigNumber memory r\n    ) internal view returns(bool) {\n\n        // first do zero check.\n        // if a<b (always zero) and r==zero (input check), return true.\n        if(cmp(a, b, false) == -1){\n            require(cmp(zero(), r, false)==0);\n            return true;\n        }\n\n        // Following zero check:\n        //if both negative: result positive\n        //if one negative: result negative\n        //if neither negative: result positive\n        bool positiveResult = ( a.neg && b.neg ) || (!a.neg && !b.neg);\n        require(positiveResult ? !r.neg : r.neg);\n        \n        // require denominator to not be zero.\n        require(!(cmp(b,zero(),true)==0));\n        \n        // division result check assumes inputs are positive.\n        // we have already checked for result sign so this is safe.\n        bool[3] memory negs = [a.neg, b.neg, r.neg];\n        a.neg = false;\n        b.neg = false;\n        r.neg = false;\n\n        // do multiplication (b * r)\n        BigNumber memory fst = mul(b,r);\n        // check if we already have 'a' (ie. no remainder after division). if so, no mod necessary, and return true.\n        if(cmp(fst,a,true)==0) return true;\n        //a mod (b*r)\n        BigNumber memory snd = modexp(a,one(),fst); \n        // ((b*r) + a % (b*r)) == a\n        require(cmp(add(fst,snd),a,true)==0); \n\n        a.neg = negs[0];\n        b.neg = negs[1];\n        r.neg = negs[2];\n\n        return true;\n    }\n\n    /** @notice BigNumber exponentiation: a ^ b.\n      * @dev pow: takes a BigNumber and a uint (a,e), and calculates a^e.\n      * modexp precompile is used to achieve a^e; for this is work, we need to work out the minimum modulus value \n      * such that the modulus passed to modexp is not used. the result of a^e can never be more than size bitlen(a) * e.\n      * \n      * @param a BigNumber\n      * @param e exponent\n      * @return r result BigNumber\n      */\n    function pow(\n        BigNumber memory a, \n        uint e\n    ) internal view returns(BigNumber memory){\n        return modexp(a, init(e, false), _powModulus(a, e));\n    }\n\n    /** @notice BigNumber modulus: a % n.\n      * @dev mod: takes a BigNumber and modulus BigNumber (a,n), and calculates a % n.\n      * modexp precompile is used to achieve a % n; an exponent of value '1' is passed.\n      * @param a BigNumber\n      * @param n modulus BigNumber\n      * @return r result BigNumber\n      */\n    function mod(\n        BigNumber memory a, \n        BigNumber memory n\n    ) internal view returns(BigNumber memory){\n      return modexp(a,one(),n);\n    }\n\n    /** @notice BigNumber modular exponentiation: a^e mod n.\n      * @dev modexp: takes base, exponent, and modulus, internally computes base^exponent % modulus using the precompile at address 0x5, and creates new BigNumber.\n      *              this function is overloaded: it assumes the exponent is positive. if not, the other method is used, whereby the inverse of the base is also passed.\n      *\n      * @param a base BigNumber\n      * @param e exponent BigNumber\n      * @param n modulus BigNumber\n      * @return result BigNumber\n      */    \n    function modexp(\n        BigNumber memory a, \n        BigNumber memory e, \n        BigNumber memory n\n    ) internal view returns(BigNumber memory) {\n        //if exponent is negative, other method with this same name should be used.\n        //if modulus is negative or zero, we cannot perform the operation.\n        require(  e.neg==false\n                && n.neg==false\n                && !isZero(n.val));\n\n        bytes memory _result = _modexp(a.val,e.val,n.val);\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\n        uint bitlen = bitLength(_result);\n        \n        // if result is 0, immediately return.\n        if(bitlen == 0) return zero();\n        // if base is negative AND exponent is odd, base^exp is negative, and tf. result is negative;\n        // in that case we make the result positive by adding the modulus.\n        if(a.neg && isOdd(e)) return add(BigNumber(_result, true, bitlen), n);\n        // in any other case we return the positive result.\n        return BigNumber(_result, false, bitlen);\n    }\n\n    /** @notice BigNumber modular exponentiation with negative base: inv(a)==a_inv && a_inv^e mod n.\n    /** @dev modexp: takes base, base inverse, exponent, and modulus, asserts inverse(base)==base inverse, \n      *              internally computes base_inverse^exponent % modulus and creates new BigNumber.\n      *              this function is overloaded: it assumes the exponent is negative. \n      *              if not, the other method is used, where the inverse of the base is not passed.\n      *\n      * @param a base BigNumber\n      * @param ai base inverse BigNumber\n      * @param e exponent BigNumber\n      * @param a modulus\n      * @return BigNumber memory result.\n      */ \n    function modexp(\n        BigNumber memory a, \n        BigNumber memory ai, \n        BigNumber memory e, \n        BigNumber memory n) \n    internal view returns(BigNumber memory) {\n        // base^-exp = (base^-1)^exp\n        require(!a.neg && e.neg);\n\n        //if modulus is negative or zero, we cannot perform the operation.\n        require(!n.neg && !isZero(n.val));\n\n        //base_inverse == inverse(base, modulus)\n        require(modinvVerify(a, n, ai)); \n            \n        bytes memory _result = _modexp(ai.val,e.val,n.val);\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\n        uint bitlen = bitLength(_result);\n\n        // if result is 0, immediately return.\n        if(bitlen == 0) return zero();\n        // if base_inverse is negative AND exponent is odd, base_inverse^exp is negative, and tf. result is negative;\n        // in that case we make the result positive by adding the modulus.\n        if(ai.neg && isOdd(e)) return add(BigNumber(_result, true, bitlen), n);\n        // in any other case we return the positive result.\n        return BigNumber(_result, false, bitlen);\n    }\n \n    /** @notice modular multiplication: (a*b) % n.\n      * @dev modmul: Takes BigNumbers for a, b, and modulus, and computes (a*b) % modulus\n      *              We call mul for the two input values, before calling modexp, passing exponent as 1.\n      *              Sign is taken care of in sub-functions.\n      *\n      * @param a BigNumber\n      * @param b BigNumber\n      * @param n Modulus BigNumber\n      * @return result BigNumber\n      */\n    function modmul(\n        BigNumber memory a, \n        BigNumber memory b, \n        BigNumber memory n) internal view returns(BigNumber memory) {       \n        return mod(mul(a,b), n);       \n    }\n\n    /** @notice modular inverse verification: Verifies that (a*r) % n == 1.\n      * @dev modinvVerify: Takes BigNumbers for base, modulus, and result, verifies (base*result)%modulus==1, and returns result.\n      *              Similar to division, it's far cheaper to verify an inverse operation on-chain than it is to calculate it, so we allow the user to pass their own result.\n      *\n      * @param a base BigNumber\n      * @param n modulus BigNumber\n      * @param r result BigNumber\n      * @return boolean result\n      */\n    function modinvVerify(\n        BigNumber memory a, \n        BigNumber memory n, \n        BigNumber memory r\n    ) internal view returns(bool) {\n        require(!a.neg && !n.neg); //assert positivity of inputs.\n        /*\n         * the following proves:\n         * - user result passed is correct for values base and modulus\n         * - modular inverse exists for values base and modulus.\n         * otherwise it fails.\n         */        \n        require(cmp(modmul(a, r, n),one(),true)==0);\n        \n        return true;\n    }\n    // ***************** END EXPOSED CORE CALCULATION FUNCTIONS ******************\n\n\n\n\n    // ***************** START EXPOSED HELPER FUNCTIONS ******************\n    /** @notice BigNumber odd number check\n      * @dev isOdd: returns 1 if BigNumber value is an odd number and 0 otherwise.\n      *              \n      * @param a BigNumber\n      * @return r Boolean result\n      */  \n    function isOdd(\n        BigNumber memory a\n    ) internal pure returns(bool r){\n        assembly{\n            let a_ptr := add(mload(a), mload(mload(a))) // go to least significant word\n            r := mod(mload(a_ptr),2)                      // mod it with 2 (returns 0 or 1) \n        }\n    }\n\n    /** @notice BigNumber comparison\n      * @dev cmp: Compares BigNumbers a and b. 'signed' parameter indiciates whether to consider the sign of the inputs.\n      *           'trigger' is used to decide this - \n      *              if both negative, invert the result; \n      *              if both positive (or signed==false), trigger has no effect;\n      *              if differing signs, we return immediately based on input.\n      *           returns -1 on a<b, 0 on a==b, 1 on a>b.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @param signed whether to consider sign of inputs\n      * @return int result\n      */\n    function cmp(\n        BigNumber memory a, \n        BigNumber memory b, \n        bool signed\n    ) internal pure returns(int){\n        int trigger = 1;\n        if(signed){\n            if(a.neg && b.neg) trigger = -1;\n            else if(a.neg==false && b.neg==true) return 1;\n            else if(a.neg==true && b.neg==false) return -1;\n        }\n\n        if(a.bitlen>b.bitlen) return    trigger;   // 1*trigger\n        if(b.bitlen>a.bitlen) return -1*trigger;\n\n        uint a_ptr;\n        uint b_ptr;\n        uint a_word;\n        uint b_word;\n\n        uint len = a.val.length; //bitlen is same so no need to check length.\n\n        assembly{\n            a_ptr := add(mload(a),0x20) \n            b_ptr := add(mload(b),0x20)\n        }\n\n        for(uint i=0; i<len;i+=32){\n            assembly{\n                a_word := mload(add(a_ptr,i))\n                b_word := mload(add(b_ptr,i))\n            }\n\n            if(a_word>b_word) return    trigger; // 1*trigger\n            if(b_word>a_word) return -1*trigger; \n\n        }\n\n        return 0; //same value.\n    }\n\n    /** @notice BigNumber equality\n      * @dev eq: returns true if a==b. sign always considered.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @return boolean result\n      */\n    function eq(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==0) ? true : false;\n    }\n\n    /** @notice BigNumber greater than\n      * @dev eq: returns true if a>b. sign always considered.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @return boolean result\n      */\n    function gt(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==1) ? true : false;\n    }\n\n    /** @notice BigNumber greater than or equal to\n      * @dev eq: returns true if a>=b. sign always considered.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @return boolean result\n      */\n    function gte(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==1 || result==0) ? true : false;\n    }\n\n    /** @notice BigNumber less than\n      * @dev eq: returns true if a<b. sign always considered.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @return boolean result\n      */\n    function lt(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==-1) ? true : false;\n    }\n\n    /** @notice BigNumber less than or equal o\n      * @dev eq: returns true if a<=b. sign always considered.\n      *           \n      * @param a BigNumber\n      * @param b BigNumber\n      * @return boolean result\n      */\n    function lte(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==-1 || result==0) ? true : false;\n    }\n\n    /** @notice right shift BigNumber value\n      * @dev shr: right shift BigNumber a by 'bits' bits.\n             copies input value to new memory location before shift and calls _shr function after. \n      * @param a BigNumber value to shift\n      * @param bits amount of bits to shift by\n      * @return result BigNumber\n      */\n    function shr(\n        BigNumber memory a, \n        uint bits\n    ) internal view returns(BigNumber memory){\n        require(!a.neg);\n        return _shr(a, bits);\n    }\n\n    /** @notice right shift BigNumber memory 'dividend' by 'bits' bits.\n      * @dev _shr: Shifts input value in-place, ie. does not create new memory. shr function does this.\n      * right shift does not necessarily have to copy into a new memory location. where the user wishes the modify\n      * the existing value they have in place, they can use this.  \n      * @param bn value to shift\n      * @param bits amount of bits to shift by\n      * @return r result\n      */\n    function _shr(BigNumber memory bn, uint bits) internal view returns(BigNumber memory){\n        uint length;\n        assembly { length := mload(mload(bn)) }\n\n        // if bits is >= the bitlength of the value the result is always 0\n        if(bits >= bn.bitlen) return BigNumber(ZERO,false,0); \n        \n        // set bitlen initially as we will be potentially modifying 'bits'\n        bn.bitlen = bn.bitlen-(bits);\n\n        // handle shifts greater than 256:\n        // if bits is greater than 256 we can simply remove any trailing words, by altering the BN length. \n        // we also update 'bits' so that it is now in the range 0..256.\n        assembly {\n            if or(gt(bits, 0x100), eq(bits, 0x100)) {\n                length := sub(length, mul(div(bits, 0x100), 0x20))\n                mstore(mload(bn), length)\n                bits := mod(bits, 0x100)\n            }\n\n            // if bits is multiple of 8 (byte size), we can simply use identity precompile for cheap memcopy.\n            // otherwise we shift each word, starting at the least signifcant word, one-by-one using the mask technique.\n            // TODO it is possible to do this without the last two operations, see SHL identity copy.\n            let bn_val_ptr := mload(bn)\n            switch eq(mod(bits, 8), 0)\n              case 1 {  \n                  let bytes_shift := div(bits, 8)\n                  let in          := mload(bn)\n                  let inlength    := mload(in)\n                  let insize      := add(inlength, 0x20)\n                  let out         := add(in,     bytes_shift)\n                  let outsize     := sub(insize, bytes_shift)\n                  let success     := staticcall(450, 0x4, in, insize, out, insize)\n                  mstore8(add(out, 0x1f), 0) // maintain our BN layout following identity call:\n                  mstore(in, inlength)         // set current length byte to 0, and reset old length.\n              }\n              default {\n                  let mask\n                  let lsw\n                  let mask_shift := sub(0x100, bits)\n                  let lsw_ptr := add(bn_val_ptr, length)   \n                  for { let i := length } eq(eq(i,0),0) { i := sub(i, 0x20) } { // for(int i=max_length; i!=0; i-=32)\n                      switch eq(i,0x20)                                         // if i==32:\n                          case 1 { mask := 0 }                                  //    - handles lsword: no mask needed.\n                          default { mask := mload(sub(lsw_ptr,0x20)) }          //    - else get mask (previous word)\n                      lsw := shr(bits, mload(lsw_ptr))                          // right shift current by bits\n                      mask := shl(mask_shift, mask)                             // left shift next significant word by mask_shift\n                      mstore(lsw_ptr, or(lsw,mask))                             // store OR'd mask and shifted bits in-place\n                      lsw_ptr := sub(lsw_ptr, 0x20)                             // point to next bits.\n                  }\n              }\n\n            // The following removes the leading word containing all zeroes in the result should it exist, \n            // as well as updating lengths and pointers as necessary.\n            let msw_ptr := add(bn_val_ptr,0x20)\n            switch eq(mload(msw_ptr), 0) \n                case 1 {\n                   mstore(msw_ptr, sub(mload(bn_val_ptr), 0x20)) // store new length in new position\n                   mstore(bn, msw_ptr)                           // update pointer from bn\n                }\n                default {}\n        }\n    \n\n        return bn;\n    }\n\n    /** @notice left shift BigNumber value\n      * @dev shr: left shift BigNumber a by 'bits' bits.\n                  ensures the value is not negative before calling the private function.\n      * @param a BigNumber value to shift\n      * @param bits amount of bits to shift by\n      * @return result BigNumber\n      */\n    function shl(\n        BigNumber memory a, \n        uint bits\n    ) internal view returns(BigNumber memory){\n        require(!a.neg);\n        return _shl(a, bits);\n    }\n\n    /** @notice sha3 hash a BigNumber.\n      * @dev hash: takes a BigNumber and performs sha3 hash on it.\n      *            we hash each BigNumber WITHOUT it's first word - first word is a pointer to the start of the bytes value,\n      *            and so is different for each struct.\n      *             \n      * @param a BigNumber\n      * @return h bytes32 hash.\n      */\n    function hash(\n        BigNumber memory a\n    ) internal pure returns(bytes32 h) {\n        //amount of words to hash = all words of the value and three extra words: neg, bitlen & value length.     \n        assembly {\n            h := keccak256( add(a,0x20), add (mload(mload(a)), 0x60 ) ) \n        }\n    }\n\n    /** @notice BigNumber full zero check\n      * @dev isZero: checks if the BigNumber is in the default zero format for BNs (ie. the result from zero()).\n      *             \n      * @param a BigNumber\n      * @return boolean result.\n      */\n    function isZero(\n        BigNumber memory a\n    ) internal pure returns(bool) {\n        return isZero(a.val) && a.val.length==0x20 && !a.neg && a.bitlen == 0;\n    }\n\n\n    /** @notice bytes zero check\n      * @dev isZero: checks if input bytes value resolves to zero.\n      *             \n      * @param a bytes value\n      * @return boolean result.\n      */\n    function isZero(\n        bytes memory a\n    ) internal pure returns(bool) {\n        uint msword;\n        uint msword_ptr;\n        assembly {\n            msword_ptr := add(a,0x20)\n        }\n        for(uint i=0; i<a.length; i+=32) {\n            assembly { msword := mload(msword_ptr) } // get msword of input\n            if(msword > 0) return false;\n            assembly { msword_ptr := add(msword_ptr, 0x20) }\n        }\n        return true;\n\n    }\n\n    /** @notice BigNumber value bit length\n      * @dev bitLength: returns BigNumber value bit length- ie. log2 (most significant bit of value)\n      *             \n      * @param a BigNumber\n      * @return uint bit length result.\n      */\n    function bitLength(\n        BigNumber memory a\n    ) internal pure returns(uint){\n        return bitLength(a.val);\n    }\n\n    /** @notice bytes bit length\n      * @dev bitLength: returns bytes bit length- ie. log2 (most significant bit of value)\n      *             \n      * @param a bytes value\n      * @return r uint bit length result.\n      */\n    function bitLength(\n        bytes memory a\n    ) internal pure returns(uint r){\n        if(isZero(a)) return 0;\n        uint msword; \n        assembly {\n            msword := mload(add(a,0x20))               // get msword of input\n        }\n        r = bitLength(msword);                         // get bitlen of msword, add to size of remaining words.\n        assembly {                                           \n            r := add(r, mul(sub(mload(a), 0x20) , 8))  // res += (val.length-32)*8;  \n        }\n    }\n\n    /** @notice uint bit length\n        @dev bitLength: get the bit length of a uint input - ie. log2 (most significant bit of 256 bit value (one EVM word))\n      *                       credit: Tjaden Hess @ ethereum.stackexchange             \n      * @param a uint value\n      * @return r uint bit length result.\n      */\n    function bitLength(\n        uint a\n    ) internal pure returns (uint r){\n        assembly {\n            switch eq(a, 0)\n            case 1 {\n                r := 0\n            }\n            default {\n                let arg := a\n                a := sub(a,1)\n                a := or(a, div(a, 0x02))\n                a := or(a, div(a, 0x04))\n                a := or(a, div(a, 0x10))\n                a := or(a, div(a, 0x100))\n                a := or(a, div(a, 0x10000))\n                a := or(a, div(a, 0x100000000))\n                a := or(a, div(a, 0x10000000000000000))\n                a := or(a, div(a, 0x100000000000000000000000000000000))\n                a := add(a, 1)\n                let m := mload(0x40)\n                mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n                mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n                mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n                mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n                mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n                mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n                mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n                mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n                mstore(0x40, add(m, 0x100))\n                let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n                let shift := 0x100000000000000000000000000000000000000000000000000000000000000\n                let _a := div(mul(a, magic), shift)\n                r := div(mload(add(m,sub(255,_a))), shift)\n                r := add(r, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n                // where a is a power of two, result needs to be incremented. we use the power of two trick here: if(arg & arg-1 == 0) ++r;\n                if eq(and(arg, sub(arg, 1)), 0) {\n                    r := add(r, 1) \n                }\n            }\n        }\n    }\n\n    /** @notice BigNumber zero value\n        @dev zero: returns zero encoded as a BigNumber\n      * @return zero encoded as BigNumber\n      */\n    function zero(\n    ) internal pure returns(BigNumber memory) {\n        return BigNumber(ZERO, false, 0);\n    }\n\n    /** @notice BigNumber one value\n        @dev one: returns one encoded as a BigNumber\n      * @return one encoded as BigNumber\n      */\n    function one(\n    ) internal pure returns(BigNumber memory) {\n        return BigNumber(ONE, false, 1);\n    }\n\n    /** @notice BigNumber two value\n        @dev two: returns two encoded as a BigNumber\n      * @return two encoded as BigNumber\n      */\n    function two(\n    ) internal pure returns(BigNumber memory) {\n        return BigNumber(TWO, false, 2);\n    }\n    // ***************** END EXPOSED HELPER FUNCTIONS ******************\n\n\n\n\n\n    // ***************** START PRIVATE MANAGEMENT FUNCTIONS ******************\n    /** @notice Create a new BigNumber.\n        @dev init: overloading allows caller to obtionally pass bitlen where it is known - as it is cheaper to do off-chain and verify on-chain. \n      *            we assert input is in data structure as defined above, and that bitlen, if passed, is correct.\n      *            'copy' parameter indicates whether or not to copy the contents of val to a new location in memory (for example where you pass \n      *            the contents of another variable's value in)\n      * @param val bytes - bignum value.\n      * @param neg bool - sign of value\n      * @param bitlen uint - bit length of value\n      * @return r BigNumber initialized value.\n      */\n    function _init(\n        bytes memory val, \n        bool neg, \n        uint bitlen\n    ) private view returns(BigNumber memory r){ \n        // use identity at location 0x4 for cheap memcpy.\n        // grab contents of val, load starting from memory end, update memory end pointer.\n        assembly {\n            let data := add(val, 0x20)\n            let length := mload(val)\n            let out\n            let freemem := msize()\n            switch eq(mod(length, 0x20), 0)                       // if(val.length % 32 == 0)\n                case 1 {\n                    out     := add(freemem, 0x20)                 // freememory location + length word\n                    mstore(freemem, length)                       // set new length \n                }\n                default { \n                    let offset  := sub(0x20, mod(length, 0x20))   // offset: 32 - (length % 32)\n                    out     := add(add(freemem, offset), 0x20)    // freememory location + offset + length word\n                    mstore(freemem, add(length, offset))          // set new length \n                }\n            pop(staticcall(450, 0x4, data, length, out, length))  // copy into 'out' memory location\n            mstore(0x40, add(freemem, add(mload(freemem), 0x20))) // update the free memory pointer\n            \n            // handle leading zero words. assume freemem is pointer to bytes value\n            let bn_length := mload(freemem)\n            for { } eq ( eq(bn_length, 0x20), 0) { } {            // for(; length!=32; length-=32)\n             switch eq(mload(add(freemem, 0x20)),0)               // if(msword==0):\n                    case 1 { freemem := add(freemem, 0x20) }      //     update length pointer\n                    default { break }                             // else: loop termination. non-zero word found\n                bn_length := sub(bn_length,0x20)                          \n            } \n            mstore(freemem, bn_length)                             \n\n            mstore(r, freemem)                                    // store new bytes value in r\n            mstore(add(r, 0x20), neg)                             // store neg value in r\n        }\n\n        r.bitlen = bitlen == 0 ? bitLength(r.val) : bitlen;\n    }\n    // ***************** END PRIVATE MANAGEMENT FUNCTIONS ******************\n\n\n\n\n\n    // ***************** START PRIVATE CORE CALCULATION FUNCTIONS ******************\n    /** @notice takes two BigNumber memory values and the bitlen of the max value, and adds them.\n      * @dev _add: This function is private and only callable from add: therefore the values may be of different sizes,\n      *            in any order of size, and of different signs (handled in add).\n      *            As values may be of different sizes, inputs are considered starting from the least significant \n      *            words, working back. \n      *            The function calculates the new bitlen (basically if bitlens are the same for max and min, \n      *            max_bitlen++) and returns a new BigNumber memory value.\n      *\n      * @param max bytes -  biggest value  (determined from add)\n      * @param min bytes -  smallest value (determined from add)\n      * @param max_bitlen uint - bit length of max value.\n      * @return bytes result - max + min.\n      * @return uint - bit length of result.\n      */\n    function _add(\n        bytes memory max, \n        bytes memory min, \n        uint max_bitlen\n    ) private pure returns (bytes memory, uint) {\n        bytes memory result;\n        assembly {\n\n            let result_start := msize()                                       // Get the highest available block of memory\n            let carry := 0\n            let uint_max := sub(0,1)\n\n            let max_ptr := add(max, mload(max))\n            let min_ptr := add(min, mload(min))                               // point to last word of each byte array.\n\n            let result_ptr := add(add(result_start,0x20), mload(max))         // set result_ptr end.\n\n            for { let i := mload(max) } eq(eq(i,0),0) { i := sub(i, 0x20) } { // for(int i=max_length; i!=0; i-=32)\n                let max_val := mload(max_ptr)                                 // get next word for 'max'\n                switch gt(i,sub(mload(max),mload(min)))                       // if(i>(max_length-min_length)). while \n                                                                              // 'min' words are still available.\n                    case 1{ \n                        let min_val := mload(min_ptr)                         //      get next word for 'min'\n                        mstore(result_ptr, add(add(max_val,min_val),carry))   //      result_word = max_word+min_word+carry\n                        switch gt(max_val, sub(uint_max,sub(min_val,carry)))  //      this switch block finds whether or\n                                                                              //      not to set the carry bit for the\n                                                                              //      next iteration.\n                            case 1  { carry := 1 }\n                            default {\n                                switch and(eq(max_val,uint_max),or(gt(carry,0), gt(min_val,0)))\n                                case 1 { carry := 1 }\n                                default{ carry := 0 }\n                            }\n                            \n                        min_ptr := sub(min_ptr,0x20)                       //       point to next 'min' word\n                    }\n                    default{                                               // else: remainder after 'min' words are complete.\n                        mstore(result_ptr, add(max_val,carry))             //       result_word = max_word+carry\n                        \n                        switch and( eq(uint_max,max_val), eq(carry,1) )    //       this switch block finds whether or \n                                                                           //       not to set the carry bit for the \n                                                                           //       next iteration.\n                            case 1  { carry := 1 }\n                            default { carry := 0 }\n                    }\n                result_ptr := sub(result_ptr,0x20)                         // point to next 'result' word\n                max_ptr := sub(max_ptr,0x20)                               // point to next 'max' word\n            }\n\n            switch eq(carry,0) \n                case 1{ result_start := add(result_start,0x20) }           // if carry is 0, increment result_start, ie.\n                                                                           // length word for result is now one word \n                                                                           // position ahead.\n                default { mstore(result_ptr, 1) }                          // else if carry is 1, store 1; overflow has\n                                                                           // occured, so length word remains in the \n                                                                           // same position.\n\n            result := result_start                                         // point 'result' bytes value to the correct\n                                                                           // address in memory.\n            mstore(result,add(mload(max),mul(0x20,carry)))                 // store length of result. we are finished \n                                                                           // with the byte array.\n            \n            mstore(0x40, add(result,add(mload(result),0x20)))              // Update freemem pointer to point to new \n                                                                           // end of memory.\n\n            // we now calculate the result's bit length.\n            // with addition, if we assume that some a is at least equal to some b, then the resulting bit length will\n            // be a's bit length or (a's bit length)+1, depending on carry bit.this is cheaper than calling bitLength.\n            let msword := mload(add(result,0x20))                             // get most significant word of result\n            // if(msword==1 || msword>>(max_bitlen % 256)==1):\n            if or( eq(msword, 1), eq(shr(mod(max_bitlen,256),msword),1) ) {\n                    max_bitlen := add(max_bitlen, 1)                          // if msword's bit length is 1 greater \n                                                                              // than max_bitlen, OR overflow occured,\n                                                                              // new bitlen is max_bitlen+1.\n                }\n        }\n        \n\n        return (result, max_bitlen);\n    }\n\n    /** @notice takes two BigNumber memory values and subtracts them.\n      * @dev _sub: This function is private and only callable from add: therefore the values may be of different sizes, \n      *            in any order of size, and of different signs (handled in add).\n      *            As values may be of different sizes, inputs are considered starting from the least significant words,\n      *            working back. \n      *            The function calculates the new bitlen (basically if bitlens are the same for max and min, \n      *            max_bitlen++) and returns a new BigNumber memory value.\n      *\n      * @param max bytes -  biggest value  (determined from add)\n      * @param min bytes -  smallest value (determined from add)\n      * @return bytes result - max + min.\n      * @return uint - bit length of result.\n      */\n    function _sub(\n        bytes memory max, \n        bytes memory min\n    ) internal pure returns (bytes memory, uint) {\n        bytes memory result;\n        uint carry = 0;\n        uint uint_max = type(uint256).max;\n        assembly {\n                \n            let result_start := msize()                                     // Get the highest available block of \n                                                                            // memory\n        \n            let max_len := mload(max)\n            let min_len := mload(min)                                       // load lengths of inputs\n            \n            let len_diff := sub(max_len,min_len)                            // get differences in lengths.\n            \n            let max_ptr := add(max, max_len)\n            let min_ptr := add(min, min_len)                                // go to end of arrays\n            let result_ptr := add(result_start, max_len)                    // point to least significant result \n                                                                            // word.\n            let memory_end := add(result_ptr,0x20)                          // save memory_end to update free memory\n                                                                            // pointer at the end.\n            \n            for { let i := max_len } eq(eq(i,0),0) { i := sub(i, 0x20) } {  // for(int i=max_length; i!=0; i-=32)\n                let max_val := mload(max_ptr)                               // get next word for 'max'\n                switch gt(i,len_diff)                                       // if(i>(max_length-min_length)). while\n                                                                            // 'min' words are still available.\n                    case 1{ \n                        let min_val := mload(min_ptr)                       //  get next word for 'min'\n        \n                        mstore(result_ptr, sub(sub(max_val,min_val),carry)) //  result_word = (max_word-min_word)-carry\n                    \n                        switch or(lt(max_val, add(min_val,carry)), \n                               and(eq(min_val,uint_max), eq(carry,1)))      //  this switch block finds whether or \n                                                                            //  not to set the carry bit for the next iteration.\n                            case 1  { carry := 1 }\n                            default { carry := 0 }\n                            \n                        min_ptr := sub(min_ptr,0x20)                        //  point to next 'result' word\n                    }\n                    default {                                               // else: remainder after 'min' words are complete.\n\n                        mstore(result_ptr, sub(max_val,carry))              //      result_word = max_word-carry\n                    \n                        switch and( eq(max_val,0), eq(carry,1) )            //      this switch block finds whether or \n                                                                            //      not to set the carry bit for the \n                                                                            //      next iteration.\n                            case 1  { carry := 1 }\n                            default { carry := 0 }\n\n                    }\n                result_ptr := sub(result_ptr,0x20)                          // point to next 'result' word\n                max_ptr    := sub(max_ptr,0x20)                             // point to next 'max' word\n            }      \n\n            //the following code removes any leading words containing all zeroes in the result.\n            result_ptr := add(result_ptr,0x20)                                                 \n\n            // for(result_ptr+=32;; result==0; result_ptr+=32)\n            for { }   eq(mload(result_ptr), 0) { result_ptr := add(result_ptr,0x20) } { \n               result_start := add(result_start, 0x20)                      // push up the start pointer for the result\n               max_len := sub(max_len,0x20)                                 // subtract a word (32 bytes) from the \n                                                                            // result length.\n            } \n\n            result := result_start                                          // point 'result' bytes value to \n                                                                            // the correct address in memory\n            \n            mstore(result,max_len)                                          // store length of result. we \n                                                                            // are finished with the byte array.\n            \n            mstore(0x40, memory_end)                                        // Update freemem pointer.\n        }\n\n        uint new_bitlen = bitLength(result);                                // calculate the result's \n                                                                            // bit length.\n        \n        return (result, new_bitlen);\n    }\n\n    /** @notice gets the modulus value necessary for calculating exponetiation.\n      * @dev _powModulus: we must pass the minimum modulus value which would return JUST the a^b part of the calculation\n      *       in modexp. the rationale here is:\n      *       if 'a' has n bits, then a^e has at most n*e bits.\n      *       using this modulus in exponetiation will result in simply a^e.\n      *       therefore the value may be many words long.\n      *       This is done by:\n      *         - storing total modulus byte length\n      *         - storing first word of modulus with correct bit set\n      *         - updating the free memory pointer to come after total length.\n      *\n      * @param a BigNumber base\n      * @param e uint exponent\n      * @return BigNumber modulus result\n      */\n    function _powModulus(\n        BigNumber memory a, \n        uint e\n    ) private pure returns(BigNumber memory){\n        bytes memory _modulus = ZERO;\n        uint mod_index;\n\n        assembly {\n            mod_index := mul(mload(add(a, 0x40)), e)               // a.bitlen * e is the max bitlength of result\n            let first_word_modulus := shl(mod(mod_index, 256), 1)  // set bit in first modulus word.\n            mstore(_modulus, mul(add(div(mod_index,256),1),0x20))  // store length of modulus\n            mstore(add(_modulus,0x20), first_word_modulus)         // set first modulus word\n            mstore(0x40, add(_modulus, add(mload(_modulus),0x20))) // update freemem pointer to be modulus index\n                                                                   // + length\n        }\n\n        //create modulus BigNumber memory for modexp function\n        return BigNumber(_modulus, false, mod_index); \n    }\n\n    /** @notice Modular Exponentiation: Takes bytes values for base, exp, mod and calls precompile for (base^exp)%^mod\n      * @dev modexp: Wrapper for built-in modexp (contract 0x5) as described here: \n      *              https://github.com/ethereum/EIPs/pull/198\n      *\n      * @param _b bytes base\n      * @param _e bytes base_inverse \n      * @param _m bytes exponent\n      * @param r bytes result.\n      */\n    function _modexp(\n        bytes memory _b, \n        bytes memory _e, \n        bytes memory _m\n    ) private view returns(bytes memory r) {\n        assembly {\n            \n            let bl := mload(_b)\n            let el := mload(_e)\n            let ml := mload(_m)\n            \n            \n            let freemem := mload(0x40) // Free memory pointer is always stored at 0x40\n            \n            \n            mstore(freemem, bl)         // arg[0] = base.length @ +0\n            \n            mstore(add(freemem,32), el) // arg[1] = exp.length @ +32\n            \n            mstore(add(freemem,64), ml) // arg[2] = mod.length @ +64\n            \n            // arg[3] = base.bits @ + 96\n            // Use identity built-in (contract 0x4) as a cheap memcpy\n            let success := staticcall(450, 0x4, add(_b,32), bl, add(freemem,96), bl)\n            \n            // arg[4] = exp.bits @ +96+base.length\n            let size := add(96, bl)\n            success := staticcall(450, 0x4, add(_e,32), el, add(freemem,size), el)\n            \n            // arg[5] = mod.bits @ +96+base.length+exp.length\n            size := add(size,el)\n            success := staticcall(450, 0x4, add(_m,32), ml, add(freemem,size), ml)\n            \n            switch success case 0 { invalid() } //fail where we haven't enough gas to make the call\n\n            // Total size of input = 96+base.length+exp.length+mod.length\n            size := add(size,ml)\n            // Invoke contract 0x5, put return value right after mod.length, @ +96\n            success := staticcall(sub(gas(), 1350), 0x5, freemem, size, add(freemem, 0x60), ml)\n\n            switch success case 0 { invalid() } //fail where we haven't enough gas to make the call\n\n            let length := ml\n            let msword_ptr := add(freemem, 0x60)\n\n            ///the following code removes any leading words containing all zeroes in the result.\n            for { } eq ( eq(length, 0x20), 0) { } {                   // for(; length!=32; length-=32)\n                switch eq(mload(msword_ptr),0)                        // if(msword==0):\n                    case 1 { msword_ptr := add(msword_ptr, 0x20) }    //     update length pointer\n                    default { break }                                 // else: loop termination. non-zero word found\n                length := sub(length,0x20)                          \n            } \n            r := sub(msword_ptr,0x20)\n            mstore(r, length)\n            \n            // point to the location of the return value (length, bits)\n            //assuming mod length is multiple of 32, return value is already in the right format.\n            mstore(0x40, add(add(96, freemem),ml)) //deallocate freemem pointer\n        }        \n    }\n    // ***************** END PRIVATE CORE CALCULATION FUNCTIONS ******************\n\n\n\n\n\n    // ***************** START PRIVATE HELPER FUNCTIONS ******************\n    /** @notice left shift BigNumber memory 'dividend' by 'value' bits.\n      * @param bn value to shift\n      * @param bits amount of bits to shift by\n      * @return r result\n      */\n    function _shl(\n        BigNumber memory bn, \n        uint bits\n    ) private view returns(BigNumber memory r) {\n        if(bits==0 || bn.bitlen==0) return bn;\n        \n        // we start by creating an empty bytes array of the size of the output, based on 'bits'.\n        // for that we must get the amount of extra words needed for the output.\n        uint length = bn.val.length;\n        // position of bitlen in most significnat word\n        uint bit_position = ((bn.bitlen-1) % 256) + 1;\n        // total extra words. we check if the bits remainder will add one more word.\n        uint extra_words = (bits / 256) + ( (bits % 256) >= (256 - bit_position) ? 1 : 0);\n        // length of output\n        uint total_length = length + (extra_words * 0x20);\n\n        r.bitlen = bn.bitlen+(bits);\n        r.neg = bn.neg;\n        bits %= 256;\n\n        \n        bytes memory bn_shift;\n        uint bn_shift_ptr;\n        // the following efficiently creates an empty byte array of size 'total_length'\n        assembly {\n            let freemem_ptr := mload(0x40)                // get pointer to free memory\n            mstore(freemem_ptr, total_length)             // store bytes length\n            let mem_end := add(freemem_ptr, total_length) // end of memory\n            mstore(mem_end, 0)                            // store 0 at memory end\n            bn_shift := freemem_ptr                       // set pointer to bytes\n            bn_shift_ptr := add(bn_shift, 0x20)           // get bn_shift pointer\n            mstore(0x40, add(mem_end, 0x20))              // update freemem pointer\n        }\n\n        // use identity for cheap copy if bits is multiple of 8.\n        if(bits % 8 == 0) {\n            // calculate the position of the first byte in the result.\n            uint bytes_pos = ((256-(((bn.bitlen-1)+bits) % 256))-1) / 8;\n            uint insize = (bn.bitlen / 8) + ((bn.bitlen % 8 != 0) ? 1 : 0);\n            assembly {\n              let in          := add(add(mload(bn), 0x20), div(sub(256, bit_position), 8))\n              let out         := add(bn_shift_ptr, bytes_pos)\n              let success     := staticcall(450, 0x4, in, insize, out, length)\n            }\n            r.val = bn_shift;\n            return r;\n        }\n\n\n        uint mask;\n        uint mask_shift = 0x100-bits;\n        uint msw;\n        uint msw_ptr;\n\n       assembly {\n           msw_ptr := add(mload(bn), 0x20)   \n       }\n        \n       // handle first word before loop if the shift adds any extra words.\n       // the loop would handle it if the bit shift doesn't wrap into the next word, \n       // so we check only for that condition.\n       if((bit_position+bits) > 256){\n           assembly {\n              msw := mload(msw_ptr)\n              mstore(bn_shift_ptr, shr(mask_shift, msw))\n              bn_shift_ptr := add(bn_shift_ptr, 0x20)\n           }\n       }\n        \n       // as a result of creating the empty array we just have to operate on the words in the original bn.\n       for(uint i=bn.val.length; i!=0; i-=0x20){                  // for each word:\n           assembly {\n               msw := mload(msw_ptr)                              // get most significant word\n               switch eq(i,0x20)                                  // if i==32:\n                   case 1 { mask := 0 }                           // handles msword: no mask needed.\n                   default { mask := mload(add(msw_ptr,0x20)) }   // else get mask (next word)\n               msw := shl(bits, msw)                              // left shift current msw by 'bits'\n               mask := shr(mask_shift, mask)                      // right shift next significant word by mask_shift\n               mstore(bn_shift_ptr, or(msw,mask))                 // store OR'd mask and shifted bits in-place\n               msw_ptr := add(msw_ptr, 0x20)\n               bn_shift_ptr := add(bn_shift_ptr, 0x20)\n           }\n       }\n\n       r.val = bn_shift;\n    }\n    // ***************** END PRIVATE HELPER FUNCTIONS ******************\n}\n"
    },
    "src/v0.8/vendor/solidity-bignumber/src/utils/Crypto.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"../BigNumbers.sol\";\n\nlibrary Crypto {\n    using BigNumbers for *;\n\n    /** @notice Verifies a PKCSv1.5 SHA256 signature\n      * @dev credit: https://github.com/adria0/SolRsaVerify\n      * @param _sha256 is the sha256 of the data\n      * @param _s is the signature\n      * @param _e is the exponent\n      * @param _m is the modulus\n      * @return 0 if success, >0 otherwise\n    */    \n    function pkcs1Sha256Verify(\n        bytes32 _sha256,\n        BigNumber memory _s,\n        BigNumber memory _e,\n        BigNumber memory _m\n    ) internal view verifyParams(_s,_e,_m) returns (uint) {\n        return _pkcs1Sha256Verify(_sha256,_s,_e,_m);\n    }\n\n    /** @notice Verifies a PKCSv1.5 SHA256 signature\n      * @dev credit: https://github.com/adria0/SolRsaVerify\n      * @param _data to verify\n      * @param _s is the signature\n      * @param _e is the exponent\n      * @param _m is the modulus\n      * @return 0 if success, >0 otherwise\n    */    \n    function pkcs1Sha256VerifyRaw(\n        bytes memory _data, \n        BigNumber memory _s, \n        BigNumber memory _e, \n        BigNumber memory _m\n    ) internal view verifyParams(_s,_e,_m) returns (uint) {\n        return _pkcs1Sha256Verify(sha256(_data),_s,_e,_m);\n    }\n\n    /** @notice executes Miller-Rabin Primality Test to see whether input BigNumber is prime or not.\n      * @dev isPrime: executes Miller-Rabin Primality Test to see whether input BigNumber is prime or not.\n      *                'randomness' is expected to be provided.\n      *                TODO: 1. add Oraclize randomness generation code template to be added to calling contract.\n      *                TODO generalize for any size input - currently just works for 850-1300 bit primes\n      *           \n      * @param a BigNumber value to check\n      * @param randomness BigNumber array of randomness\n      * @return bool indicating primality.\n      */\n    function isPrime(\n        BigNumber memory a, \n        BigNumber[3] memory randomness\n    ) internal view returns (bool){\n\n        BigNumber memory one = BigNumbers.one();\n        BigNumber memory two = BigNumbers.two();\n        \n        int compare = a.cmp(two,true); \n        if (compare < 0){\n            // if value is < 2\n            return false;\n        } \n        if(compare == 0){\n            // if value is 2\n            return true;\n        }\n        // if a is even and not 2 (checked): return false\n        if (!a.isOdd()) {\n            return false; \n        }\n                 \n        BigNumber memory a1 = a.sub(one);\n\n        uint k = getK(a1);\n        BigNumber memory a1_odd = a1.val.init(a1.neg); \n        a1_odd._shr(k);\n\n        int j;\n        uint num_checks = primeChecksForSize(a.bitlen);\n        BigNumber memory check;\n        for (uint i = 0; i < num_checks; i++) {\n            \n            check = randomness[i].add(one);\n            // now 1 <= check < a.\n\n            j = witness(check, a, a1, a1_odd, k);\n\n            if(j==-1 || j==1) return false;\n        }\n\n        //if we've got to here, a is likely a prime.\n        return true;\n    }\n\n    /** @notice Verifies a PKCSv1.5 SHA256 signature\n      * @dev credit: https://github.com/adria0/SolRsaVerify\n      * @param _sha256 to verify\n      * @param _s is the signature\n      * @param _e is the exponent\n      * @param _m is the modulus\n      * @return 0 if success, >0 otherwise\n    */    \n    function _pkcs1Sha256Verify(\n        bytes32 _sha256,\n        BigNumber memory _s,\n        BigNumber memory _e,\n        BigNumber memory _m\n    ) private view returns (uint) {\n        \n        uint8[19] memory sha256Prefix = [\n            0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20\n        ];\n        \n      \trequire(_m.val.length >= sha256Prefix.length+_sha256.length+11);\n\n        /// decipher\n        uint decipherlen = _m.val.length;\n        bytes memory decipher = (_s.modexp(_e, _m)).val;\n        \n        /// 0x00 || 0x01 || PS || 0x00 || DigestInfo\n        /// PS is padding filled with 0xff\n        //  DigestInfo ::= SEQUENCE {\n        //     digestAlgorithm AlgorithmIdentifier,\n        //     digest OCTET STRING\n        //  }\n        uint i;\n        uint paddingLen = decipherlen - 3 - sha256Prefix.length - 32;\n        if (decipher[0] != 0 || uint8(decipher[1]) != 1) {\n            return 1;\n        }\n        for (i = 2;i<2+paddingLen;i++) {\n            if (decipher[i] != 0xff) {\n                return 2;\n            }\n        }\n        if (decipher[2+paddingLen] != 0) {\n            return 3;\n        }\n        for (i = 0;i<sha256Prefix.length;i++) {\n            if (uint8(decipher[3+paddingLen+i])!=sha256Prefix[i]) {\n                return 4;\n            }\n        }\n        for (i = 0;i<_sha256.length;i++) {\n            if (decipher[3+paddingLen+sha256Prefix.length+i]!=_sha256[i]) {\n                return 5;\n            }\n        }\n\n        return 0;\n    }\n\n    function getK(\n        BigNumber memory a1\n    ) private pure returns (uint k){\n        k = 0;\n        uint mask=1;\n        uint a1_ptr;\n        uint val;\n        assembly{ \n            a1_ptr := add(mload(a1),mload(mload(a1))) // get address of least significant portion of a\n            val := mload(a1_ptr)  //load it\n        }\n        \n        //loop from least signifcant bits until we hit a set bit. increment k until this point.        \n        for(bool bit_set = ((val & mask) != 0); !bit_set; bit_set = ((val & mask) != 0)){\n            \n            if(((k+1) % 256) == 0){ //get next word should k reach 256.\n                a1_ptr -= 32;\n                assembly {val := mload(a1_ptr)}\n                mask = 1;\n            }\n            \n            mask*=2; // set next bit (left shift)\n            k++;     // increment k\n        }\n    } \n\n    function primeChecksForSize(\n        uint bit_size\n    ) private pure returns(uint checks){\n\n       checks = bit_size >= 1300 ?  2 :\n                bit_size >=  850 ?  3 :\n                bit_size >=  650 ?  4 :\n                bit_size >=  550 ?  5 :\n                bit_size >=  450 ?  6 :\n                bit_size >=  400 ?  7 :\n                bit_size >=  350 ?  8 :\n                bit_size >=  300 ?  9 :\n                bit_size >=  250 ? 12 :\n                bit_size >=  200 ? 15 :\n                bit_size >=  150 ? 18 :\n                /* b >= 100 */ 27;\n    }\n    \n    function witness(\n        BigNumber memory w, \n        BigNumber memory a, \n        BigNumber memory a1, \n        BigNumber memory a1_odd, \n        uint k\n    ) private view returns (int){\n        BigNumber memory one = BigNumbers.one();\n        BigNumber memory two = BigNumbers.two();\n        // returns -  0: likely prime, 1: composite number (definite non-prime).\n\n        w = w.modexp(a1_odd, a); // w := w^a1_odd mod a\n\n        if (w.cmp(one,true)==0) return 0; // probably prime.                \n                           \n        if (w.cmp(a1,true)==0) return 0; // w == -1 (mod a), 'a' is probably prime\n                                 \n         for (;k != 0; k=k-1) {\n             w = w.modexp(two,a); // w := w^2 mod a\n\n             if (w.cmp(one,true)==0) return 1; // // 'a' is composite, otherwise a previous 'w' would have been == -1 (mod 'a')\n                                    \n             if (w.cmp(a1,true)==0) return 0; // w == -1 (mod a), 'a' is probably prime\n                      \n         }\n        /*\n         * If we get here, 'w' is the (a-1)/2-th power of the original 'w', and\n         * it is neither -1 nor +1 -- so 'a' cannot be prime\n         */\n        return 1;\n    }\n\n    modifier verifyParams(\n        BigNumber memory s,\n        BigNumber memory e,\n        BigNumber memory m\n    ) {\n        s.verify();\n        e.verify();\n        m.verify();\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 0,
      "details": {
        "yul": false,
        "constantOptimizer": true
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373030363434343639383630"
      }
    }
  }
}